<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"toulondu.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Sharing Knowledge And Learn More">
<meta property="og:type" content="website">
<meta property="og:title" content="Toulon&#39;s BLOG">
<meta property="og:url" content="https://toulondu.github.io/index.html">
<meta property="og:site_name" content="Toulon&#39;s BLOG">
<meta property="og:description" content="Sharing Knowledge And Learn More">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Toulon Du">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://toulondu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Toulon's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Toulon's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Algorithm</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-Context%E5%92%8CHook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-Context%E5%92%8CHook/" class="post-title-link" itemprop="url">React官方文档知识点-Context和Hook</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-28 17:56:57 / 修改时间：18:20:37" itemprop="dateCreated datePublished" datetime="2020-05-28T17:56:57+08:00">2020-05-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前的进阶中其实有Context的内容，不过那里跳过了，但Hook的一些API涉及到Context的操作。所以先熟悉一下Context的内容。<br>Hook算是React中比较新的一个特性，配合Context，这让我们在管理状态的时候更加的方便，在很多情况下，如果你的应用不是那么复杂，你甚至可以放下redux。当然这一点比较见仁见智。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span><br><span class="line">&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。</span><br><span class="line">const ThemeContext &#x3D; React.createContext(&#39;light&#39;);</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span><br><span class="line">    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。</span><br><span class="line">    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;</span><br><span class="line">        &lt;Toolbar &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。</span><br><span class="line">function Toolbar() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。</span><br><span class="line">  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。</span><br><span class="line">  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。</span><br><span class="line">  static contextType &#x3D; ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MyContext &#x3D; React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p>
<p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。</p>
<h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Provider value&#x3D;&#123;&#x2F;* 某个值 *&#x2F;&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p>
<p>Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>
<p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p>
<p>通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p>
<h3 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* 基于 MyContext 组件的值进行渲染 *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType &#x3D; MyContext;</span><br></pre></td></tr></table></figure>
<p>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</p>
<p>如果你正在使用实验性的 public class fields 语法，你可以使用 static 这个类属性来初始化你的 contextType。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends React.Component &#123;</span><br><span class="line">  static contextType &#x3D; MyContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* 基于这个值进行渲染工作 *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是函数式组件，则可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value &#x3D;&gt; &#x2F;* 基于 context 值进行渲染*&#x2F;&#125;</span><br><span class="line">&lt;&#x2F;MyContext.Consumer&gt;</span><br></pre></td></tr></table></figure>


<h2 id="更复杂的情形"><a href="#更复杂的情形" class="headerlink" title="更复杂的情形"></a>更复杂的情形</h2><h3 id="动态Context"><a href="#动态Context" class="headerlink" title="动态Context"></a>动态Context</h3><p>对于上面的 theme 例子，使用动态值（dynamic values）后更复杂的用法：<br><strong>theme-context.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">export const themes &#x3D; &#123;</span><br><span class="line">    light: &#123;</span><br><span class="line">      foreground: &#39;#000000&#39;,</span><br><span class="line">      background: &#39;#eeeeee&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    dark: &#123;</span><br><span class="line">      foreground: &#39;#ffffff&#39;,</span><br><span class="line">      background: &#39;#222222&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  export const ThemeContext &#x3D; React.createContext(</span><br><span class="line">    themes.dark &#x2F;&#x2F; 默认值</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p><strong>themedButton.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class="line">import &#123;ThemeContext&#125; from &#39;.&#x2F;theme-context&#39;;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let props &#x3D; this.props;</span><br><span class="line">    let theme &#x3D; this.context;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button</span><br><span class="line">        &#123;...props&#125;</span><br><span class="line">        style&#x3D;&#123;&#123;backgroundColor: theme.background&#125;&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ThemedButton.contextType &#x3D; ThemeContext;</span><br><span class="line"></span><br><span class="line">export default ThemedButton;</span><br></pre></td></tr></table></figure>
<p><strong>App.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个使用 ThemedButton 的中间组件</span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemedButton onClick&#x3D;&#123;props.changeTheme&#125;&gt;</span><br><span class="line">      Change Theme</span><br><span class="line">    &lt;&#x2F;ThemedButton&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.toggleTheme &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">        theme:</span><br><span class="line">          state.theme &#x3D;&#x3D;&#x3D; themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在 ThemeProvider 内部的 ThemedButton 按钮组件使用 state 中的 theme 值，</span><br><span class="line">    &#x2F;&#x2F; 而外部的组件使用默认的 theme 值</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;ThemeContext.Provider value&#x3D;&#123;this.state.theme&#125;&gt;</span><br><span class="line">          &lt;Toolbar changeTheme&#x3D;&#123;this.toggleTheme&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ThemedButton &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在嵌套组件中更新Context"><a href="#在嵌套组件中更新Context" class="headerlink" title="在嵌套组件中更新Context"></a>在嵌套组件中更新Context</h3><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context。实际就是将某个高层组件的某个深层组件要用到的state和控制state变化的函数作为context，然后不需要一层一层传递，底层组件通过Consumer来获取</p>
<p><strong>theme-context.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！</span><br><span class="line">export const ThemeContext &#x3D; React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,</span><br><span class="line">  toggleTheme: () &#x3D;&gt; &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>theme-toggler-button.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ThemeContext&#125; from &#39;.&#x2F;theme-context&#39;;</span><br><span class="line"></span><br><span class="line">function ThemeTogglerButton() &#123;</span><br><span class="line">  &#x2F;&#x2F; Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123;theme, toggleTheme&#125;) &#x3D;&gt; (</span><br><span class="line">        &lt;button          onClick&#x3D;&#123;toggleTheme&#125;</span><br><span class="line">          style&#x3D;&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;&#x2F;ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ThemeTogglerButton;</span><br></pre></td></tr></table></figure>

<p><strong>app.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ThemeContext, themes&#125; from &#39;.&#x2F;theme-context&#39;;</span><br><span class="line">import ThemeTogglerButton from &#39;.&#x2F;theme-toggler-button&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.toggleTheme &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">        theme:</span><br><span class="line">          state.theme &#x3D;&#x3D;&#x3D; themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; State 也包含了更新函数，因此它会被传递进 context provider。</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: this.toggleTheme,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 整个 state 都被传递进 provider</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value&#x3D;&#123;this.state&#125;&gt;</span><br><span class="line">        &lt;Content &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Content() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemeTogglerButton &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App &#x2F;&gt;, document.root);</span><br></pre></td></tr></table></figure>

<h3 id="消费多个Context"><a href="#消费多个Context" class="headerlink" title="消费多个Context"></a>消费多个Context</h3><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Theme context，默认的 theme 是 “light” 值</span><br><span class="line">const ThemeContext &#x3D; React.createContext(&#39;light&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用户登录 context</span><br><span class="line">const UserContext &#x3D; React.createContext(&#123;</span><br><span class="line">  name: &#39;Guest&#39;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;signedInUser, theme&#125; &#x3D; this.props;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 提供初始 context 值的 App 组件</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;</span><br><span class="line">        &lt;UserContext.Provider value&#x3D;&#123;signedInUser&#125;&gt;</span><br><span class="line">          &lt;Layout &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;UserContext.Provider&gt;</span><br><span class="line">      &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Layout() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Sidebar &#x2F;&gt;</span><br><span class="line">      &lt;Content &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个组件可能会消费多个 context</span><br><span class="line">function Content() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme &#x3D;&gt; (</span><br><span class="line">        &lt;UserContext.Consumer&gt;</span><br><span class="line">          &#123;user &#x3D;&gt; (</span><br><span class="line">            &lt;ProfilePage user&#x3D;&#123;user&#125; theme&#x3D;&#123;theme&#125; &#x2F;&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;&#x2F;UserContext.Consumer&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;&#x2F;ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>上面之所以要将值放到高层组件的state中，是因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。</p>
<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<h2 id="诞生原因"><a href="#诞生原因" class="headerlink" title="诞生原因"></a>诞生原因</h2><ul>
<li>在组件之间复用状态逻辑很难</li>
<li>复杂组件变得难以理解<br>我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</li>
<li>难以理解的 class<br>Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>先看个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明一个叫 “count” 的 state 变量。</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。<br>useState 唯一的参数就是初始 state。不同于 this.state，这里的 state 不一定要是一个对象.</p>
<p><strong>声明多个state变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function ExampleWithManyStates() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明多个 state 变量！</span><br><span class="line">  const [age, setAge] &#x3D; useState(42);</span><br><span class="line">  const [fruit, setFruit] &#x3D; useState(&#39;banana&#39;);</span><br><span class="line">  const [todos, setTodos] &#x3D; useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是Hook</strong><br>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。（我们不推荐把你已有的组件全部重写，但是你可以在新组件里开始使用 Hook。）</p>
<p>React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们先介绍这些内置的 Hook。</p>
<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。</p>
<p>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 相当于 componentDidMount 和 componentDidUpdate:</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用浏览器的 API 更新页面标题</span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。</p>
<p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line"></span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return &#39;Loading...&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟 useState 一样，你可以在组件中多次使用 useEffect。<br>通过使用 Hook，你可以把组件内相关的副作用组织在一起（例如创建订阅及取消订阅），而不要把它们拆分到不同的生命周期函数里。</p>
<h2 id="hook使用规则"><a href="#hook使用规则" class="headerlink" title="hook使用规则"></a>hook使用规则</h2><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>
<ul>
<li>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</li>
</ul>
<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>有时候我们会想要在组件之间重用一些状态逻辑。目前为止，有两种主流方案来解决这个问题：高阶组件和 render props。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line"></span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以在两个组件中使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const isOnline &#x3D; useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return &#39;Loading...&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function FriendListItem(props) &#123;</span><br><span class="line">  const isOnline &#x3D; useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;li style&#x3D;&#123;&#123; color: isOnline ? &#39;green&#39; : &#39;black&#39; &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个组件的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。</p>
<p>自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 useSomething 的命名约定可以让我们的 linter 插件在使用 Hook 的代码中找到 bug。</p>
<p>你可以创建涵盖各种场景的自定义 Hook，如表单处理、动画、订阅声明、计时器，甚至可能还有更多我们没想到的场景。我们很期待看到 React 社区会出现什么样的自定义 Hook。</p>
<h2 id="其它hook"><a href="#其它hook" class="headerlink" title="其它hook"></a>其它hook</h2><p>除此之外，还有一些使用频率较低的但是很有用的 Hook。比如，useContext 让你不使用组件嵌套就可以订阅 React 的 Context。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  const locale &#x3D; useContext(LocaleContext);</span><br><span class="line">  const theme &#x3D; useContext(ThemeContext);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外 useReducer 可以让你通过 reducer 来管理组件本地的复杂 state。</p>
<p>接下来我们进一步的来看这些API到底做了什么。</p>
<h2 id="useState方法说明"><a href="#useState方法说明" class="headerlink" title="useState方法说明"></a>useState方法说明</h2><p>调用 useState 方法的时候做了什么? 它定义一个 “state 变量”。我们的变量叫 count， 但是我们可以叫他任何名字，比如 banana。这是一种在函数调用时保存变量的方式 —— useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留。</p>
<p>useState 需要哪些参数？ useState() 方法里面唯一的参数就是初始 state。不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而不一定是对象。在示例中，只需使用数字来记录用户点击次数，所以我们传了 0 作为变量的初始 state。（如果我们想要在 state 中存储两个不同的变量，只需调用 useState() 两次即可。）</p>
<p>useState 方法的返回值是什么？ 返回值为：当前 state 以及更新 state 的函数。这就是我们写 const [count, setCount] = useState() 的原因。这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。</p>
<p>你不必使用多个 state 变量。State 变量可以很好地存储对象和数组，因此，你仍然可以将相关数据分为一组。然而，不像 class 中的 this.setState，更新 state 变量总是替换它而不是合并它。</p>
<h2 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h2><p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。</p>
<h3 id="无需清除的effect"><a href="#无需清除的effect" class="headerlink" title="无需清除的effect"></a>无需清除的effect</h3><p>有时候，我们只想在 React 更新 DOM 之后运行一些额外的代码。比如<strong>发送网络请求，手动变更 DOM，记录日志</strong>，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。让我们对比一下使用 class 和 Hook 都是怎么实现这些副作用的。</p>
<p><strong>class</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Example extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用Hook</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useEffect 做了什么？ 通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。</p>
<p>useEffect 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p>
<p>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</p>
<h3 id="需要清除的effect"><a href="#需要清除的effect" class="headerlink" title="需要清除的effect"></a>需要清除的effect</h3><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 Class 和 Hook 来实现。</p>
<p>在 React class 中，你通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它。</p>
<p>例如，假设我们有一个 ChatAPI 模块，它允许我们订阅好友的在线状态。<br><strong>使用class</strong><br>略</p>
<p><strong>使用Hook</strong><br>你可能认为需要单独的 effect 来执行清除操作。但由于添加和删除订阅的代码的紧密性，所以 useEffect 的设计是在同一个地方执行。<strong>如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#x2F;&#x2F; Specify how to clean up after this effect:  实际上函数名不重要，箭头函数也行，这里只是为了体现其作用</span><br><span class="line">    return function cleanup() &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return &#39;Loading...&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p>
<p>React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。我们稍后将讨论<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update" target="_blank" rel="noopener">为什么这将助于避免 bug</a>以及<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank" rel="noopener">如何在遇到性能问题时跳过此行为</a>。</p>
<h3 id="使用多个effect实现关注点分离"><a href="#使用多个effect实现关注点分离" class="headerlink" title="使用多个effect实现关注点分离"></a>使用多个effect实现关注点分离</h3><p>我们的class中的声明周期函数内经常需要包含如上例子这样的不相关逻辑，而class写法里这些逻辑无疑会被分割到不同的生命周期中，比如componentWillMount中订阅，compnentWillUnmount中取消订阅等。而如果这样的代码较多，我们还要在同个生命周期中做不同的事情，让代码变得更加难以理解。<br>Hook的另一个作用，<strong>就是允许我们按照代码的用途来分离他们</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function FriendStatusWithCounter(props) &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么每次更新的时候都需要运行effect"><a href="#为什么每次更新的时候都需要运行effect" class="headerlink" title="为什么每次更新的时候都需要运行effect"></a>为什么每次更新的时候都需要运行effect</h3><p>如果你已经习惯了使用 class，那么你或许会疑惑为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建 bug 更少的组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如上，考虑原来的代码，<strong>当组件已经显示在屏幕上时，friend prop 发生变化时会发生什么</strong>？ 我们的组件将继续展示原来的好友状态。这是一个 bug。而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。</p>
<p>在 class 组件中，我们需要添加 componentDidUpdate 来解决这个问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">    &#x2F;&#x2F; 取消订阅之前的 friend.id</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      prevProps.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 订阅新的 friend.id</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而hook就很好的解决了这一问题。</p>
<h3 id="跳过effect进行性能优化"><a href="#跳过effect进行性能优化" class="headerlink" title="跳过effect进行性能优化"></a>跳过effect进行性能优化</h3><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  if (prevState.count !&#x3D;&#x3D; this.state.count) &#123;</span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">&#125;, [count]); &#x2F;&#x2F; 仅在 count 更改时更新</span><br></pre></td></tr></table></figure>
<p>相当于把当前的count作为第二个参数传入，重渲染调用effect的时候react会比较彼时的count和我们传入的count，如果相等，则react会跳过这个effect。<br><strong>想判断哪个参数，就传入哪个参数。</strong>对于有清除操作的effect同样适用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.friend.id]); &#x2F;&#x2F; 仅在 props.friend.id 发生变化时，重新订阅</span><br></pre></td></tr></table></figure>
<p>未来版本，可能会在构建时自动添加第二个参数。</p>
<p><strong>注意</strong>：<br>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会随时间变化并且在effect中使用的变量</strong>，否则你的代码会引用到先前渲染中的旧变量。参阅文档，了解更多关于<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">如何处理函数</a>以及<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" target="_blank" rel="noopener">数组频繁变化时的措施</a>内容。</p>
<p><strong>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行）</strong>，可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。 </p>
<p>如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 [] 作为第二个参数更接近大家更熟悉的 componentDidMount 和 componentWillUnmount 思维模式，但我们有<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">更好的方式</a>来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得额外操作很方便。</p>
<p>我们推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" target="_blank" rel="noopener">eslint-plugin-react-hooks</a> 中的 <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">exhaustive-deps</a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p>
<p>此时你可能会好奇 Hook 是如何工作的。在两次渲染间，React如何知道哪个 useState 调用对应于哪个 state 变量？React 又是如何匹配前后两次渲染中的每一个 effect 的？接着来看。</p>
<h2 id="hook规则"><a href="#hook规则" class="headerlink" title="hook规则"></a>hook规则</h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">linter 插件</a>来强制执行这些规则：</p>
<ol>
<li>只在最顶层使用 Hook<br>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</li>
<li>只在 React 函数中调用 Hook<br>不要在普通的 JavaScript 函数中调用 Hook。你可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li>
</ol>
<h3 id="eslint插件"><a href="#eslint插件" class="headerlink" title="eslint插件"></a>eslint插件</h3><p>我们发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来强制执行这两条规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-plugin-react-hooks --save-dev</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 你的 ESLint 配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &quot;react-hooks&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &quot;react-hooks&#x2F;rules-of-hooks&quot;: &quot;error&quot;, &#x2F;&#x2F; 检查 Hook 的规则</span><br><span class="line">    &quot;react-hooks&#x2F;exhaustive-deps&quot;: &quot;warn&quot; &#x2F;&#x2F; 检查 effect 的依赖</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回答上面的问题，React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。<br>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。但如果我们将一个 Hook (例如 persistForm effect) 调用放到一个条件语句中，Hook的调用顺序可能就会发生改变，从而导致bug。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 🔴 在条件语句中使用 Hook 违反第一条规则</span><br><span class="line">  if (name !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">    useEffect(function persistForm() &#123;</span><br><span class="line">      localStorage.setItem(&#39;formData&#39;, name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么 Hook 需要在我们组件的最顶层调用。如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(function persistForm() &#123;</span><br><span class="line">   &#x2F;&#x2F; 👍 将条件判断放置在 effect 中</span><br><span class="line">   if (name !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">     localStorage.setItem(&#39;formData&#39;, name);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果使用了提供的 lint 插件，就无需担心此问题。</strong></p>
<h2 id="自定义Hook-1"><a href="#自定义Hook-1" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</p>
<p>在我们学习使用 Effect Hook 时，我们已经见过这个聊天程序中的组件，该组件用于显示好友的在线状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return &#39;Loading...&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为绿色。我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中来，但这并不是理想的解决方案。<br>相反，我们希望在 FriendStatus 和 FriendListItem 之间共享逻辑。<br>目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: render props 和高阶组件，现在让我们来看看 Hook 是如何在让你不增加组件的情况下解决相同问题的。</p>
<h3 id="提取自定义-Hook"><a href="#提取自定义-Hook" class="headerlink" title="提取自定义 Hook"></a>提取自定义 Hook</h3><p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。</p>
<p><strong>自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与组件中一致，请确保只在自定义 Hook 的顶层无条件地调用其他 Hook。</p>
<p>与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。</p>
<h3 id="使用自定义Hook"><a href="#使用自定义Hook" class="headerlink" title="使用自定义Hook"></a>使用自定义Hook</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unction FriendStatus(props) &#123;</span><br><span class="line">  const isOnline &#x3D; useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return &#39;Loading...&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function FriendListItem(props) &#123;</span><br><span class="line">  const isOnline &#x3D; useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;li style&#x3D;&#123;&#123; color: isOnline ? &#39;green&#39; : &#39;black&#39; &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码等价于原来的示例代码吗？等价，它的工作方式完全一样。如果你仔细观察，你会发现我们没有对其行为做任何的改变，我们只是将两个函数之间一些共同的代码提取到单独的函数中。</p>
<p>所以，<strong>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</strong></p>
<p>几个点：</p>
<ul>
<li><strong>自定义 Hook 必须以 “use” 开头。</strong>  不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。</li>
<li><strong>在两个组件中使用相同的 Hook 不会共享 state。</strong>  自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</li>
<li><strong>自定义 Hook 如何获取独立的 state?</strong> 每次调用 Hook，它都会获取独立的 state。由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect。 正如我们在之前章节中了解到的一样，我们可以在一个组件中多次调用 useState 和 useEffect，它们是完全独立的。</li>
</ul>
<h3 id="在多个-Hook-之间传递信息"><a href="#在多个-Hook-之间传递信息" class="headerlink" title="在多个 Hook 之间传递信息"></a>在多个 Hook 之间传递信息</h3><p>由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const friendList &#x3D; [</span><br><span class="line">  &#123; id: 1, name: &#39;Phoebe&#39; &#125;,</span><br><span class="line">  &#123; id: 2, name: &#39;Rachel&#39; &#125;,</span><br><span class="line">  &#123; id: 3, name: &#39;Ross&#39; &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function ChatRecipientPicker() &#123;</span><br><span class="line">  const [recipientID, setRecipientID] &#x3D; useState(1);</span><br><span class="line">  const isRecipientOnline &#x3D; useFriendStatus(recipientID);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Circle color&#x3D;&#123;isRecipientOnline ? &#39;green&#39; : &#39;red&#39;&#125; &#x2F;&gt;</span><br><span class="line">      &lt;select</span><br><span class="line">        value&#x3D;&#123;recipientID&#125;</span><br><span class="line">        onChange&#x3D;&#123;e &#x3D;&gt; setRecipientID(Number(e.target.value))&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;friendList.map(friend &#x3D;&gt; (</span><br><span class="line">          &lt;option key&#x3D;&#123;friend.id&#125; value&#x3D;&#123;friend.id&#125;&gt;</span><br><span class="line">            &#123;friend.name&#125;</span><br><span class="line">          &lt;&#x2F;option&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将当前选择的好友 ID 保存在 recipientID 状态变量中，并在用户从 <code>&lt;select&gt;</code> 中选择其他好友时更新这个 state。</p>
<p>由于 useState 为我们提供了 recipientID 状态变量的最新值，因此我们可以将它作为参数传递给自定义的 useFriendStatus Hook。<br>如此可以让我们知道当前选中的好友是否在线。当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatus Hook 将会取消订阅之前选中的好友，并订阅新选中的好友状态。</p>
<p>既然函数组件能够做的更多，那么代码库中函数组件的代码行数可能会剧增。这属于正常现象 —— 不必立即将它们拆分为 Hook。但我们仍鼓励你能通过自定义 Hook 寻找可能，以达到简化代码逻辑，解决组件杂乱无章的目的。</p>
<h3 id="发挥想象"><a href="#发挥想象" class="headerlink" title="发挥想象"></a>发挥想象</h3><p>有个复杂的组件，其中包含了大量以特殊的方式来管理的内部状态。useState 并不会使得集中更新逻辑变得容易，因此你可能更愿意使用 redux 中的 reducer 来编写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function todosReducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;add&#39;:</span><br><span class="line">      return [...state, &#123;</span><br><span class="line">        text: action.text,</span><br><span class="line">        completed: false</span><br><span class="line">      &#125;];</span><br><span class="line">    &#x2F;&#x2F; ... other actions ...</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reducers 非常便于单独测试，且易于扩展，以表达复杂的更新逻辑。如有必要，您可以将它们分成更小的 reducer。但是，你可能还享受着 React 内部 state 带来的好处，或者可能根本不想安装其他库。</p>
<p>那么，为什么我们不编写一个 useReducer 的 Hook，使用 reducer 的方式来管理组件的内部 state 呢？其简化版本可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function useReducer(reducer, initialState) &#123;</span><br><span class="line">  const [state, setState] &#x3D; useState(initialState);</span><br><span class="line"></span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    const nextState &#x3D; reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [state, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用它，让 reducer 驱动它管理 state：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Todos() &#123;</span><br><span class="line">  const [todos, dispatch] &#x3D; useReducer(todosReducer, []);</span><br><span class="line"></span><br><span class="line">  function handleAddClick(text) &#123;</span><br><span class="line">    dispatch(&#123; type: &#39;add&#39;, text &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在复杂组件中使用 reducer 管理内部 state 的需求很常见，我们已经将 useReducer 的 Hook 内置到 React 中。你可以在 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">Hook API 索引</a>中找到它使用，搭配其他内置的 Hook 一起使用。</p>
<h1 id="Hook的API"><a href="#Hook的API" class="headerlink" title="Hook的API"></a>Hook的API</h1><p>Hook的API大致分为两类。</p>
<p>基础 Hook</p>
<ul>
<li>useState</li>
<li>useEffect</li>
<li>useContext</li>
</ul>
<p>额外的 Hook</p>
<ul>
<li>useReducer</li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
</ul>
<h2 id="基础Hook"><a href="#基础Hook" class="headerlink" title="基础Hook"></a>基础Hook</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] &#x3D; useState(initialState);</span><br></pre></td></tr></table></figure>
<p>除了之前介绍的用法。</p>
<p>还可以进行<br><strong>函数式更新</strong><br>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 setState 的两种用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Counter(&#123;initialCount&#125;) &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(initialCount);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(initialCount)&#125;&gt;Reset&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(prevCount &#x3D;&gt; prevCount - 1)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(prevCount &#x3D;&gt; prevCount + 1)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。</p>
<p>注意：与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。<br>useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p>
<p><strong>惰性初始state</strong><br>initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;</span><br><span class="line">  const initialState &#x3D; someExpensiveComputation(props);</span><br><span class="line">  return initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>跳过state更新</strong><br>调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state。）</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(didUpdate);</span><br></pre></td></tr></table></figure>
<p>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p>
<p>默认情况下，effect 将在每轮渲染结束后执行。前面说到过，但你可以选择让它 在只有某些值改变的时候 才执行。</p>
<p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
<p>然而，并非所有 effect 都可以被延迟执行。例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 <strong>useLayoutEffect Hook</strong> 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p>
<p>虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p>
<p><strong>effect 的条件执行</strong><br>即前面说到的第二个参数,它是 effect 所依赖的值数组。更新后的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">  () &#x3D;&gt; &#123;</span><br><span class="line">    const subscription &#x3D; props.source.subscribe();</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      subscription.unsubscribe();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [props.source],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>此时，只有当 props.source 改变后才会重新创建订阅。</p>
<p>再次强调，<strong>请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量</strong>。 见<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">如何处理函数</a>和<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" target="_blank" rel="noopener">数组频繁变化时的措施</a></p>
<p>这里确实有一点麻烦，需要自己传入对应的prop，state或二者的衍生值才能完成优化。未来编译器会更加智能，届时自动创建数组将成为可能。</p>
<p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。但这需要你的effect函数确实没有引用 props、state 以及由它们衍生而来的值。</p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value &#x3D; useContext(MyContext);</span><br></pre></td></tr></table></figure>
<p>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 value prop 决定。<br>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code>更新时，该 Hook 会触发重渲染.即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。</p>
<p>别忘记 useContext 的参数必须是 context 对象本身：</p>
<ul>
<li>正确： useContext(MyContext)</li>
<li>错误： useContext(MyContext.Consumer)</li>
<li>错误： useContext(MyContext.Provider)</li>
</ul>
<p>调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693" target="_blank" rel="noopener">通过使用 memoization 来优化</a>。</p>
<p>注意：<br>useContext(MyContext) 相当于 class 组件中的 static contextType = MyContext 或者 <code>&lt;MyContext.Consumer&gt;</code>。<br>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件提供 context。</p>
<h2 id="额外的Hook"><a href="#额外的Hook" class="headerlink" title="额外的Hook"></a>额外的Hook</h2><p>以下介绍的 Hook，有些是上一节中基础 Hook 的变体，有些则仅在特殊情况下会用到。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<p>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）<br>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;reducer为单独定义的函数</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;increment&#39;:</span><br><span class="line">      &#x2F;&#x2F;注意这里，不用返回dispath，react会帮我们实现，跟redux基本一致</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 dispatch。</p>
<p><strong>惰性初始化</strong><br>注意到useReducer的第三个参数。用于让我们可以选择 惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。<br>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function init(initialCount) &#123;</span><br><span class="line">  return &#123;count: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    case &#39;reset&#39;:</span><br><span class="line">      return init(action.payload);</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter(&#123;initialCount&#125;) &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialCount, init);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;reset&#39;, payload: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const memoizedCallback &#x3D; useCallback(</span><br><span class="line">  () &#x3D;&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>返回一个 memoized 回调函数。<br>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<p>返回一个 memoized 值。</p>
<p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
<p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p>
<p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p>
<p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。</p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const refContainer &#x3D; useRef(initialValue);</span><br></pre></td></tr></table></figure>

<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
<p>尽可能使用标准的 useEffect 以避免阻塞视觉更新。</p>
<p>我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。</p>
<p>如果你使用服务端渲染，请记住，无论 useLayoutEffect 还是 useEffect 都无法在 Javascript 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码时会触发 React 告警。解决这个问题，需要将代码逻辑移至 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 useLayoutEffect 执行之前 HTML 都显示错乱的情况下）。</p>
<p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild &amp;&amp; <code>&lt;Child /&gt;</code> 进行条件渲染，并使用 useEffect(() =&gt; { setShowChild(true); }, []) 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。</p>
<h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">React官方文档知识点-进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-28 17:56:33 / 修改时间：18:10:06" itemprop="dateCreated datePublished" datetime="2020-05-28T17:56:33+08:00">2020-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>承接上一篇文章。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-无障碍辅助功能"><a href="#1-无障碍辅助功能" class="headerlink" title="1.无障碍辅助功能"></a>1.无障碍辅助功能</h3><p>无障碍辅助功能是让所有人都能够获得服务的一种设计。<br>关于React中对此功能的全面要点：<a href="https://zh-hans.reactjs.org/docs/accessibility.html" target="_blank" rel="noopener">点击这里</a></p>
<h3 id="2-代码分割"><a href="#2-代码分割" class="headerlink" title="2.代码分割"></a>2.代码分割</h3><p>大多数 React 应用都会使用 Webpack，Rollup 或 Browserify 这类的构建工具来打包文件。 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。 接着在页面上引入该 bundle，整个应用即可一次性加载。</p>
<p>而现在的前端应用大多都会整合非常多第三方库，为了避免打包出的代码包过大导致加载时间边长。我们应该尽早思考对代码进行代码分割。代码分割是上诉打包工具支持的一项技术，能够创建多个包并在运行时动态加载。<br>它可以让你“懒加载”用户所需要的内容，避免加载永远不需要的代码，并在初始加载时减少所需加载的代码量，从而显著提高应用性能。</p>
<p>比如你的网站有20个网页，而某个用户可能只使用其中2个网页，另外18个网页的内容，用户是不需要加载的。</p>
<p>使用方法：</p>
<ul>
<li><p>import</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用前</span><br><span class="line">import &#123; add &#125; from &#39;.&#x2F;math&#39;;</span><br><span class="line">console.log(add(16, 26));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用后</span><br><span class="line">import(&quot;.&#x2F;math&quot;).then(math &#x3D;&gt; &#123;</span><br><span class="line">  console.log(math.add(16, 26));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你自己配置 Webpack，你可能要阅读下 Webpack 关于<a href="https://webpack.docschina.org/guides/code-splitting/" target="_blank" rel="noopener">代码分割</a>的指南。你的 Webpack 配置应该<a href="https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269" target="_blank" rel="noopener">类似于此</a>。</p>
</li>
<li><p>React.lazy<br>React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用前</span><br><span class="line">import OtherComponent from &#39;.&#x2F;OtherComponent&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用后</span><br><span class="line">const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</span><br></pre></td></tr></table></figure>
<p>此代码将会在组件首次渲染时，自动导入包含 OtherComponent 组件的包。<br>React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。<br>然后你应在 <strong>Suspense</strong> 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense &#125; from &#39;react&#39;;</span><br><span class="line">const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class="line">        &lt;OtherComponent &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Suspense&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。</p>
</li>
</ul>
<p>PS：React.lazy 目前只支持默认导出（default exports）</p>
<ul>
<li><p>异常捕获边界(Error boundaries)<br>如果模块加载失败（如网络问题），它会触发一个错误。你可以通过<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">异常捕获边界（Error boundaries）</a>技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。</p>
</li>
<li><p>基于路由的代码分割<br>另一个很简单的代码分割方式就是基于路由。<br>使用React.lazy 和 <a href="https://react-router.docschina.org/" target="_blank" rel="noopener">React Router</a> 这类的第三方库，来配置基于路由的代码分割。</p>
</li>
</ul>
<h3 id="3-Context"><a href="#3-Context" class="headerlink" title="3.Context"></a>3.Context</h3><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。<br>使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span><br><span class="line">&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。</span><br><span class="line">const ThemeContext &#x3D; React.createContext(&#39;light&#39;);</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span><br><span class="line">    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。</span><br><span class="line">    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;</span><br><span class="line">        &lt;Toolbar &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。</span><br><span class="line">function Toolbar() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。</span><br><span class="line">  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。</span><br><span class="line">  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。</span><br><span class="line">  static contextType &#x3D; ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请谨慎使用context，因为这会使得组件的复用性变差。</p>
<p>如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。</p>
<p>比如在一个Page组件内，它层层向下传递user和avatarSize属性，从而较深的Avatar组件可以读取到这些属性。如果最后只有Avatar需要这个变量，层层传递就显得比较蠢，此时除了使用context，还可以的一种方法是直接在page中构造好avatar组件，然后传递下去。</p>
<p>这种对组件的控制反转减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。</p>
<p><a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">context的使用方法</a></p>
<h3 id="4-错误边界"><a href="#4-错误边界" class="headerlink" title="4.错误边界"></a>4.错误边界</h3><p>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p>
<p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>
<p>错误边界无法捕获以下场景中产生的错误：</p>
<ul>
<li>事件处理,因为事件处理器不会再渲染期间触发，so使用try/catch来捕获。</li>
<li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
<p>如果一个 class 组件中定义了 static <strong>getDerivedStateFromError()</strong> 或 <strong>componentDidCatch()</strong> 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。<br>当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; 更新 state 使下一次渲染能够显示降级后的 UI</span><br><span class="line">    return &#123; hasError: true &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F; 你同样可以将错误日志上报给服务器</span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      &#x2F;&#x2F; 你可以自定义降级后的 UI 并渲染</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;&#x2F;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p>
<p>错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃。</p>
<p>PS:自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。</p>
<h3 id="5-Refs-和-DOM"><a href="#5-Refs-和-DOM" class="headerlink" title="5.Refs 和 DOM"></a>5.Refs 和 DOM</h3><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。<br>在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。  </p>
<p>下面是几个适合使用 refs 的情况：</p>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。举个例子，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性。</p>
<p>两种使用refs的方式：<br>1.React.createRef()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    &#x2F;&#x2F; 创建一个 ref 来存储 textInput 的 DOM 元素</span><br><span class="line">    this.textInput &#x3D; React.createRef();</span><br><span class="line">    this.focusTextInput &#x3D; this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接使用原生 API 使 text 输入框获得焦点</span><br><span class="line">    &#x2F;&#x2F; 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br><span class="line">    this.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br><span class="line">    &#x2F;&#x2F; 构造器里创建的 &#96;textInput&#96; 上</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;text&quot;</span><br><span class="line">          ref&#x3D;&#123;this.textInput&#125; &#x2F;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;button&quot;</span><br><span class="line">          value&#x3D;&quot;Focus the text input&quot;</span><br><span class="line">          onClick&#x3D;&#123;this.focusTextInput&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 会在组件挂载时给 current 属性传入 DOM 元素，并在组件卸载时传入 null 值。ref 会在 componentDidMount 或 componentDidUpdate 生命周期钩子触发前更新。</p>
<ul>
<li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</li>
<li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。</li>
</ul>
<p>2.回调ref</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.textInput &#x3D; null;</span><br><span class="line"></span><br><span class="line">    this.setTextInputRef &#x3D; element &#x3D;&gt; &#123;</span><br><span class="line">      this.textInput &#x3D; element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.focusTextInput &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 使用原生 DOM API 使 text 输入框获得焦点</span><br><span class="line">      if (this.textInput) this.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    &#x2F;&#x2F; 组件挂载后，让文本框自动获得焦点</span><br><span class="line">    this.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用 &#96;ref&#96; 的回调函数将 text 输入框 DOM 节点的引用存储到 React</span><br><span class="line">    &#x2F;&#x2F; 实例上（比如 this.textInput）</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;text&quot;</span><br><span class="line">          ref&#x3D;&#123;this.setTextInputRef&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;button&quot;</span><br><span class="line">          value&#x3D;&quot;Focus the text input&quot;</span><br><span class="line">          onClick&#x3D;&#123;this.focusTextInput&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
<p>注：var func_name = function(){}这种形式定义的函数为内联函数。</p>
<p>在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。<br>这种情况下我们推荐使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">ref 转发</a>。Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。关于怎样对父组件暴露子组件的 DOM 节点，在 ref 转发文档中有一个详细的例子。</p>
<h3 id="6-Fragments"><a href="#6-Fragments" class="headerlink" title="6.Fragments"></a>6.Fragments</h3><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA &#x2F;&gt;</span><br><span class="line">      &lt;ChildB &#x2F;&gt;</span><br><span class="line">      &lt;ChildC &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种段语法,看起来有点诡异，即空标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Columns extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用显式 &lt;React.Fragment&gt; 语法声明的片段可能具有 key。一个使用场景是将一个集合映射到一个 Fragments 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Glossary(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &#123;props.items.map(item &#x3D;&gt; (</span><br><span class="line">        &#x2F;&#x2F; 没有&#96;key&#96;，React 会发出一个关键警告</span><br><span class="line">        &lt;React.Fragment key&#x3D;&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.term&#125;&lt;&#x2F;dt&gt;</span><br><span class="line">          &lt;dd&gt;&#123;item.description&#125;&lt;&#x2F;dd&gt;</span><br><span class="line">        &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;&#x2F;dl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key 是目前唯一可以传递给 Fragment 的属性。</p>
<h3 id="7-高阶组件"><a href="#7-高阶组件" class="headerlink" title="7.高阶组件"></a>7.高阶组件</h3><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
<p>可以对应高阶函数来理解，高阶函数为函数作为参数传递，函数作为返回值。<br>而高阶组件则是参数为组件，返回值为新组件的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent &#x3D; higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>
<p>HOC 在 React 的第三方库中很常见，例如 Redux 的 connect 和 Relay 的 createFragmentContainer。</p>
<p>一大作用就是将组件间相同的业务逻辑进行抽象，比如2个组件都依赖于某个外部数据进行渲染，那么获取这个外部数据和监听其改变的方式就可以放到高阶组件中进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此函数接收一个组件...</span><br><span class="line">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...并返回另一个组件...</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">      this.state &#x3D; &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      &#x2F;&#x2F; ...负责订阅相关的操作...</span><br><span class="line">      DataSource.addChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, this.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!</span><br><span class="line">      &#x2F;&#x2F; 请注意，我们可能还会传递其他属性</span><br><span class="line">      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。</p>
<p>不要试图在 HOC 中修改组件原型（或以其他方式改变它）。因为这种修改会导致组件行为永远发生变化。</p>
<p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function logProps(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&#39;Current props: &#39;, this.props);</span><br><span class="line">      console.log(&#39;Previous props: &#39;, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &#x2F;&#x2F; 将 input 组件包装在容器中，而不对其进行修改。Good!</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可能已经注意到 HOC 与容器组件模式之间有相似之处。容器组件担任分离将高层和低层关注的责任，由容器管理订阅和状态，并将 prop 传递给处理渲染 UI。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p>
<p>来看看redux的connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; React Redux 的 &#96;connect&#96; 函数</span><br><span class="line">const ConnectedComment &#x3D; connect(commentSelector, commentActions)(CommentList);</span><br></pre></td></tr></table></figure>
<p>发生了什么？！如果你把它分开，就会更容易看出发生了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; connect 是一个函数，它的返回值为另外一个函数。</span><br><span class="line">const enhance &#x3D; connect(commentListSelector, commentListActions);</span><br><span class="line">&#x2F;&#x2F; 返回值为 HOC，它会返回已经连接 Redux store 的组件</span><br><span class="line">const ConnectedComment &#x3D; enhance(CommentList);</span><br></pre></td></tr></table></figure>
<p>换句话说，connect 是一个返回高阶组件的高阶函数！</p>
<p>这种形式可能看起来令人困惑或不必要，但它有一个有用的属性, 充当装饰器，多个装饰器可以一起使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 而不是这样...</span><br><span class="line">const EnhancedComponent &#x3D; withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ... 你可以编写组合工具函数</span><br><span class="line">&#x2F;&#x2F; compose(f, g, h) 等同于 (...args) &#x3D;&gt; f(g(h(...args)))</span><br><span class="line">const enhance &#x3D; compose(</span><br><span class="line">  &#x2F;&#x2F; 这些都是单参数的 HOC</span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector)</span><br><span class="line">)</span><br><span class="line">const EnhancedComponent &#x3D; enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>
<p>许多第三方库都提供了 compose 工具函数，包括 lodash （比如 lodash.flowRight）， Redux 和 Ramda。</p>
<p>注意点：</p>
<ul>
<li>不要在 render 方法中使用 HOC</li>
<li>务必复制静态方法</li>
<li>Refs 不会被传递</li>
</ul>
<h3 id="8-与其它视图库集成"><a href="#8-与其它视图库集成" class="headerlink" title="8.与其它视图库集成"></a>8.与其它视图库集成</h3><p>得益于 ReactDOM.render() 的灵活性 React 可以被嵌入到其他的应用中。</p>
<p>虽然 React 通常被用来在启动的时候加载一个单独的根 React 组件到 DOM 上，ReactDOM.render() 同样可以在 UI 的独立部分上多次调用，这些部分可以小到一个按钮，也可以大到一个应用。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;#container&#39;).html(&#39;&lt;button id&#x3D;&quot;btn&quot;&gt;Say Hello&lt;&#x2F;button&gt;&#39;);</span><br><span class="line">$(&#39;#btn&#39;).click(function() &#123;</span><br><span class="line">  alert(&#39;Hello!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>改造成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Button(props) &#123;</span><br><span class="line">  return &lt;button onClick&#x3D;&#123;props.onClick&#125;&gt;Say Hello&lt;&#x2F;button&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloButton() &#123;</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    alert(&#39;Hello!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;Button onClick&#x3D;&#123;handleClick&#125; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloButton &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;container&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="9-深入JSX"><a href="#9-深入JSX" class="headerlink" title="9.深入JSX"></a>9.深入JSX</h3><p>实际上，JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。<br>值得说的点：</p>
<ul>
<li><p>Props 默认值为 “True”，如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete&#x3D;&#123;true&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>属性展开：如果你已经有了一个 props 对象，你可以使用展开运算符 … 来在 JSX 中传递整个 props 对象。还可以选择只保留当前组件需要接收的 props，并使用展开运算符将其他 props 传递下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Button &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; kind, ...other &#125; &#x3D; props;</span><br><span class="line">  const className &#x3D; kind &#x3D;&#x3D;&#x3D; &quot;primary&quot; ? &quot;PrimaryButton&quot; : &quot;SecondaryButton&quot;;</span><br><span class="line">  return &lt;button className&#x3D;&#123;className&#125; &#123;...other&#125; &#x2F;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作为子元素。 你可以将任何东西作为子元素传递给自定义组件，只要确保在该组件渲染之前能够被转换成 React 理解的对象。这种用法并不常见，但可以用于扩展 JSX。</p>
</li>
<li><p>false, null, undefined, and true 是合法的子元素。但它们并不会被渲染。值得注意的是有一些 “falsy” 值，如数字 0，仍然会被 React 渲染。 所以不要用 aa.length &amp;&amp; Component 这种形式。改成aa.length&gt;0即可。</p>
</li>
</ul>
<h3 id="10-性能优化"><a href="#10-性能优化" class="headerlink" title="10.性能优化"></a>10.性能优化</h3><p>UI 更新需要昂贵的 DOM 操作，而 React 内部使用几种巧妙的技术以便最小化 DOM 操作次数。</p>
<p><strong>首先，使用生产版本。</strong><br>React 默认包含了许多有用的警告信息。这些警告信息在开发过程中非常有帮助。然而这使得 React 变得更大且更慢，所以你需要确保部署时使用了生产版本。可通过chrome的<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">React开发者工具来检查</a>。图标为蓝色表示生产版本，图片红色表示开发模式。<br><a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">这里</a>有webpack,Brunch,Browserify,Rollup来进行生产构建的方法。</p>
<p><strong>使用chrome performance标签分析组件</strong><br>在开发模式下，你可以通过支持的浏览器可视化地了解组件是如何 挂载、更新以及卸载的。<br>在 Chrome 中进行如下操作：</p>
<ol>
<li>临时禁用所有的 Chrome 扩展，尤其是 React 开发者工具。他们会严重干扰度量结果！</li>
<li>确保你是在 React 的开发模式下运行应用。</li>
<li>打开 Chrome 开发者工具的 Performance 标签并按下 Record。</li>
<li>对你想分析的行为进行复现。尽量在 20 秒内完成以避免 Chrome 卡住。</li>
<li>停止记录。</li>
<li>在 User Timing 标签下会显示 React 归类好的事件。<br>这能帮助你查看是否有不相关的组件被错误地更新，以及 UI 更新的深度和频率。</li>
</ol>
<p><strong>使用开发者工具中的分析器对组件进行分析</strong><br>在开发模式下，React 开发者工具会出现分析器标签。 你可以在<a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">《介绍 React 分析器》</a>这篇博客中了解概述。 你也可以在 <a href="https://www.youtube.com/watch?v=nySib7ipZdk" target="_blank" rel="noopener">YouTube</a> 上观看分析器的视频指导。</p>
<p><strong>虚拟化长列表</strong><br>如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。</p>
<p><a href="https://react-window.now.sh/" target="_blank" rel="noopener">react-window</a> 和 <a href="https://bvaughn.github.io/react-virtualized/" target="_blank" rel="noopener">react-virtualized</a> 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。 如果你想要一些针对你的应用做定制优化，你也可以创建你自己的虚拟滚动组件，就像 Twitter 所做的。</p>
<p><strong>避免调停</strong><br>React 构建并维护了一套内部的 UI 渲染描述。它包含了来自你的组件返回的 React 元素。即虚拟DOM，使得 React 避免创建 DOM 节点以及没有必要的节点访问，因为 DOM 操作相对于 JavaScript 对象操作更慢。</p>
<p>当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM。<br>即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法 shouldComponentUpdate 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 true，让 React 执行更新。<br>如果你知道在什么情况下你的组件不需要更新，你可以在 shouldComponentUpdate 中返回 false 来跳过整个渲染过程。其包括该组件的 render 调用以及之后的操作。<br>在大部分情况下，你可以继承 React.PureComponent 以代替手写 shouldComponentUpdate()。它用当前与之前 props 和 state 的浅比较覆写了 shouldComponentUpdate() 的实现。</p>
<p><strong>不可变数据的力量</strong><br>这点之前已经说过，比如对于数组，用concat避免直接在原来的数组上push。 对于对象，用Object.assign避免直接修改对象中的值。</p>
<p>当处理深层嵌套对象时，以 immutable （不可变）的方式更新它们令人费解。如遇到此类问题，请参阅 <a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a> 或 <a href="https://github.com/kolodny/immutability-helper" target="_blank" rel="noopener">immutability-helper</a>。这些库会帮助你编写高可读性的代码，且不会失去 immutability （不可变性）带来的好处。</p>
<h3 id="11-Portals"><a href="#11-Portals" class="headerlink" title="11.Portals"></a>11.Portals</h3><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>
<p>通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点。然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的。<br>一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  &#x2F;&#x2F; React 并*没有*创建一个新的 div。它只是把子元素渲染到 &#96;domNode&#96; 中。</span><br><span class="line">  &#x2F;&#x2F; &#96;domNode&#96; 是一个可以在任何位置的有效 DOM 节点。</span><br><span class="line">  return ReactDOM.createPortal(</span><br><span class="line">    this.props.children,</span><br><span class="line">    domNode</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:当在使用 portal 时, 记住<a href="https://zh-hans.reactjs.org/docs/accessibility.html#programmatically-managing-focus" target="_blank" rel="noopener">管理键盘焦点</a>就变得尤为重要。</p>
<p>对于模态对话框，通过遵循 <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" target="_blank" rel="noopener">WAI-ARIA 模态开发实践</a>，来确保每个人都能够运用它。</p>
<p><a href="https://codepen.io/gaearon/pen/yzMaBd" target="_blank" rel="noopener">这里</a>有一个关于用portal创建模态对话框的示例。</p>
<p>一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树 中的祖先。假设存在如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app-root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;modal-root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>在 #app-root 里的 Parent 组件能够捕获到未被捕获的从兄弟节点 #modal-root 冒泡上来的事件。<br><a href="https://codepen.io/gaearon/pen/jGBWpE" target="_blank" rel="noopener">codepen实例</a><br>在父组件里捕获一个来自 portal 冒泡上来的事件，使之能够在开发时具有不完全依赖于 portal 的更为灵活的抽象。例如，如果你在渲染一个 <Modal /> 组件，无论其是否采用 portal 实现，父组件都能够捕获其事件。</p>
<h3 id="12-Profiler-API"><a href="#12-Profiler-API" class="headerlink" title="12.Profiler API"></a>12.Profiler API</h3><p>Profiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用类似 <a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations" target="_blank" rel="noopener">memoization 优化</a>的部分，并从相关优化中获益。<br><a href="https://zh-hans.reactjs.org/docs/profiler.html" target="_blank" rel="noopener">这里</a>了解详情。</p>
<h3 id="13-React-Diffing的原理-协调算法"><a href="#13-React-Diffing的原理-协调算法" class="headerlink" title="13.React Diffing的原理 协调算法"></a>13.React Diffing的原理 协调算法</h3><p>在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。<br>这个算法问题有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作数。 然而，即使在最前沿的算法中，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量。<br>这无疑有些难以接受，React基于真实使用环境做出2个假设，在其基础上提出了一套O(n)的算法：</p>
<ol>
<li>两个不同类型的元素会产生出不同的树；</li>
<li>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；</li>
</ol>
<p><strong>Diffing算法</strong><br>当对比两颗树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。</p>
<ol>
<li>比对不同类型的元素<br>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。<br>当拆卸一棵树时，对应的 DOM 节点也会被销毁。在根节点以下的组件也会被卸载，它们的状态会被销毁。</li>
<li>比对同一类型的元素<br>当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如className变了就只更新className属性，当style属性更新是，也仅更新有所改变的属性，比如color等。<br>处理完当前节点之后，React 继续对子节点进行递归。</li>
<li>比对同类型的组件元素<br>当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。<br>下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。</li>
<li>对子节点进行递归<br>在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。<br>在子元素列表末尾新增元素时，更变开销比较小。React 会针对每个子元素 mutate 而不是保持相同的 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code> 子树完成。这种情况下的低效可能会带来性能问题。<br>所以引进了key属性。</li>
</ol>
<p><strong>总之</strong><br>React 可以在每个 action 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 render 方法，这不代表 React 会卸载或装载它们。React 只会基于以上提到的规则来决定如何进行差异的合并。<br>由于 React 依赖探索的算法，因此当以下假设没有得到满足，性能会有所损耗。</p>
<ol>
<li>该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题。</li>
<li>Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。</li>
</ol>
<h3 id="14-render-props"><a href="#14-render-props" class="headerlink" title="14.render props"></a>14.render props</h3><p>术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p>
<p>具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render&#x3D;&#123;data &#x3D;&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">)&#125;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>使用 render prop 的库有 React Router、Downshift 以及 Formik。<br>更具体地说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse &#x3D; this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src&#x3D;&quot;&#x2F;cat.jpg&quot; style&#x3D;&#123;&#123; position: &#39;absolute&#39;, left: mouse.x, top: mouse.y &#125;&#125; &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove &#x3D; this.handleMouseMove.bind(this);</span><br><span class="line">    this.state &#x3D; &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style&#x3D;&#123;&#123; height: &#39;100vh&#39; &#125;&#125; onMouseMove&#x3D;&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;&#x2F;*</span><br><span class="line">          Instead of providing a static representation of what &lt;Mouse&gt; renders,</span><br><span class="line">          use the &#96;render&#96; prop to dynamically determine what to render.</span><br><span class="line">        *&#x2F;&#125;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;Mouse render&#x3D;&#123;mouse &#x3D;&gt; (</span><br><span class="line">          &lt;Cat mouse&#x3D;&#123;mouse&#125; &#x2F;&gt;</span><br><span class="line">        )&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这项技术使我们共享行为非常容易。要获得这个行为，只要渲染一个带有 render prop 的 <Mouse> 组件就能够告诉它当前鼠标坐标 (x, y) 要渲染什么。</p>
<p>关于 render prop 一个有趣的事情是你可以使用带有 render prop 的常规组件来实现大多数高阶组件 (HOC)。 例如，如果你更喜欢使用 withMouse HOC而不是 <Mouse> 组件，你可以使用带有 render prop 的常规 <Mouse> 轻松创建一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果你出于某种原因真的想要 HOC，那么你可以轻松实现</span><br><span class="line">&#x2F;&#x2F; 使用具有 render prop 的普通组件创建一个！</span><br><span class="line">function withMouse(Component) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Mouse render&#x3D;&#123;mouse &#x3D;&gt; (</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse&#x3D;&#123;mouse&#125; &#x2F;&gt;</span><br><span class="line">        )&#125;&#x2F;&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的是要记住，render prop 是因为模式才被称为 render prop ，你不一定要用名为 render 的 prop 来使用这种模式。事实上， <strong>任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”.</strong></p>
<h3 id="15-静态类型检查"><a href="#15-静态类型检查" class="headerlink" title="15.静态类型检查"></a>15.静态类型检查</h3><p>像 Flow 和 TypeScript 等这些静态类型检查器，可以在运行前识别某些类型的问题。他们还可以通过增加自动补全等功能来改善开发者的工作流程。出于这个原因，我们建议在大型代码库中使用 Flow 或 TypeScript 来代替 PropTypes。</p>
<p>Flow介绍在<a href="https://zh-hans.reactjs.org/docs/static-type-checking.html" target="_blank" rel="noopener">这里</a></p>
<p><strong>typescript</strong><br>TypeScript 是一种由微软开发的编程语言。它是 JavaScript 的一个类型超集，包含独立的编译器。作为一种类型语言，TypeScript 可以在构建时发现 bug 和错误，这样程序运行时就可以避免此类错误。您可以通过<a href="https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter" target="_blank" rel="noopener">此文档</a> 了解更多有关在 React 中使用 TypeScript 的知识。</p>
<p>完成以下步骤，便可开始使用 TypeScript：</p>
<ul>
<li>将 TypeScript 添加到你的项目依赖中。</li>
<li>配置 TypeScript 编译选项</li>
<li>使用正确的文件扩展名</li>
<li>为你使用的库添加定义</li>
</ul>
<p>如果你使用create-react-app,那么使用<code>npx create-react-app my-app --template typescript</code>即可创建一个使用TypeScript的新项目。</p>
<p>关于怎么在现有项目中引入TS，见<a href="https://zh-hans.reactjs.org/docs/static-type-checking.html" target="_blank" rel="noopener">这里</a></p>
<p><strong>Kotlin</strong><br>Kotlin 是由 JetBrains 开发的一门静态类型语言。其目标平台包括 JVM、Android、LLVM 和 JavaScript。</p>
<p>JetBrains 专门为 React 社区开发和维护了几个工具：React bindings 以及 Create React Kotlin App。后者可以通过 Kotlin 快速编写 React 应用程序，并且不需要构建配置。</p>
<h3 id="16-严格模式"><a href="#16-严格模式" class="headerlink" title="16.严格模式"></a>16.严格模式</h3><p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function ExampleApplication() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header &#x2F;&gt;</span><br><span class="line">      &lt;React.StrictMode&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ComponentOne &#x2F;&gt;</span><br><span class="line">          &lt;ComponentTwo &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;React.StrictMode&gt;</span><br><span class="line">      &lt;Footer &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StrictMode 目前有助于：</p>
<ul>
<li>识别不安全的生命周期</li>
<li>关于使用过时字符串 ref API 的警告</li>
<li>关于使用废弃的 findDOMNode 方法的警告</li>
<li>检测意外的副作用</li>
<li>检测过时的 context API<br>详情见<a href="https://zh-hans.reactjs.org/docs/strict-mode.html" target="_blank" rel="noopener">这里</a></li>
</ul>
<h3 id="17-PropTypes-类型检查"><a href="#17-PropTypes-类型检查" class="headerlink" title="17.PropTypes 类型检查"></a>17.PropTypes 类型检查</h3><p>第15点中说过，Flow和TypeScript可以对整个应用程序进行类型检查，但如果你没有使用这些扩展。你可以使用内置的PropTypes来进行类型检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line"></span><br><span class="line">class Greeting extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greeting.propTypes &#x3D; &#123;</span><br><span class="line">  name: PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当传入的 prop 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，propTypes 仅在开发模式下进行检查。</p>
<p>类型很多，如下，还可以自定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 你可以将属性声明为 JS 原生类型，默认情况下</span><br><span class="line">  &#x2F;&#x2F; 这些属性都是可选的。</span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 任何可被渲染的元素（包括数字、字符串、元素或数组）</span><br><span class="line">  &#x2F;&#x2F; (或 Fragment) 也包含这些类型。</span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 React 元素。</span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个 React 元素类型（即，MyComponent）。</span><br><span class="line">  optionalElementType: PropTypes.elementType,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 你也可以声明 prop 为类的实例，这里使用</span><br><span class="line">  &#x2F;&#x2F; JS 的 instanceof 操作符。</span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 你可以让你的 prop 只能是特定的值，指定它为</span><br><span class="line">  &#x2F;&#x2F; 枚举类型。</span><br><span class="line">  optionalEnum: PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一个对象可以是几种类型中的任意一个类型</span><br><span class="line">  optionalUnion: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 可以指定一个数组由某一类型的元素组成</span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 可以指定一个对象由某一类型的值组成</span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 可以指定一个对象由特定的类型值组成</span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; An object with warnings on extra properties</span><br><span class="line">  optionalObjectWithStrictShape: PropTypes.exact(&#123;</span><br><span class="line">    name: PropTypes.string,</span><br><span class="line">    quantity: PropTypes.number</span><br><span class="line">  &#125;),   </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 你可以在任何 PropTypes 属性后面加上 &#96;isRequired&#96; ，确保</span><br><span class="line">  &#x2F;&#x2F; 这个 prop 没有被提供时，会打印警告信息。</span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 任意类型的数据</span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span><br><span class="line">  &#x2F;&#x2F; 请不要使用 &#96;console.warn&#96; 或抛出异常，因为这在 &#96;onOfType&#96; 中不会起作用。</span><br><span class="line">  customProp: function(props, propName, componentName) &#123;</span><br><span class="line">    if (!&#x2F;matchme&#x2F;.test(props[propName])) &#123;</span><br><span class="line">      return new Error(</span><br><span class="line">        &#39;Invalid prop &#96;&#39; + propName + &#39;&#96; supplied to&#39; +</span><br><span class="line">        &#39; &#96;&#39; + componentName + &#39;&#96;. Validation failed.&#39;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 你也可以提供一个自定义的 &#96;arrayOf&#96; 或 &#96;objectOf&#96; 验证器。</span><br><span class="line">  &#x2F;&#x2F; 它应该在验证失败时返回一个 Error 对象。</span><br><span class="line">  &#x2F;&#x2F; 验证器将验证数组或对象中的每个值。验证器的前两个参数</span><br><span class="line">  &#x2F;&#x2F; 第一个是数组或对象本身</span><br><span class="line">  &#x2F;&#x2F; 第二个是他们当前的键。</span><br><span class="line">  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;</span><br><span class="line">    if (!&#x2F;matchme&#x2F;.test(propValue[key])) &#123;</span><br><span class="line">      return new Error(</span><br><span class="line">        &#39;Invalid prop &#96;&#39; + propFullName + &#39;&#96; supplied to&#39; +</span><br><span class="line">        &#39; &#96;&#39; + componentName + &#39;&#96;. Validation failed.&#39;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>限制单个元素</strong><br>你可以通过 PropTypes.element 来确保传递给组件的 children 中只包含一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; children必须只有一个元素，否则控制台会打印警告。</span><br><span class="line">MyComponent.propTypes &#x3D; &#123;</span><br><span class="line">  children: PropTypes.element.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>默认Prop值</strong><br>您可以通过配置特定的 defaultProps 属性来定义 props 的默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Greeting extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定 props 的默认值：</span><br><span class="line">Greeting.defaultProps &#x3D; &#123;</span><br><span class="line">  name: &#39;Stranger&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不传递name将渲染出 &quot;Hello, Stranger&quot;：</span><br></pre></td></tr></table></figure>

<h3 id="18-非受控组件"><a href="#18-非受控组件" class="headerlink" title="18.非受控组件"></a>18.非受控组件</h3><p>在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。即使用类似ref等功能来从DOM节点获取表单数据。</p>
<p><strong>默认值</strong><br>在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value。</p>
<p><strong>文件输入</strong></p>
<figure class="highlight plain"><figcaption><span>type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 File API 与文件进行交互。</span><br></pre></td></tr></table></figure>
<p>class FileInput extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br>    this.fileInput = React.createRef();<br>  }<br>  handleSubmit(event) {<br>    event.preventDefault();<br>    alert(<br>      <code>Selected file - ${this.fileInput.current.files[0].name}</code><br>    );<br>  }</p>
<p>  render() {<br>    return (<br>      <form onSubmit={this.handleSubmit}><br>        <label><br>          Upload file:<br>          <input type="file" ref={this.fileInput} /><br>        </label><br>        <br /><br>        <button type="submit">Submit</button><br>      </form><br>    );<br>  }<br>}</p>
<p>ReactDOM.render(<br>  <FileInput />,<br>  document.getElementById(‘root’)<br>);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 19. Web Components</span><br><span class="line">React 和 Web Components 为了解决不同的问题而生。Web Components 为可复用组件提供了强大的封装，而 React 则提供了声明式的解决方案，使 DOM 与数据保持同步。两者旨在互补。作为开发人员，可以自由选择在 Web Components 中使用 React，或者在 React 中使用 Web Components，或者两者共存。</span><br><span class="line"></span><br><span class="line">大多数开发者在使用 React 时，不使用 Web Components，但可能你会需要使用，尤其是在使用 Web Components 编写的第三方 UI 组件时。</span><br></pre></td></tr></table></figure>
<p>class HelloMessage extends React.Component {<br>  render() {<br>    return <div>Hello <x-search>{this.props.name}</x-search>!</div>;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Web Components 通常暴露的是命令式 API。例如，Web Components 的组件 video 可能会公开 play() 和 pause() 方法。要访问 Web Components 的命令式 API，你需要使用 ref 直接与 DOM 节点进行交互。如果你使用的是第三方 Web Components，那么最好的解决方案是编写 React 组件包装该 Web Components。</span><br><span class="line"></span><br><span class="line">Web Components 触发的事件可能无法通过 React 渲染树正确的传递。 你需要在 React 组件中手动添加事件处理器来处理这些事件。</span><br><span class="line"></span><br><span class="line">常见的误区是要注意在 Web Components 中应该使用 class 而非 className。</span><br><span class="line"></span><br><span class="line">**在 Web Components 中使用 React**</span><br></pre></td></tr></table></figure>
<p>class XSearch extends HTMLElement {<br>  connectedCallback() {<br>    const mountPoint = document.createElement(‘span’);<br>    this.attachShadow({ mode: ‘open’ }).appendChild(mountPoint);</p>
<pre><code>const name = this.getAttribute(&apos;name&apos;);
const url = &apos;https://www.google.com/search?q=&apos; + encodeURIComponent(name);
ReactDOM.render(&lt;a href={url}&gt;{name}&lt;/a&gt;, mountPoint);</code></pre><p>  }<br>}<br>customElements.define(‘x-search’, XSearch);</p>
<p>```<br>注意：<br>如果使用 Babel 来转换 class，此代码将不会起作用。请查阅该 <a href="https://github.com/w3c/webcomponents/issues/587" target="_blank" rel="noopener">issue</a> 了解相关讨论。 在加载 Web Components 前请引入 <a href="https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs" target="_blank" rel="noopener">custom-elements-es5-adapter</a> 来解决该 issue。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%9F%BA%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%9F%BA%E6%9C%AC/" class="post-title-link" itemprop="url">React官方文档知识点-基本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-28 17:56:23 / 修改时间：18:03:39" itemprop="dateCreated datePublished" datetime="2020-05-28T17:56:23+08:00">2020-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近准备面试前端工作，很多很久没使用的东西是应该复习一下了。首当其冲就是前端领域的三大框架。在这里就不再比较这三个框架的优劣，我从15年底开始用react，也算是很早期的一批用户了，所以先从官方文档出发复习一下React的知识点，顺便也学习一下新的特性。</p>
<p>官方文档比较多，我全部看了一遍。也将其中的要点摘录来下来，如果有缘读到这篇文章的你恰巧没有那么多时间复习，可以大概地瞟一眼我的摘录笔记。大概会有三篇，基本、进阶和Context+Hook</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-React不直接修改数据的原因："><a href="#1-React不直接修改数据的原因：" class="headerlink" title="1.React不直接修改数据的原因："></a>1.React不直接修改数据的原因：</h3><ul>
<li>简化复杂的功能，不直接在数据上修改可以让我们追溯并复用游戏的历史记录。</li>
<li>跟踪数据的改变，直接修改数据，很难跟踪到数据的改变，需要可变对象可以与改变之前的版本进行对比，这样整个对象树都需要被遍历一次。<br>跟踪不可变数据的变化相对来说就容易多了。如果发现对象变成了一个新对象，那么我们就可以说对象发生改变了。</li>
<li>确定在react中何时重新渲染，不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染。</li>
</ul>
<h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2.函数组件"></a>2.函数组件</h3><p>如果你想写的组件只包含一个 render 方法，并且不包含 state，那么使用函数组件就会更简单。<br>PS：当我们把 Square 修改成函数组件时，我们同时也把 onClick={() =&gt; this.props.onClick()} 改成了更短的 onClick={props.onClick}（注意两侧都没有括号）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Square(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button className&#x3D;&quot;square&quot; onClick&#x3D;&#123;props.onClick&#125;&gt;</span><br><span class="line">      &#123;props.value&#125;</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-key"><a href="#3-key" class="headerlink" title="3.key"></a>3.key</h3><p>我们需要给每一个列表项一个确定的 key 属性，它可以用来区分不同的列表项和他们的同级兄弟列表项。<br>每当一个列表重新渲染时，React 会根据每一项列表元素的 key 来检索上一次渲染时与每个 key 所匹配的列表项。如果 React 发现当前的列表有一个之前不存在的 key，那么就会创建出一个新的组件。如果 React 发现和之前对比少了一个 key，那么就会销毁之前对应的组件。如果一个组件的 key 发生了变化，这个组件会被销毁，然后使用新的 state 重新创建一份。</p>
<p>key 是 React 中一个特殊的保留属性（还有一个是 ref，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 key 属性，然后把 key 直接存储在返回的元素上。虽然 key 看起来好像是 props 中的一个，但是你不能通过 this.props.key 来获取 key。React 会通过 key 来自动判断哪些组件需要更新。组件是不能访问到它的 key 的。</p>
<p>我们强烈推荐，每次只要你构建动态列表的时候，都要指定一个合适的 key。如果你没有找到一个合适的 key，那么你就需要考虑重新整理你的数据结构了，这样才能有合适的 key。</p>
<p>另外，设置key的元素是map() 方法中的元素，假如你的每个li都是包含在一个ListItem组件中返回的，你就应该在ListItem上加key，而不是li</p>
<h3 id="4-防注入攻击"><a href="#4-防注入攻击" class="headerlink" title="4.防注入攻击"></a>4.防注入攻击</h3><p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p>
<h3 id="5-将一个元素渲染为dom"><a href="#5-将一个元素渲染为dom" class="headerlink" title="5.将一个元素渲染为dom"></a>5.将一个元素渲染为dom</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>成为‘根’dom节点，仅使用react创建的应用通常只有一个根dom节点。<br>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure>

<h3 id="6-按需更新"><a href="#6-按需更新" class="headerlink" title="6.按需更新"></a>6.按需更新</h3><p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。<br>尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容<br>根据我们的经验，考虑 UI 在任意给定时刻的状态，而不是随时间变化的过程，能够消灭一整类的 bug。</p>
<h3 id="7-组件名称必须以大写字母开头。"><a href="#7-组件名称必须以大写字母开头。" class="headerlink" title="7.组件名称必须以大写字母开头。"></a>7.组件名称必须以大写字母开头。</h3><p>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<code>&lt;div /&gt;</code>代表 HTML 的 div 标签，而 <code>&lt;Welcome /&gt;</code> 则代表一个组件，并且需在作用域内使用 Welcome。</p>
<h3 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h3><p>当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）”。</p>
<p>同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（unmount）”。</p>
<p>于是我们有了componentDidMount() 和 componentWillUnmount()</p>
<p>当你需要在class中添加不参与数据流的额外字段，而它又需要初始化时，就在componentDidMount()来做。<br>比如在componentDidMount()中初始化一个计时器，在componentWillUnmount()中销毁它。</p>
<p>关于state:</p>
<ul>
<li>不要直接修改</li>
<li>state的更新可能是异步的，出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。<br>因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Correct</span><br><span class="line">this.setState((state, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="9-事件"><a href="#9-事件" class="headerlink" title="9.事件"></a>9.事件</h3><p>在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&#39;The link was clicked.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href&#x3D;&quot;#&quot; onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;&#x2F;a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，e 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。如果想了解更多，请查看 <a href="https://zh-hans.reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a> 参考指南。</p>
<h3 id="10-条件渲染"><a href="#10-条件渲染" class="headerlink" title="10.条件渲染"></a>10.条件渲染</h3><p>之所以可以用 条件 &amp;&amp; 组件 的方式来渲染组件。是因为在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。</p>
<p>因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p>
<p>其次，在组件的 render 方法中返回 null 并不会影响组件的生命周期。即使返回null，componentDidUpdate 依然会被调用。</p>
<h3 id="11-表单"><a href="#11-表单" class="headerlink" title="11.表单"></a>11.表单</h3><p>React中，可变状态通常保存在组件的state属性中，且只能通过setState来更新。但HTML里类似input,select,textarea等元素本身自己维护着state。</p>
<p>一般情况下，我们还是倾向于让react的state成为组件的唯一数据源，即由react来渲染input，并控制用户输入过程中发生的操作，这样改造了的表单输入元素叫做“受控”组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;form ...&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如上,显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>
<p>对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。</p>
<p><a href="https://zh-hans.reactjs.org/docs/forms.html" target="_blank" rel="noopener">这里</a>了解诸如 textarea,select等受控组件在react中的用法。</p>
<p>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。</p>
<p>其次，类似<code>&lt;input type=&quot;file&quot; /&gt;</code>这种value为只读的元素，它们叫做非受控组件。<br>有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。</p>
<p>当然，直接找一些成熟的解决方案也是非常好的解决方式，比如<a href="https://jaredpalmer.com/formik" target="_blank" rel="noopener">Formilk</a> 就是不错的选择。但它们大多也是建立在受控组件和管理state的基础上的，所以了解一下原理并没有错。</p>
<h3 id="12-状态提升"><a href="#12-状态提升" class="headerlink" title="12.状态提升"></a>12.状态提升</h3><p>其实关于这个，只要用过React的人就应该非常熟悉，没什么值得再进一步探讨的。这里就提炼一下要点：  </p>
<ul>
<li>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”，如果当前组件的state在其它组件中被需要，我们就应该考虑将这个变量提升到共同的父组件中。利用好自上而下的数据流。</li>
<li>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。</li>
<li>利用好<a href="https://github.com/facebook/react/tree/master/packages/react-devtools" target="_blank" rel="noopener">React开发者工具</a>来定位UI中的bug</li>
</ul>
<p>提升方式与双向绑定的区别与优缺点： react的这种数据单向绑定方式实际是大势所趋，使得我们在追踪数据变化和调试程序的时候逻辑更加清晰，而双向绑定虽然一定程度减少了代码量，但一让查错变得困难，二也会在大量双向绑定存在的时候产生性能问题。</p>
<h3 id="13-不需要组件继承"><a href="#13-不需要组件继承" class="headerlink" title="13.不需要组件继承"></a>13.不需要组件继承</h3><p>组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p>
<p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p>
<h3 id="14-容器组件"><a href="#14-容器组件" class="headerlink" title="14.容器组件"></a>14.容器组件</h3><p>有一个特殊的prop：children。使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;SomeComp color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;SomeComp&gt;</span><br></pre></td></tr></table></figure>
<p>出现在标签开始结束标记之间的这些内容，就会在SomeComp内部以props.children的形式存在。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/" class="post-title-link" itemprop="url">边写代码边学习Mask-rcnn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-19 00:42:15 / 修改时间：03:35:04" itemprop="dateCreated datePublished" datetime="2020-05-19T00:42:15+08:00">2020-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为一个深度学习的学习者，你是不是苦于自己看了非常多的理论却难以下手实践？是否总觉得自己还没到写代码的时候？<br>如果你这么想，那么你看再多的理论，也无法真正踏进深度学习的大门。<br>就我个人而言，很多时候即使读完了论文仍然有点懵，很多地方感觉都一知半解，还有些地方可能直接就是不太明白。此时，如果能有源码看一看，才能真正将这篇文章搞明白。<br>so, “talk is cheap, show me the code” 实乃金玉良言。</p>
<p>这篇文章将使用pytorch modelzoo提供的现成Mask R-CNN预训练模型来进行fine-turing，实现一个目标检测和语义分割应用。并且在这个过程中来重新复习一下Mask R-CNN这个经典网络的一些原理。  </p>
<h2 id="Mask-R-CNN简介"><a href="#Mask-R-CNN简介" class="headerlink" title="Mask R-CNN简介"></a>Mask R-CNN简介</h2><p>Mask R-CNN来自何恺明大神2017年的论文，是一个通用的目标检测和实例分割的模型。它基于作者团队在2015年提出的faster rcnn模型，最主要的改动就是增加了一个分支来用于分割任务。<br>Mask R-CNN是anchor-based的模型，依然采用Faster RCNN的2-stage结构，首先用RPN找出候选region，然后在此基础上计算ROI并完成分类、检测和分割任务。<br>并没有添加各种trick，Mask RCNN就超过了当时所有的sota模型。</p>
<h2 id="定义DataSet并处理"><a href="#定义DataSet并处理" class="headerlink" title="定义DataSet并处理"></a>定义DataSet并处理</h2><p>我们将使用Penn-Fudan数据库中的行人图片数据来对模型进行微调。它包含170个图像和345个行人实例。<a href="https://www.cis.upenn.edu/~jshi/ped_html/PennFudanPed.zip" target="_blank" rel="noopener">数据在此</a>。<br>数据文件结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PennFudanPed&#x2F;</span><br><span class="line">  PedMasks&#x2F;</span><br><span class="line">    FudanPed00001_mask.png</span><br><span class="line">    FudanPed00002_mask.png</span><br><span class="line">    FudanPed00003_mask.png</span><br><span class="line">    FudanPed00004_mask.png</span><br><span class="line">    ...</span><br><span class="line">  PNGImages&#x2F;</span><br><span class="line">    FudanPed00001.png</span><br><span class="line">    FudanPed00002.png</span><br><span class="line">    FudanPed00003.png</span><br><span class="line">    FudanPed00004.png</span><br></pre></td></tr></table></figure>
<p>PedMasks中数据为PNGImages文件夹下对应图片的实例分割掩膜，如下：</p>
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/mask_sample.png" class="" title="原图片">
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/mask_sample1.png" class="" title="mask图片">
<p>即掩膜中不同的数值对应不同的实例的分割。</p>
<h3 id="定义Dataset类"><a href="#定义Dataset类" class="headerlink" title="定义Dataset类"></a>定义Dataset类</h3><p>上一篇文章说过，Dataset类是帮助我们处理原始数据并产出模型需要的输入数据的类。<br>而在我们这次的Mask R-CNN模型中，我们希望Dataset通过<strong>getitem</strong>能返回我们图像数据(H,W)以及图像的以下信息：</p>
<ul>
<li>boxes: 这张图片里所有的目标区域,格式为[x0,x1,y0,y1]，x∈[0,W], y∈[0,H]</li>
<li>labels: 每个边框的标签</li>
<li>masks: 每个图像的掩膜</li>
<li>image_id: 图片id</li>
<li>area：每个bbox的面积，用于计算IoU</li>
<li>iscrowd: 每个区域是否是人群<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">class PennFudanDataset(Dataset):</span><br><span class="line">    def __init__(self, root, transforms):</span><br><span class="line">        self.root &#x3D; root</span><br><span class="line">        self.transforms &#x3D; transforms</span><br><span class="line">        # 下载所有图像文件，为其排序。确保它们对齐,而且这样就把图片名字列出来了，方便了加载图片</span><br><span class="line">        self.imgs &#x3D; list(sorted(os.listdir(os.path.join(root, &quot;PNGImages&quot;))))</span><br><span class="line">        self.masks &#x3D; list(sorted(os.listdir(os.path.join(root, &quot;PedMasks&quot;))))</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, idx):</span><br><span class="line">        # load images ad masks</span><br><span class="line">        img_path &#x3D; os.path.join(self.root, &quot;PNGImages&quot;, self.imgs[idx])</span><br><span class="line">        mask_path &#x3D; os.path.join(self.root, &quot;PedMasks&quot;, self.masks[idx])</span><br><span class="line">        img &#x3D; Image.open(img_path).convert(&quot;RGB&quot;)</span><br><span class="line">        # 请注意我们还没有将mask转换为RGB,</span><br><span class="line">        # 因为每种颜色对应一个不同的实例。0是背景</span><br><span class="line">        mask &#x3D; Image.open(mask_path)</span><br><span class="line">        # 将PIL图像转换为numpy数组</span><br><span class="line">        mask &#x3D; np.array(mask)</span><br><span class="line">        # 实例被编码为不同的颜色</span><br><span class="line">        obj_ids &#x3D; np.unique(mask)</span><br><span class="line">        # 第一个id是背景(即0)，所以删除它</span><br><span class="line">        obj_ids &#x3D; obj_ids[1:]</span><br><span class="line"></span><br><span class="line">        # 将相同颜色编码的mask分成一组</span><br><span class="line">        # mask为2维，用None扩充obj_ids维度，masks为3维，因为一张图片可能有多个实例分割</span><br><span class="line">        # 二进制格式</span><br><span class="line">        masks &#x3D; mask &#x3D;&#x3D; obj_ids[:, None, None]</span><br><span class="line"></span><br><span class="line">        # 获取每个mask的边界框坐标</span><br><span class="line">        num_objs &#x3D; len(obj_ids)</span><br><span class="line">        boxes &#x3D; []</span><br><span class="line">        for i in range(num_objs):</span><br><span class="line">            # masks[i]为2维，所以np.where返回2个tuple，分别为此颜色编码的元素在各个维度的下标</span><br><span class="line">            # 这里的数据中不同颜色的mask是语义分割的像素点，选出最大最小的x坐标和y坐标就得到了目标区域(x0,y0),(x1,y1)</span><br><span class="line">            pos &#x3D; np.where(masks[i])</span><br><span class="line">            xmin &#x3D; np.min(pos[1])</span><br><span class="line">            xmax &#x3D; np.max(pos[1])</span><br><span class="line">            ymin &#x3D; np.min(pos[0])</span><br><span class="line">            ymax &#x3D; np.max(pos[0])</span><br><span class="line">            boxes.append([xmin, ymin, xmax, ymax])</span><br><span class="line"></span><br><span class="line">        # 将所有转换为torch.Tensor</span><br><span class="line">        boxes &#x3D; torch.as_tensor(boxes, dtype&#x3D;torch.float32)</span><br><span class="line">        # 我们只检测行人这一个类(行人，所以直接全部置为1)</span><br><span class="line">        labels &#x3D; torch.ones((num_objs,), dtype&#x3D;torch.int64)</span><br><span class="line">        masks &#x3D; torch.as_tensor(masks, dtype&#x3D;torch.uint8)</span><br><span class="line"></span><br><span class="line">        image_id &#x3D; torch.tensor([idx])</span><br><span class="line">        area &#x3D; (boxes[:, 3] - boxes[:, 1]) * (boxes[:, 2] - boxes[:, 0])</span><br><span class="line">        # 假设所有实例都不是人群</span><br><span class="line">        iscrowd &#x3D; torch.zeros((num_objs,), dtype&#x3D;torch.int64)</span><br><span class="line"></span><br><span class="line">        target &#x3D; &#123;&#125;</span><br><span class="line">        target[&quot;boxes&quot;] &#x3D; boxes  # 这张图片里所有的目标区域</span><br><span class="line">        target[&quot;labels&quot;] &#x3D; labels   # 每个目标区域的类型</span><br><span class="line">        target[&quot;masks&quot;] &#x3D; masks    # 图像掩膜 mask</span><br><span class="line">        target[&quot;image_id&quot;] &#x3D; image_id  # 图片id</span><br><span class="line">        target[&quot;area&quot;] &#x3D; area          # 每个区域的面积</span><br><span class="line">        target[&quot;iscrowd&quot;] &#x3D; iscrowd    # 每个区域是否是人群(这里假设的都不是)</span><br><span class="line"></span><br><span class="line">        if self.transforms is not None:</span><br><span class="line">            img, target &#x3D; self.transforms(img, target)</span><br><span class="line"></span><br><span class="line">        return img, target</span><br><span class="line">        </span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.imgs)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>Mask-RCNN结构如下：</p>
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/mask_rcnn_model.jpg" class="" title="模型结构">
<p>torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True) 为我们提供了一个预训练的Mask-RCNN模型。<br>修改这种预训练模型一般有2种思路，第一就是当我们数据较少时，我们就只将最后一层替换成我们的输入目标，然后进行微调。<br>另一种思路则是可以在原模型基础上进行修改，比如替换backbone，修改RPN的anchor数量，调整ROI维度等。  </p>
<p>我们先来看看第二种方式：<br><strong>修改backbone</strong>: Mask-RCNN 的backbone使用的Resnet101，整体还是比较大的，假如你想使用一些轻量的backbone，比如mobileNet，那么你可以进行替换<br><strong>修改rpn</strong>:Mask-RCNN 的anchor是如何生成的呢，注意看上面的结构图。输入数据在经过backbone之后，得到的feature-map其实是在原输入的基础上进行了32倍下采样。基于这个feature-map的每个元素，我们再进行一个3×3的卷积来增加感受野，然后对每个元素生成9个anchor来生成候选区域。这9个初始anchor包含3种长宽比(1:1,1:2,2:1),每种长宽比包含3种不同的面积。结构如下：</p>
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/rpn_structure.jpg" class="" title="rpn结构">
<p>注意图上的各种数字，256表示的是骨干网络输出的通道数，k表示生成的anchor的数量。因为每个anchor有positive和negative，所以有2k个打分。而每个anchor会经过后续的回归找到针对正确区域的4个偏移量(x,y,w,h)，所以是4k个coordinates。<br>对于这些参数，我们也可以修改。<br><strong>修改RoI pooling</strong>：RoI pooling层复杂收集proposal，然后选取特征并送入后续的分类和检测FC网络。 要知道为了保留图片中事物的特性，我们很少对图片采用resize或者裁剪操作，而Mask-RCNN接受不同大小的图片输入，那么经过骨干和RPN网络后，各图片到此时的数据维度是不一样的。这种情况下我们没有办法通过FC等网络进行特征组合。RoI pooling层就是来解决这个问题的。它将收集到的proposal分为固定个数的区域(比如7*7)，然后对每这些区域使用max_pool处理，这样就得到了固定维度的输出。<br>其次，Faster RCNN在处理RoI pooling的过程中有2次取整操作：</p>
<ul>
<li>region proposal的xywh通常是小数，但是为了方便操作会把它整数化。</li>
<li>将整数化后的边界区域平均分割成 k x k 个单元，对每一个单元的边界进行整数化。<br>这将会导致RoI pooling后的输出与原图像对应的区域产生一些偏离，导致不能完全对应。第一个问题很好解决，不再取整即可。而解决第二个问题，则是使用双线性插值的方式来更加精确的找到每个边界的特征。我们在下面代码中看到的sampling_ratio=2就是这个方法的体现。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from torchvision.models.detection import FasterRCNN</span><br><span class="line">from torchvision.models.detection.rpn import AnchorGenerator</span><br><span class="line"></span><br><span class="line"># 加载预先训练的模型进行分类和返回</span><br><span class="line"># 只有功能 </span><br><span class="line"># 主干采用mobileNet V2</span><br><span class="line">backbone &#x3D; torchvision.models.mobilenet_v2(pretrained&#x3D;True).features</span><br><span class="line"># FasterRCNN需要知道骨干网中的输出通道数量。对于mobilenet_v2，它是1280，所以我们需要在这里添加它</span><br><span class="line">backbone.out_channels &#x3D; 1280</span><br><span class="line"></span><br><span class="line"># 我们让RPN在每个空间位置生成5 x 3个锚点 PS：这里原文是3*3，即3种大小3种宽高比</span><br><span class="line"># 改成5种不同的大小和3种不同的宽高比。 </span><br><span class="line"># 因为每个特征映射可能具有不同的大小和宽高比，size为anchor box大小，aspect_ratios则是宽高比</span><br><span class="line">anchor_generator &#x3D; AnchorGenerator(sizes&#x3D;((32, 64, 128, 256, 512),),</span><br><span class="line">                                   aspect_ratios&#x3D;((0.5, 1.0, 2.0),))</span><br><span class="line"></span><br><span class="line"># 定义一下我们将用于执行感兴趣区域裁剪的特征映射，以及重新缩放后裁剪的大小。 </span><br><span class="line"># 如果您的主干返回Tensor，则featmap_names应为[0]。 </span><br><span class="line"># 更一般地，主干应该返回OrderedDict [Tensor]</span><br><span class="line"># 并且在featmap_names中，您可以选择要使用的功能映射。</span><br><span class="line"># 这里为RoIPooling层，将feature_map对应的原图中部分处理成7*7(output_size&#x3D;7)的大小然后再进行后续的分类和回归操作</span><br><span class="line"># 而sampling_ratio&#x3D;2则是原文中进行插值所选取的采样点，简单的说：采样点为2就是说7*7的每个区域内，都要再分成2*2个grid，然后对每个grid中心点进行采样，将这4个点的值求平均就是这个区域最终的值。</span><br><span class="line">roi_pooler &#x3D; torchvision.ops.MultiScaleRoIAlign(featmap_names&#x3D;[0],</span><br><span class="line">                                                output_size&#x3D;7,</span><br><span class="line">                                                sampling_ratio&#x3D;2)</span><br><span class="line"></span><br><span class="line"># 将这些pieces放在FasterRCNN模型中</span><br><span class="line">model &#x3D; FasterRCNN(backbone,</span><br><span class="line">                   num_classes&#x3D;2,</span><br><span class="line">                   rpn_anchor_generator&#x3D;anchor_generator,</span><br><span class="line">                   box_roi_pool&#x3D;roi_pooler)</span><br></pre></td></tr></table></figure>


<p>虽然第二种方式明显比较酷，但鉴于本示例中样本数据比较少，所以我们使用第一种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def get_model_instance_segmentation(num_classes):</span><br><span class="line">    # 加载在COCO上预训练的预训练的实例分割模型</span><br><span class="line">    model &#x3D; torchvision.models.detection.maskrcnn_resnet50_fpn(pretrained&#x3D;True)</span><br><span class="line"></span><br><span class="line">    # 获取分类器的输入特征数</span><br><span class="line">    in_features &#x3D; model.roi_heads.box_predictor.cls_score.in_features</span><br><span class="line">    # 用新的头部替换预先训练好的头部</span><br><span class="line">    model.roi_heads.box_predictor &#x3D; FastRCNNPredictor(in_features, num_classes)</span><br><span class="line"></span><br><span class="line">    # 现在获取掩膜分类器的输入特征数</span><br><span class="line">    in_features_mask &#x3D; model.roi_heads.mask_predictor.conv5_mask.in_channels</span><br><span class="line">    hidden_layer &#x3D; 256</span><br><span class="line">    # 并用新的掩膜预测器替换掩膜预测器</span><br><span class="line">    model.roi_heads.mask_predictor &#x3D; MaskRCNNPredictor(in_features_mask,</span><br><span class="line">                                                       hidden_layer,</span><br><span class="line">                                                       num_classes)</span><br></pre></td></tr></table></figure>


<h2 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h2><p>在torchvision的官方库中，references/detection/里有很多辅助函数来简化训练和评估检测模型。<br>这里我们需要用到references/detection/engine.py，references/detection/utils.py和references/detection/transforms.py。<br>去<a href="https://github.com/pytorch/vision" target="_blank" rel="noopener">这里</a> download代码并将这几个文件拷贝到你的目录中即可。</p>
<p>其次，提前安装<a href="https://github.com/cocodataset/cocoapi/tree/master/PythonAPI" target="_blank" rel="noopener">cocoapi</a>,如果你在windows上，可能需要安装visial studio。<br>windows上也可以通过安装pycocotools来解决。whl见：<a href="https://pypi.org/project/pycocotools-windows/#files" target="_blank" rel="noopener">https://pypi.org/project/pycocotools-windows/#files</a></p>
<p>这一步没什么好说的，代码里也有足够的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 训练阶段按0.5几率水平翻转图像</span><br><span class="line">def get_transform(train):</span><br><span class="line">    transforms &#x3D; []</span><br><span class="line">    transforms.append(T.ToTensor())</span><br><span class="line">    if train:</span><br><span class="line">        transforms.append(T.RandomHorizontalFlip(0.5))</span><br><span class="line">    return T.Compose(transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 在GPU上训练，若无GPU，可选择在CPU上训练</span><br><span class="line">device &#x3D; torch.device(&#39;cuda&#39;) if torch.cuda.is_available() else torch.device(&#39;cpu&#39;)</span><br><span class="line"></span><br><span class="line"># 我们的数据集只有两个类 - 背景和人</span><br><span class="line">num_classes &#x3D; 2</span><br><span class="line"># 使用我们的数据集和定义的转换</span><br><span class="line">dataset &#x3D; PennFudanDataset(&#39;data&#x2F;PennFudanPed&#39;, get_transform(train&#x3D;True))</span><br><span class="line">dataset_test &#x3D; PennFudanDataset(&#39;data&#x2F;PennFudanPed&#39;, get_transform(train&#x3D;False))</span><br><span class="line"></span><br><span class="line"># 在训练和测试集中拆分数据集</span><br><span class="line">indices &#x3D; torch.randperm(len(dataset)).tolist()</span><br><span class="line">dataset &#x3D; torch.utils.data.Subset(dataset, indices[:-50])</span><br><span class="line">dataset_test &#x3D; torch.utils.data.Subset(dataset_test, indices[-50:])</span><br><span class="line"></span><br><span class="line"># 定义训练和验证数据加载器</span><br><span class="line">data_loader &#x3D; torch.utils.data.DataLoader(</span><br><span class="line">    dataset, batch_size&#x3D;2, shuffle&#x3D;True, num_workers&#x3D;4,</span><br><span class="line">    collate_fn&#x3D;utils.collate_fn)</span><br><span class="line"></span><br><span class="line">data_loader_test &#x3D; torch.utils.data.DataLoader(</span><br><span class="line">    dataset_test, batch_size&#x3D;1, shuffle&#x3D;False, num_workers&#x3D;4,</span><br><span class="line">    collate_fn&#x3D;utils.collate_fn)</span><br><span class="line"></span><br><span class="line"># 使用我们的辅助函数获取模型</span><br><span class="line">model &#x3D; get_model_instance_segmentation(num_classes)</span><br><span class="line"></span><br><span class="line"># 将我们的模型迁移到合适的设备</span><br><span class="line">model.to(device)</span><br></pre></td></tr></table></figure>

<h2 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h2><p>我们使用SGD进行优化，训练10个epoch。并且通过比较在测试集上的mAP，保存效果最好的参数到best_state_dict中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def train():</span><br><span class="line">    # 构造一个优化器</span><br><span class="line">    params &#x3D; [p for p in model.parameters() if p.requires_grad]</span><br><span class="line">    optimizer &#x3D; torch.optim.SGD(params, lr&#x3D;0.005,</span><br><span class="line">                                momentum&#x3D;0.9, weight_decay&#x3D;0.0005)</span><br><span class="line">    # 和学习率调度程序</span><br><span class="line">    lr_scheduler &#x3D; torch.optim.lr_scheduler.StepLR(optimizer,</span><br><span class="line">                                                   step_size&#x3D;3,</span><br><span class="line">                                                   gamma&#x3D;0.1)</span><br><span class="line"></span><br><span class="line">    # 训练10个epochs</span><br><span class="line">    num_epochs &#x3D; 10</span><br><span class="line"></span><br><span class="line">    best_mAp &#x3D; 0</span><br><span class="line">    for epoch in range(num_epochs):</span><br><span class="line">        # 训练一个epoch，每10次迭代打印一次</span><br><span class="line">        train_one_epoch(model, optimizer, data_loader, device, epoch, print_freq&#x3D;10)</span><br><span class="line">        # 更新学习速率</span><br><span class="line">        lr_scheduler.step()</span><br><span class="line">        # 在测试集上评价</span><br><span class="line">        eval_res &#x3D; evaluate(model, data_loader_test, device&#x3D;device)</span><br><span class="line"></span><br><span class="line">        # 将结果最好的参数保存下来</span><br><span class="line">        mAp_epoch &#x3D; float(eval_res.coco_eval[&#39;bbox&#39;].stats[0])</span><br><span class="line">        if mAp_epoch &gt; best_mAp:</span><br><span class="line">            torch.save(model.state_dict(),&#39;.&#x2F;best_state_dict&#39;)</span><br><span class="line">            best_mAp &#x3D; mAp_epoch</span><br><span class="line"></span><br><span class="line">    print(&quot;Finish training the model.&quot;)</span><br></pre></td></tr></table></figure>
<p>训练过程中你可以看到各项指标，我忘了截图，最后的COCO-style mAP大概是81左右，mask mAP为在78左右。</p>
<h2 id="使用效果最好的参数进行预测"><a href="#使用效果最好的参数进行预测" class="headerlink" title="使用效果最好的参数进行预测"></a>使用效果最好的参数进行预测</h2><p>完成了训练，接下来肯定就是我们的show time了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">model.load_state_dict(torch.load(&#39;.&#x2F;best_state_dict&#39;))</span><br><span class="line">    # # 切换为评估模式</span><br><span class="line">    model.eval()</span><br><span class="line"></span><br><span class="line">    # 让我们瞅一瞅效果</span><br><span class="line">    img, _ &#x3D; dataset_test[0]</span><br><span class="line"></span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        prediction &#x3D; model([img.to(device)])</span><br><span class="line"></span><br><span class="line">    img_ori &#x3D; Image.fromarray(img.mul(255).permute(1, 2, 0).byte().numpy())</span><br><span class="line">    draw &#x3D; ImageDraw.Draw(img_ori)</span><br><span class="line"></span><br><span class="line">    masks &#x3D; prediction[0][&#39;masks&#39;]</span><br><span class="line">    masks_all &#x3D; Image.fromarray(np.sum(np.sum(masks.mul(255).byte().cpu().numpy(),axis&#x3D;0),axis&#x3D;0))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for [x1,y1,x2,y2] in prediction[0][&#39;boxes&#39;]:</span><br><span class="line">        draw.rectangle([(x1,y1),(x2,y2)],outline&#x3D;(255,0,0))</span><br><span class="line"></span><br><span class="line">    imgs &#x3D; [img_ori,masks_all]</span><br><span class="line"></span><br><span class="line">    for i,im in enumerate(imgs):</span><br><span class="line">        ax &#x3D; plt.subplot(1, 2, i + 1)</span><br><span class="line">        plt.tight_layout()</span><br><span class="line">        ax.axis(&#39;off&#39;)</span><br><span class="line">        plt.imshow(im)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/result01.jpg" class="" title="效果图1">
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/result02.jpg" class="" title="效果图2">
<img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/result03.jpg" class="" title="效果图3">

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本文源码在<a href="https://github.com/toulondu/mask-rcnn-brief" target="_blank" rel="noopener">这里</a></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html" target="_blank" rel="noopener">pytorch官网教程:TORCHVISION OBJECT DETECTION FINETUNING TUTORIAL</a><br><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">Faster R-CNN 论文</a><br><a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">Mask R-CNN 论文</a>、<br><a href="https://zhuanlan.zhihu.com/p/37998710" target="_blank" rel="noopener">令人拍案称奇的Mask RCNN</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/05/15/PyTorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/PyTorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">PyTorch中的数据加载和处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 14:21:23" itemprop="dateCreated datePublished" datetime="2020-05-15T14:21:23+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-19 00:44:34" itemprop="dateModified" datetime="2020-05-19T00:44:34+08:00">2020-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">编码工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章来自<a href="http://pytorch123.com/ThirdSection/DataLoding/" target="_blank" rel="noopener">官网中文教程</a>。<br>我稍稍作了总结，并把代码中稍微不好理解的地方做了详细的注释。</p>
<p>PyTorch提供了许多工具来简化和进行数据加载，使代码更具可读性。<br>这一节就主要介绍pytorch中是如何进行数据的加载和处理的。</p>
<p>先安装2个包：</p>
<ul>
<li>scikit-image：用于图像的IO和变换</li>
<li>pandas：用于更容易地进行csv解析</li>
</ul>
<p>在pytorch中进行数据加载，主要的步骤是：</p>
<ol>
<li>将下好的数据集放在本地文件夹中，本示例中的数据集是imagenet数据集标注为face的图片当中在 dlib 面部检测 (dlib’s pose estimation) 表现良好的图片，连接在<a href="https://download.pytorch.org/tutorial/faces.zip" target="_blank" rel="noopener">这里</a>。</li>
<li>先创建一个自己的数据集类(继承自dataset),在<strong>init</strong>中读取数据内容(根据数据的来源)，在<strong>getitem</strong>中根据idx读取文件。</li>
<li>在Dataset类中可以加入一个transform参数，它是一个函数，可以对样本数据进行预处理，包括Rescale,randomCrop等(输入图片大小不符合网络输入要求时)。我们可以通过torchvision.transforms.Compose这个函数式的方法将数据转换的方法合成一个方法作为我们最后的transform。</li>
<li>迭代从我们创建的Dataset中获取数据，这不需要我们自己实现，通过<strong>torch.utils.data.DataLoader</strong>提供的多线程实现我们可以更高效地载入数据。但在Windows上会存在内存泄漏的问题，所以无法使用多线程。</li>
<li>torchvision，这个包提供了常用的datasets和transform。</li>
</ol>
<p>代码如下,内部有详细注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function, division</span><br><span class="line">import os</span><br><span class="line">import torch</span><br><span class="line">import pandas as pd              #用于更容易地进行csv解析</span><br><span class="line">from skimage import io, transform    #用于图像的IO和变换</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from torch.utils.data import Dataset, DataLoader</span><br><span class="line">from torchvision import transforms, utils</span><br><span class="line"></span><br><span class="line"># 忽略警告</span><br><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line"></span><br><span class="line">plt.ion()   # interactive mode</span><br><span class="line"></span><br><span class="line"># 下载数据集放在&#39;data&#x2F;face&#39;中，</span><br><span class="line"># 这个数据集实际上是imagenet数据集标注为face的图片当中在 dlib 面部检测 (dlib’s pose estimation) 表现良好的图片。</span><br><span class="line"># 我们要处理的是一个面部姿态的数据集。</span><br><span class="line"># 数据集是按如下规则打包成的csv文件:</span><br><span class="line"># image_name,part_0_x,part_0_y,part_1_x,part_1_y,part_2_x, ... ,part_67_x,part_67_y</span><br><span class="line"></span><br><span class="line"># 将csv中的标注点数据读入（N，2）数组中，其中N是特征点的数量。读取数据代码如下：</span><br><span class="line">landmarks_frame &#x3D; pd.read_csv(&#39;data&#x2F;faces&#x2F;face_landmarks.csv&#39;)</span><br><span class="line"></span><br><span class="line">n &#x3D; 32</span><br><span class="line">img_name &#x3D; landmarks_frame.iloc[n, 0]</span><br><span class="line"># values将Series作为ndarry或者ndarry-like类型的数据返回，取决于dtype类型. 这句代码取出了第n张图片的所以标记点信息</span><br><span class="line">landmarks &#x3D; landmarks_frame.iloc[n, 1:].values</span><br><span class="line"># 一对一对的坐标，2个一组</span><br><span class="line">landmarks &#x3D; landmarks.astype(&#39;float&#39;).reshape(-1, 2)</span><br><span class="line"></span><br><span class="line">print(&#39;Image name: &#123;&#125;&#39;.format(img_name))</span><br><span class="line">print(&#39;Landmarks shape: &#123;&#125;&#39;.format(landmarks.shape))</span><br><span class="line">print(&#39;First 4 Landmarks: &#123;&#125;&#39;.format(landmarks[:4]))</span><br><span class="line"></span><br><span class="line"># 展示一张图片和它对应的标注点作为例子。用到的函数都很容易看出作用</span><br><span class="line">def show_landmarks(image, landmarks):</span><br><span class="line">    &quot;&quot;&quot;显示带有地标的图片&quot;&quot;&quot;</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.scatter(landmarks[:, 0], landmarks[:, 1], s&#x3D;10, marker&#x3D;&#39;.&#39;, c&#x3D;&#39;r&#39;)</span><br><span class="line">    plt.pause(0.001)  # pause a bit so that plots are updated</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">show_landmarks(io.imread(os.path.join(&#39;data&#x2F;faces&#x2F;&#39;, img_name)),</span><br><span class="line">               landmarks)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据集类</span><br><span class="line"># torch.utils.data.Dataset是表示数据集的抽象类，因此自定义数据集应继承Dataset并覆盖以下方法 </span><br><span class="line"># * __len__ 实现 len(dataset) 返还数据集的尺寸。</span><br><span class="line"># * __getitem__用来获取一些索引数据，例如 dataset[i] 中的(i)。</span><br><span class="line"></span><br><span class="line"># 为面部数据集创建一个数据集类。</span><br><span class="line"># 我们将在 __init__中读取csv的文件内容，在 __getitem__中读取图片。</span><br><span class="line"># 这么做是为了节省内存 空间。只有在需要用到图片的时候才读取它而不是一开始就把图片全部存进内存里。</span><br><span class="line"></span><br><span class="line"># 我们的数据样本将按这样一个字典&#123;&#39;image&#39;: image, &#39;landmarks&#39;: landmarks&#125;组织。 </span><br><span class="line"># 我们的数据集类将添加一个可选参数transform 以方便对样本进行预处理。</span><br><span class="line">#下一节我们会看到什么时候需要用到transform参数。 __init__方法如下图所示：</span><br><span class="line"># 这部分代码也没什么值得说的</span><br><span class="line">class FaceLandmarksDataset(Dataset):</span><br><span class="line">    &quot;&quot;&quot;面部标记数据集.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, csv_file, root_dir, transform&#x3D;None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        csv_file（string）：带注释的csv文件的路径。</span><br><span class="line">        root_dir（string）：包含所有图像的目录。</span><br><span class="line">        transform（callable， optional）：一个样本上的可用的可选变换</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.landmarks_frame &#x3D; pd.read_csv(csv_file)</span><br><span class="line">        self.root_dir &#x3D; root_dir</span><br><span class="line">        self.transform &#x3D; transform</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.landmarks_frame)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, idx):</span><br><span class="line">        img_name &#x3D; os.path.join(self.root_dir,</span><br><span class="line">                                self.landmarks_frame.iloc[idx, 0])</span><br><span class="line">        image &#x3D; io.imread(img_name)</span><br><span class="line">        landmarks &#x3D; self.landmarks_frame.iloc[idx, 1:]</span><br><span class="line">        landmarks &#x3D; np.array([landmarks])</span><br><span class="line">        landmarks &#x3D; landmarks.astype(&#39;float&#39;).reshape(-1, 2)</span><br><span class="line">        sample &#x3D; &#123;&#39;image&#39;: image, &#39;landmarks&#39;: landmarks&#125;</span><br><span class="line"></span><br><span class="line">        if self.transform:</span><br><span class="line">            sample &#x3D; self.transform(sample)</span><br><span class="line"></span><br><span class="line">        return sample</span><br><span class="line">        </span><br><span class="line"># 数据可视化</span><br><span class="line"># 实例化这个类并遍历数据样本。我们将会打印出前四个例子的尺寸并展示标注的特征点。 代码如下图所示：</span><br><span class="line">face_dataset &#x3D; FaceLandmarksDataset(csv_file&#x3D;&#39;data&#x2F;faces&#x2F;face_landmarks.csv&#39;,</span><br><span class="line">                                    root_dir&#x3D;&#39;data&#x2F;faces&#x2F;&#39;)</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line"></span><br><span class="line">for i in range(len(face_dataset)):</span><br><span class="line">    sample &#x3D; face_dataset[i]</span><br><span class="line"></span><br><span class="line">    print(i, sample[&#39;image&#39;].shape, sample[&#39;landmarks&#39;].shape)</span><br><span class="line">    </span><br><span class="line">    # 创建子图，1行4列，最后一个参数为当前图编号 但也不知道为什么没成功，还是画成了4行1列</span><br><span class="line">    ax &#x3D; plt.subplot(1, 4, i + 1)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    ax.set_title(&#39;Sample #&#123;&#125;&#39;.format(i))</span><br><span class="line">    # 不画坐标轴</span><br><span class="line">    ax.axis(&#39;off&#39;)</span><br><span class="line">    show_landmarks(**sample)</span><br><span class="line"></span><br><span class="line">    if i &#x3D;&#x3D; 3:</span><br><span class="line">        plt.show()</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据变换</span><br><span class="line"># 通过上面的例子我们会发现图片并不是同样的尺寸。绝大多数神经网络都假定图片的尺寸相同。因此我们需要做一些预处理。</span><br><span class="line"># 让我们创建三个转换: * Rescale：缩放图片 * RandomCrop：对图片进行随机裁剪。这是一种数据增强操作 * ToTensor：把numpy格式图片转为torch格式图片 (我们需要交换坐标轴).</span><br><span class="line"># 我们会把它们写成可调用的类的形式而不是简单的函数，这样就不需要每次调用时传递一遍参数。我们只需要实现__call__方法，必 要的时候实现 __init__方法。我们可以这样调用这些转换:</span><br><span class="line"># tsfm &#x3D; Transform(params)</span><br><span class="line"># transformed_sample &#x3D; tsfm(sample)</span><br><span class="line"></span><br><span class="line">class Rescale(object):</span><br><span class="line">    &quot;&quot;&quot;将样本中的图像重新缩放到给定大小。.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        output_size（tuple或int）：所需的输出大小。 如果是元组，则输出为</span><br><span class="line">         与output_size匹配。 如果是int，则匹配较小的图像边缘到output_size保持纵横比相同。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, output_size):</span><br><span class="line">        assert isinstance(output_size, (int, tuple))</span><br><span class="line">        self.output_size &#x3D; output_size</span><br><span class="line"></span><br><span class="line">    def __call__(self, sample):</span><br><span class="line">        image, landmarks &#x3D; sample[&#39;image&#39;], sample[&#39;landmarks&#39;]</span><br><span class="line"></span><br><span class="line">        h, w &#x3D; image.shape[:2]</span><br><span class="line">        if isinstance(self.output_size, int):</span><br><span class="line">            # output_size为int，将长或宽中小的那一个rescale成output_size，另一个保持纵横比缩放</span><br><span class="line">            if h &gt; w:</span><br><span class="line">                new_h, new_w &#x3D; self.output_size * h &#x2F; w, self.output_size</span><br><span class="line">            else:</span><br><span class="line">                new_h, new_w &#x3D; self.output_size, self.output_size * w &#x2F; h</span><br><span class="line">        else:</span><br><span class="line">            new_h, new_w &#x3D; self.output_size</span><br><span class="line"></span><br><span class="line">        new_h, new_w &#x3D; int(new_h), int(new_w)</span><br><span class="line">        </span><br><span class="line">        # 看来skimage的这个库实现了对图片的各种转换操作</span><br><span class="line">        img &#x3D; transform.resize(image, (new_h, new_w))</span><br><span class="line"></span><br><span class="line">        # 别忘了对landmarks也要作同样比例的缩放！</span><br><span class="line">        landmarks &#x3D; landmarks * [new_w &#x2F; w, new_h &#x2F; h]</span><br><span class="line"></span><br><span class="line">        return &#123;&#39;image&#39;: img, &#39;landmarks&#39;: landmarks&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RandomCrop(object):</span><br><span class="line">    &quot;&quot;&quot;随机裁剪样本中的图像.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">       output_size（tuple或int）：所需的输出大小。 如果是int，就按照int的值进行方形裁剪。         </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, output_size):</span><br><span class="line">        assert isinstance(output_size, (int, tuple))</span><br><span class="line">        if isinstance(output_size, int):</span><br><span class="line">            self.output_size &#x3D; (output_size, output_size)</span><br><span class="line">        else:</span><br><span class="line">            assert len(output_size) &#x3D;&#x3D; 2</span><br><span class="line">            self.output_size &#x3D; output_size</span><br><span class="line"></span><br><span class="line">    def __call__(self, sample):</span><br><span class="line">        image, landmarks &#x3D; sample[&#39;image&#39;], sample[&#39;landmarks&#39;]</span><br><span class="line"></span><br><span class="line">        h, w &#x3D; image.shape[:2]</span><br><span class="line">        new_h, new_w &#x3D; self.output_size</span><br><span class="line">        </span><br><span class="line">        # 随机从图片中裁剪一块目标大小的图像出来,landmark也作相应处理 PS:h更小肿么办</span><br><span class="line">        top &#x3D; np.random.randint(0, h - new_h)</span><br><span class="line">        left &#x3D; np.random.randint(0, w - new_w)</span><br><span class="line"></span><br><span class="line">        image &#x3D; image[top: top + new_h,</span><br><span class="line">                      left: left + new_w]</span><br><span class="line"></span><br><span class="line">        landmarks &#x3D; landmarks - [left, top]</span><br><span class="line"></span><br><span class="line">        return &#123;&#39;image&#39;: image, &#39;landmarks&#39;: landmarks&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ToTensor(object):</span><br><span class="line">    &quot;&quot;&quot;将样本中的ndarrays转换为Tensors.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __call__(self, sample):</span><br><span class="line">        image, landmarks &#x3D; sample[&#39;image&#39;], sample[&#39;landmarks&#39;]</span><br><span class="line"></span><br><span class="line">        # 交换颜色轴因为</span><br><span class="line">        # numpy包的图片是: H * W * C</span><br><span class="line">        # torch包的图片是: C * H * W</span><br><span class="line">        image &#x3D; image.transpose((2, 0, 1))</span><br><span class="line">        return &#123;&#39;image&#39;: torch.from_numpy(image),</span><br><span class="line">                &#39;landmarks&#39;: torch.from_numpy(landmarks)&#125;</span><br><span class="line">                </span><br><span class="line"># 8.组合转换</span><br><span class="line"># 即把这些转换应用起来 </span><br><span class="line"># 我们想要把图像的短边调整为256，然后随机裁剪(randomcrop)为224大小的正方形。</span><br><span class="line"># 也就是说，我们打算组合一个Rescale和 RandomCrop的变换。 </span><br><span class="line"># 我们可以调用一个简单的类 torchvision.transforms.Compose来实现这一操作。具体实现如下图：</span><br><span class="line"></span><br><span class="line">scale &#x3D; Rescale(256)</span><br><span class="line">crop &#x3D; RandomCrop(128)</span><br><span class="line">composed &#x3D; transforms.Compose([Rescale(256),</span><br><span class="line">                               RandomCrop(224)])</span><br><span class="line"></span><br><span class="line"># 在样本上应用上述的每个变换。</span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">sample &#x3D; face_dataset[65]</span><br><span class="line"></span><br><span class="line">for i, tsfrm in enumerate([scale, crop, composed]):</span><br><span class="line">    transformed_sample &#x3D; tsfrm(sample)</span><br><span class="line">    </span><br><span class="line">    ax &#x3D; plt.subplot(1, 3, i + 1)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    ax.set_title(type(tsfrm).__name__)</span><br><span class="line">    show_landmarks(**transformed_sample)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 9.迭代数据集</span><br><span class="line"># 让我们把这些整合起来以创建一个带组合转换的数据集。</span><br><span class="line"># 总结一下，每次这个数据集被采样时: </span><br><span class="line"># * 及时地从文件中读取图片 * 对读取的图片应用转换 * 由于其中一步操作是随机的 (randomcrop) , 数据被增强了</span><br><span class="line"></span><br><span class="line"># 我们可以像之前那样使用for i in range循环来对所有创建的数据集执行同样的操作。</span><br><span class="line"></span><br><span class="line"># 还记得FaceLandmarksDataset 这个类吗，忘了可以翻回去看一下</span><br><span class="line">transformed_dataset &#x3D; FaceLandmarksDataset(csv_file&#x3D;&#39;data&#x2F;faces&#x2F;face_landmarks.csv&#39;,</span><br><span class="line">                                           root_dir&#x3D;&#39;data&#x2F;faces&#x2F;&#39;,</span><br><span class="line">                                           transform&#x3D;transforms.Compose([</span><br><span class="line">                                               Rescale(256),</span><br><span class="line">                                               RandomCrop(224),</span><br><span class="line">                                               ToTensor()</span><br><span class="line">                                           ]))</span><br><span class="line"></span><br><span class="line">for i in range(len(transformed_dataset)):</span><br><span class="line">    sample &#x3D; transformed_dataset[i]</span><br><span class="line"></span><br><span class="line">    print(i, sample[&#39;image&#39;].size(), sample[&#39;landmarks&#39;].size())</span><br><span class="line"></span><br><span class="line">    if i &#x3D;&#x3D; 3:</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line"># 但是，对所有数据集简单的使用for循环牺牲了许多功能，尤其是: * 批量处理数据 * 打乱数据 * 使用多线程multiprocessingworker 并行加载数据。</span><br><span class="line"># torch.utils.data.DataLoader是一个提供上述所有这些功能的迭代器。</span><br><span class="line"># 下面使用的参数必须是清楚的。一个值得关注的参数是collate_fn, 可以通过它来决定如何对数据进行批处理。但是绝大多数情况下默认值就能运行良好。</span><br><span class="line"># PS: 这里windows下跑是有问题的，因为windows在用这个多线程方法时有内存泄漏，详情：https:&#x2F;&#x2F;github.com&#x2F;pytorch&#x2F;pytorch&#x2F;pull&#x2F;5585</span><br><span class="line"># 概括点来说就是，因为在Windows上使用FileMapping（mmap）的差异引起的。</span><br><span class="line"># Windows上，所有相关线程都释放了FileMapping对象的引用，它才才能够被释放。没有提供其他方法可以将其直接删除。（例如shm_unlink） </span><br><span class="line"># 启用多线程后，子线程将创建一个FileMapping，然后主进程将其打开。之后子线程将尝试释放它，但是它的引用计数非零，因此无法在那时释放它。</span><br><span class="line"># 而且当前代码无法提供在可能的情况下再次关闭的机会，于是导致了内存泄漏。</span><br><span class="line"></span><br><span class="line"># 解决办法是权宜之计，即使用num_workers参数，令num_workers&#x3D;0,只使用一个主线程加载数据集。避免在windows中使用多线程。</span><br><span class="line"></span><br><span class="line">dataloader &#x3D; DataLoader(transformed_dataset, batch_size&#x3D;4,</span><br><span class="line">                        shuffle&#x3D;True, num_workers&#x3D;4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 辅助功能：显示批次</span><br><span class="line">def show_landmarks_batch(sample_batched):</span><br><span class="line">    &quot;&quot;&quot;Show image with landmarks for a batch of samples.&quot;&quot;&quot;</span><br><span class="line">    images_batch, landmarks_batch &#x3D; \</span><br><span class="line">            sample_batched[&#39;image&#39;], sample_batched[&#39;landmarks&#39;]</span><br><span class="line">    batch_size &#x3D; len(images_batch)</span><br><span class="line">    im_size &#x3D; images_batch.size(2)</span><br><span class="line">    grid_border_size &#x3D; 2</span><br><span class="line"></span><br><span class="line">    grid &#x3D; utils.make_grid(images_batch)</span><br><span class="line">    plt.imshow(grid.numpy().transpose((1, 2, 0)))</span><br><span class="line">    </span><br><span class="line">    for i in range(batch_size):</span><br><span class="line">        plt.scatter(landmarks_batch[i, :, 0].numpy() + i * im_size + (i + 1) * grid_border_size,</span><br><span class="line">                    landmarks_batch[i, :, 1].numpy() + grid_border_size,</span><br><span class="line">                    s&#x3D;10, marker&#x3D;&#39;.&#39;, c&#x3D;&#39;r&#39;)</span><br><span class="line"></span><br><span class="line">        plt.title(&#39;Batch from dataloader&#39;)</span><br><span class="line">        </span><br><span class="line">for i_batch, sample_batched in enumerate(dataloader):</span><br><span class="line">    print(i_batch, sample_batched[&#39;image&#39;].size(),</span><br><span class="line">          sample_batched[&#39;landmarks&#39;].size())</span><br><span class="line"></span><br><span class="line">    # 观察第4批次并停止。</span><br><span class="line">    if i_batch &#x3D;&#x3D; 3:</span><br><span class="line">        plt.figure()</span><br><span class="line">        show_landmarks_batch(sample_batched)</span><br><span class="line">        plt.axis(&#39;off&#39;)</span><br><span class="line">        plt.ioff()</span><br><span class="line">        plt.show()</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p><strong>torchvision</strong><br>torchvision包提供了 常用的数据集类(datasets)和转换(transforms)。<br>所以只要我们的数据符合这些数据集的要求，我们就不需要自己构造这些类比如。torchvision中还有一个更常用的数据集类ImageFolder。 它假定了数据集是以如下方式构造的:<br>root/ants/xxx.png<br>root/ants/xxy.jpeg<br>root/ants/xxz.png<br>.<br>.<br>.<br>root/bees/123.jpg<br>root/bees/nsdf3.png<br>root/bees/asd932_.png</p>
<p>其中’ants’,bees’等是分类标签。在PIL.Image中你也可以使用类似的转换(transforms)例如RandomHorizontalFlip,Scale。利 用这些你可以按如下的方式创建一个数据加载器(dataloader) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torchvision import transforms, datasets</span><br><span class="line"></span><br><span class="line">data_transform &#x3D; transforms.Compose([</span><br><span class="line">        transforms.RandomSizedCrop(224),</span><br><span class="line">        transforms.RandomHorizontalFlip(),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean&#x3D;[0.485, 0.456, 0.406],</span><br><span class="line">                             std&#x3D;[0.229, 0.224, 0.225])</span><br><span class="line">    ])</span><br><span class="line">hymenoptera_dataset &#x3D; datasets.ImageFolder(root&#x3D;&#39;hymenoptera_data&#x2F;train&#39;,</span><br><span class="line">                                           transform&#x3D;data_transform)</span><br><span class="line">dataset_loader &#x3D; torch.utils.data.DataLoader(hymenoptera_dataset,</span><br><span class="line">                                             batch_size&#x3D;4, shuffle&#x3D;True,</span><br><span class="line">                                             num_workers&#x3D;4)</span><br></pre></td></tr></table></figure>




















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">推荐系统技术概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-01 18:32:57" itemprop="dateCreated datePublished" datetime="2020-05-01T18:32:57+08:00">2020-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-12 17:38:51" itemprop="dateModified" datetime="2020-05-12T17:38:51+08:00">2020-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">基础算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近在一边写一个web qa的问答模型一边刷leetcode，前者踩坑太多耗费了超出我预期的时间(还是攻城能力欠缺啊- -)，于是文章也有一段时间没更新了。<br>这期间抽空回顾和学习了目前工业界推荐系统常用的架构和算法，也亲自用代码实现了其中的部分算法，但总体还是停留在纸上谈兵的阶段。<br>虽然这篇文章我脸很厚的用了<strong><em>“概览”</em></strong>这个词，但我们都知道真实的工程落地远比纯粹的算法来得复杂，除了对应实际问题的难度，还会遭遇很多预想不到的困难，当然，这是题外话了~</p>
<p>这篇文章基本是对我近期看的这些推荐系统算法文章和视频的一个个人的文字总结，希望自己之后有应用的机会吧~</p>
<p>相关链接会放在文末。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工业界推荐系统的架构基本在宏观上比较趋同，大都可以粗分为<strong>召回(recall)</strong>和<strong>排序(rank)</strong>两个阶段。如下：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/recommandation-system-structure.png" class="" title="推荐系统架构">

<p>一般来说，平台往往动辄有上百万的item，不管是新闻应用，视频应用还是电商应用，要从海量的item中直接一步到位准确地找到推荐给某个用户的item是比较难的。 这两个阶段可以大概地看成是粗筛和精选，对某个用户来说，先通过一个比较快速而简单的方法从上百万的item中筛选出几百或者几千个高质量的item，再通过一个精确的方法仔细地将其中最好的一些item优先级确定下来，然后推荐给用户。前者就叫做召回阶段，后者则叫做排序阶段。</p>
<p>当然，落地的时候往往还会把排序阶段再分成 粗排-主排-重排，于是变成了四个阶段，这个后面再说~</p>
<p>下面就来介绍一下各个阶段常用的算法。</p>
<h2 id="召回算法"><a href="#召回算法" class="headerlink" title="召回算法"></a>召回算法</h2><p>召回算法有很多，主要分为3类：</p>
<ul>
<li>基于用户行为，简单地说就是“你看了什么，我就给你推荐什么“</li>
<li>基于用户档案，即给用户建立档案，根据用户档案中的标签推荐相应的item</li>
<li>基于隐语义，即基于机器学习方法，使用类似于embedding的方式<br>三者各有特点和优劣，基于用户行为直观上显得过于简单，基于用户档案也会存在用户改口味难以泛化的情况，而机器学习，本身就偏向黑盒，对于算法中的中间值难以解释，从而优化和修改显得困难。</li>
</ul>
<p>所以在使用这些算法的时候，一般是使用多路召回，即使用很多不同的召回算法分别进行召回，再把各自召回的结果组合起来作为最后的召回结果。</p>
<p>这里主要介绍 CF, personal rank, item2vec等算法。</p>
<h3 id="CF-协同过滤"><a href="#CF-协同过滤" class="headerlink" title="CF(协同过滤)"></a>CF(协同过滤)</h3><p>协同过滤是一种很老的算法，但沿用至今，它能够实现对特征进行学习的算法，即能够自行学习所需要使用的特征。</p>
<p>算法的核心是通过学习得到2个维度较低的矩阵，一个代表用户的embedding矩阵，一个代表item的embedding矩阵，计算某个用户对于item的推荐值的时候，只需要将二者进行点积计算。再直白一点，比如电影拥有两个特征，动作属性和爱情属性，某用户A的embedding向量为θ=[5，1]，即A对电影中动作元素的偏爱为5，相对地对爱情元素的偏爱只有1。而某一部电影的X=embedding为[4，1]，那么我们将这2个向量直接进行点积，matmul(θ,transpose(X))，得到的值就是这部电影对于这个用户的推荐值，将不同电影的推荐值进行排序，其中推荐值最高的不就是应该推荐给A的电影了吗。</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF01.png" class="" title="CF图示">

<p>怎么得到这两个embedding矩阵呢？基于上面电影推荐的例子，假设我们知道每部电影的特征矩阵，即X已知 求θ。那这个问题就变成了一个很简单的线性回归问题。 已有的打分数据作为样本，我们的目标函数只需要将 θ·XT减去真实评分 作为误差，很简单就可以定义出目标函数：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-formula-1.png" class="" title="CF单体公式">

<p>其中</p>
<ul>
<li>θ^(j)代表用户j的embedding向量。</li>
<li>x^(i)则代表电影i的embedding向量。</li>
<li>r(i,j)为1表示用户j已经为电影i打了分，0则表示没有。</li>
<li>y^(i,j)为用户j给电影i的评分<br>将这个公式推广到所有用户：<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-formula-1.png" class="" title="CF公式">

</li>
</ul>
<p>有了目标函数我们在将其对θ求导</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-derivative-theta.png" class="" title="Lossd对θ导数">

<p>然后直接用梯度下降之类的优化算法进行求解即可。</p>
<p>同理，假设θ已知，我们也可以用同样的方式求得X。</p>
<p>你可能会想，这不就成了鸡生蛋还是蛋生鸡的问题了吗？问题是两者我们都不知道啊？</p>
<p>是的，你很清醒，没有被带偏，实际情况中，用户的偏好和电影的属性都很难收集，更别提特征这个东西本就虚无缥缈，爱情属性动作属性你还能够理解，真出来几百个特征，你能分清什么是什么吗?</p>
<p>这个时候协同过滤就钻出来了，在面对这种两个未知数可以互相更新的情况下，最好的方式就是初始化其中一个未知数，然后求得另一个未知数，再反过来求第一个未知数，以此类推，在这个过程中，2个未知数就会产生协同作用，终会完成收敛，达到生命的大和谐。想想pagerank,想想EM，是不是很熟悉~</p>
<p>除了让二者彼此更新，还可以将二者同时计算：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-form.png" class="" title="协同过滤">

<p>第一个式子是对每个用户，通过他们评价过的电影的类别来推断用户的喜好。第二个式子反过来，对每个电影，找出评价过它的用户的喜好来推断电影的类别。</p>
<p>其实二者前半部分就是第三个式子中的第一部分，只是第三个式子取得是一个(i,j)的对，表示所有用户评分过的电影。然后把二者的正则化都加上。实际上关于第三个式子，假如你假设x为常数，它就等于第一个式子，你假设θ为常数，它就等于第二个式子。</p>
<p>这就是协同过滤，实际实现过程中是可以用向量化实现从而不需要一个一个地进行计算的。这样的实现也叫做<strong>低秩矩阵分解(low rank matrix factorization)</strong>，还有一些地方叫做<strong>LFM(latent factor model)</strong>。不过矩阵分解方法并不是只此一家，SVD也是其中的佼佼者。这些方法最终都是得到user-item的隐式矩阵分解，获取二者的隐相量。</p>
<h3 id="personal-rank"><a href="#personal-rank" class="headerlink" title="personal rank"></a>personal rank</h3><p>推荐系统中最基础的两个部分就是user和item，整个系统也是user和item的交互，很容易想到，这就是一个图结构。那么，聪明的先行者们就想，能不能使用图算法来进行个性化推荐呢？ 当然可以~</p>
<p>user和item构成的图是一个<strong>二分图</strong>。</p>
<p>摘抄一下百度百科二分图的解释：<br>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p>
<p>而对于推荐系统而言，用户和item刚好是一个二分图，顶点分为user和item两类，且所有的变都是连接一个user和一个item的。</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_example.png" class="" title="示例">
<p>如上user和item构成了一个二分图，大写ABCD表示user，小写表示item。<br>personal rank比较各个item对于某个user的推荐值基于以下规则，其重要性一次递减：</p>
<ol>
<li>两个顶点间有多少条路径可以连通，如上图，从A-c，有A-a-B-c, A-d-D-c两条，而从A-e只有A-b-C-e一条，则c更值得推荐。</li>
<li>如果第一条相同，则比较连同路径的总长度，长度短者更值得推荐</li>
<li>如果1，2相同，则比较连同路径经过的顶点的出度和。</li>
</ol>
<p>基于此规则，我们来介绍personal rank方法的详细操作：<br>将二分图视作无向图，对于用户A进行推荐时，我们就从A节点出发开始在图上进行随机游走，以概率α从A所有的出度中等概率选择一条前进，到达对应顶点后(比如到了b)，再次以α的概率继续从a的出度中 等概率地选择一条继续前进，或者(1-α)的概率回到起点A，经历很多步之后，统计A到达各个item节点的次数求得概率。可以证明，只要步数足够大，此概率可以收敛。</p>
<p>把固定item对固定user的推荐得分记作PR值</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_formula.png" class="" title="personal_rank公式">
<p>其中out(v~)表示节点的出度。</p>
<p>可以看出，和pagerank算法非常相似，某个点的PR值等于 可以连通到该点的其它点的PR值除以自身出度 的和，即如a，有A,B可以连接到它，而A出度为3，B出度为2，故PR(a) = PR(A)/3 + PR(B)/2，再乘以一个概率α。A自身的PR值还要加上一个(1-alpha)。</p>
<p>直接迭代计算，复杂度太高了，像pagerank一样，我们也可以祭出矩阵来做：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_form_vec.png" class="" title="向量化实现">
<ul>
<li>r是一个n维向量，n是图中所有的节点数量，包括user节点和item节点，值则是每个节点的PR值。</li>
<li>r0也是一个n维向量，只有对应出发节点的元素为1，其余节点为0。</li>
<li>M是一个n阶转移矩阵，即图中节点与节点之间转移的概率，很好理解。<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/trans_M.png" class="" title="转移矩阵M">
这样不断将结果代入公式，r最终可以收敛。</li>
</ul>
<p>再对公式进行移项处理，得到：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_final_form.png" class="" title="移项处理后">

<p>向量化实现很简单，你把r0换成矩阵试试。</p>
<p>PS：</p>
<ul>
<li>在计算时很多喜欢去掉1-α这个值，是因为推荐时我们更多的是要的推荐排序结果，而不是具体的推荐值，故去掉一个常数乘子没有影响。</li>
<li>可以看到其中M是稀疏矩阵，故E-αMT也是稀疏矩阵。针对它的存储和计算都有很多成熟的方法。</li>
</ul>
<h3 id="item2vec"><a href="#item2vec" class="headerlink" title="item2vec"></a>item2vec</h3><p>item2vec是一个神经网络算法，它基本是属于word2vec的衍生品。word2vec算法在诞生后，其简洁的方法和出色的效果掀起了一股万物皆可embedding的热潮，item2vec就是将word2vec应用到推荐系统上的算法。</p>
<p>所以要说item2vec，就逃不了word2vec，word2vec是一个用于NLP的算法，由大神Tomas Mikolov在2013年的论文《Efficient estimation of word representations in vector space》中提出。word2vec是一篇跨时代的论文，在word2vec诞生前，语言中的词都是使用one-hot、tf-inf等统计学方法或者NNLM这种计算量非常大的n-gram方式进行表示的，这样就会使得数据维度特别高(语料库大小)和精度低，而且词与词的关系也被忽略了。word2vec是一种将其进行降维，并且可以表示出词与词关系的方法。而且从它开始的embedding的概念，使我们在NLP研究方面，也终于可以开始站在巨人的肩膀上了。</p>
<p>它使用的方式就是embedding，将词用向量来表示。如下：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/word2vecSample.png" class="" title="CF公式">
<p>每一列是一个词的向量表示，向量中的每个值可以看做是一个特征，比如king和queen在性别和皇室上都非常突出，这是非常符合直觉的。<br>注意：上图只是为了举例，真实的embedding向量中的值基本是很难解释的。</p>
<p>要得到词的embedding,我们只需要将embedding矩阵与该词的one-hot相乘，如下：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/embedding_matrix.png" class="" title="CF公式">

<p>这个embedding矩阵如何得到呢？</p>
<p>word2vec论文中介绍了2种方式，CBOW和skip gram。我以skip gram为例作一个简要的介绍：</p>
<p>比如我们的语料库大小为10000，现在有一个英文句子： I will try to climb a very high mountain tomorrow.<br>我们随机选择其中一个词来预测它上下文的其它词，比如 climb，接着我们就可以在它一定的上下文范围内选取词作为样本，如：(climb,mountain),(climb, high),(climb, I),(climb,to)。</p>
<p>接着我们使用这些选取的词的one-hot来乘以一个Embedding矩阵 E得到其词向量，再通过一层神经网络+softmax得到一个10000维的向量，向量的各个值就代表每个词出现在其上下文中的概率。<br>即： Oc * E = ec -&gt; θT * ec -&gt; softmax -&gt; yhat<br>其中E和θ就是我们的待训练参数，直接使用优化器进行更新，便可以得到我们的E。</p>
<p>而CBOW则差不多，区别在于CBOW是用多个词来预测一个词。</p>
<p>当然，word2vec还有很多的细节，比如如何通过分层计算或者负采样来减少softmax层的计算量以及选取上下文词的启发式方法等。你可以在文末找到该论文进行翻阅。</p>
<p>而item2vec 就是把item当作词，一起出现的item当作上下文(比如用户浏览的item的集合)，使用上面的word2vec方式学习到item的embedding矩阵，有了它，再用任何向量近似算法计算向量相似性作为item相似性还不是任你施为~ </p>
<p>比如根据用户最近浏览过的item推荐与之相似的item。</p>
<p><strong>和CF的区别</strong><br>都是计算隐相量embedding，item2vec和上面介绍的MF主要的区别就是MF计算的embedding是user-item的，而item2vec计算出的embeeding是item-item的，从二者最终的使用方式上便可看出来。其次，二者计算的方式也完全不一样~</p>
<p>至于二者的效果，MF更容易推荐比较热门的内容，而item2vec在时间窗口的基础上更能推荐user最近浏览的相似item。</p>
<h3 id="基于内容"><a href="#基于内容" class="headerlink" title="基于内容"></a>基于内容</h3><p>基于内容的推荐方法最好解释，它的思路非常简单，就是建立在“用户经常看什么，我们就给他推荐什么”的思路上。它应该是诞生最早的推荐方法了。<br>这种方法的一个特点是它的独立性，即给某个用户进行推荐的策略只跟这个用户有关，而与其它用 户的行为无关。</p>
<p>缺点也比较明显，没什么扩展性，且需要已经有一些用户的行为历史。</p>
<p>算法的主要流程为：</p>
<ol>
<li>给所有的item做分类，或者打标签，早期通过手动或者提取关键字来做，而后可以通过上面介绍的embeding方法来计算相似性来做，或者SVD。</li>
<li>做用户画像，基于用户的长短期行为得到用户感兴趣的分类或者标签。</li>
<li>基于1，2的结果进行推荐</li>
</ol>
<p>召回方法还有不少，上面介绍的几个只是比较有代表性的几个算法，使用这些算法进行多路召回并合并结果，得到的新的集合，就是我们下一步，排序的输入了。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>如果说召回决定了我们推荐效果的天花板，那么排序就决定了我们最终逼近天花板的程度。</p>
<p>在文章开头说过，排序阶段一般分成三个步骤：粗排-&gt;主排序-&gt;重排序。</p>
<p>粗排的原因时因为排序算法一般使用较为复杂的模型，使用较多的参数，速度相对较慢，如果召回阶段产出的item过多，会导致排序时间过长。于是先用一次粗排的过程来缩小样本范围。因此粗排一般使用比较简单的排序方法，比如使用后验CTR(点击率预估)和入库时的预估CTR值直接排序。</p>
<p>主排序则是我们要介绍的学习排序。</p>
<p>重排则是对主排的结果进行一些筛选，比如把结果放到一个类似于session model或者强化学习的模型里面进行重新排序，主要突出用户最近行为的特点。一般来说使用更少的样本范围，比如只把主排序结果的top k进行重排。</p>
<p>所以，最影响排序结果的，还是主排序部分。我们这里介绍的方法也是主排序的方法。</p>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归(logistic regression)这里就不展开来讲了，简单的说就是用函数关系来拟合真实的分布，然后用一个非线性的转换函数将结果拟合成分类结果。</p>
<p>推荐系统中基于一阶特征的逻辑回归如下：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/LR_formula.png" class="" title="LR公式">
<p>上式的x1,x2,…,xn代表不同的特征，sigmoid是一个可以将函数值映射到0-1间的函数：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/sigmoid.png" class="" title="sigmoid公式">
<p>接着再用交叉熵定义损失函数并用梯度下降更新求得w即可。</p>
<p>需要注意的是样本数据的选择和清洗，比如明显的异常数据便应该去掉。<br>其次，在特征的选取上，那种只有少量数据才拥有的特征意义就不大。</p>
<p>逻辑回归的缺点在于，要想取得好的结果，人工组合的特征不能少，但是人工特征需要不断组合、测试、调优，非常耗费人力，我们能否在模型层面自行进行特征组合呢？</p>
<h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p>单独写一篇文章来讲GBDT。<br>链接：todo..</p>
<h3 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT + LR"></a>GBDT + LR</h3><p>这个思路来自于《practical lessons from predicting clikcks on ads at facebook》这篇论文。</p>
<p>一句话就可以概括论文的主要想法：<br>逻辑回归进行融合特征时，一需要手动组合，二调参麻烦，而GBDT这种提升树模型不断用新的决策树学习残差的过程，就相当于不断地把特征变幻成了新的特征，如果把这种高维特征再放入LR模型中去训练，能不能得到更好的结果呢？</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/gbdt&lr.png" class="" title="gbdt&amp;lr-model">
<p>做法也很好实现，先训练好GBDT模型，再把每颗决策树的结果作为新的分类特征，然后使用LR模型进行训练。</p>
<p>看起来有一些trick，但实际效果确实在很多情况下略优于二者。<br>但2个模型并不是联合训练而是单独进行训练的，二者优化目标不同，从而解释性也就弱了。</p>
<h3 id="FM-factor-machine"><a href="#FM-factor-machine" class="headerlink" title="FM(factor machine)"></a>FM(factor machine)</h3><p>由上面的LR模型，我们有了一阶线性模型：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/state-1-LR.png" class="" title="lr公式">

<p>其实很容易想到，想要融入特征组合的概念，我们只需要添加一项：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/state-2-feature-combine.png" class="" title="特征组合">
<p>将特征两两组合构成新特征，再次放入线性模型，似乎就在模型层面完成了特征组合了。</p>
<p>其实不然，上诉方法在现实中是很难运用的，因为现实中的数据特征往往非常多，如淘宝京东的商品特征，量级超过千万。<br>这种情况下，数据矩阵是高度稀疏的，xi,xj同时不为0的可能性非常小，从而使得wij的训练几乎不可能。</p>
<p>FM模型就是一种求解这种高阶稀疏矩阵的方式，它将wij转化成2个向量大小为k的一维向量vi和vj的內积</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/fm-formula.png" class="" title="fm公式">
<p>它的本质还是我们上面提到的embedding，为什么它能解决稀疏矩阵的计算问题呢？<br>因为它的计算并不依赖于xi,xj这种特征组合是否出现，vi的本质是一个embedding, 于某个特征xi而言，只要有足够多xi和其它任何特征一起出现的样本，那么vi就是可以被训练出来的。此时和同样被训练出来的vj计算內积，便可以得到二者组合特征的权重。如下：</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/fm-illustrate.jpg" class="" title="fm图解">
<p>这就是embedding的核心特点，将one-hot或者1-0的硬匹配，转换成了向量间的软匹配，从而能够近似的得到2个本来匹配不上的特征的关系。</p>
<p><strong>公式化简</strong><br>上诉FM公式中的xixj交叉项是可以化简的，从而更好的进行model serving。</p>
<p>首先，我们要考虑的交叉项肯定不包括自己与自己组合，所以xixi这种情况不考虑，其次xixj,xjxi这种重复的，我们也只算一次。那么原始可以化简如下:</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/FM-briefy.png" class="" title="fm化简">
<ol>
<li>第一步式子中的1/2就是在去重，而减去的项则是自身与自身进行的特征组合。</li>
<li>第二步则是将向量內积展开，k是向量v的维度。</li>
<li>第三步则是先将k求和移到最外层，然后内层是在确定某个特征的第l位的情况下，与其它特征对应的第l位相乘并求和。</li>
<li>第三步到第四步，注意2个求和符号，虽然一个是i，一个是j，但范围相同，求和的对象也相同，所以实际是一样的，直接把乘改为平方即可。</li>
</ol>
<p>在实际的编码中就很好表示了，Σvilxi就是 样本特征矩阵*v, 最外层的Σ则是求和操作。</p>
<p>再根据实际情况是分类还是回归选择合适的损失函数进行求导即可，因为我们的式子里有常数项、一阶项和二阶交叉项，所以导数也是3个哦~</p>
<h3 id="使用DNN"><a href="#使用DNN" class="headerlink" title="使用DNN"></a>使用DNN</h3><p>深度学习在图像和NLP领域都搞得热火朝天如火如荼，那推荐系统可以蹭一蹭吗？答案是可以的，比起上诉的LR,GBDT,FM，神经网络模型最大的优点就是它可以完全自动地对特征进行非线性的组合，且覆盖了二阶组合和高阶组合。</p>
<p>将DNN引入推荐系统，最常用的方法就是wide and deep模型，它来自于google的一篇论文：《Wide &amp; Deep Learning for Recommender Systems》(文末附链接)。</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/wideAndDeep.png" class="" title="wideAndDeep模型">
<p>左边的wide部分是一个LR或者FM模型，而右边的deep则是一个神经网络模型，或者说MLP模型。w&amp;d模型的输出是将wide侧输出与deep侧最后一个隐层的输出相加，然后再进行激活得到的。这样做的目的是可以在一次反向传播中同时更新两边的参数，达到联合训练的目的。</p>
<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/w&d-formula.png" class="" title="w&amp;d激活">
<p>x_cross是组合特征。<br>Loss目标函数则根据项目的实际情况自行定义，定义好后，再利用神经网络的反向传播进行求解即可。</p>
<p>当然，DNN也有其缺点。而且成也萧何败萧何，上面我们说自动组合特征是DNN的优点，但也是缺点。这种最纯粹的w&amp;d模型，只依靠MLP本身来自动对特征进行组合，但其内里却完全是一个黑盒子，我们并不知道真正组合了什么。</p>
<p>一般来说在实际进行使用的时候，这些排序模型在大规模数据上得到的效果是 w&amp;d&gt;LR+GBDT&gt;GBDT&gt;LR的。<br>当然，实际情况实际讨论，在模型落地的时候我们都会进行一些符合业务逻辑的修改，或者加入一些其它的想法。所以，选择合适的才是最重要的。</p>
<p>其次，对于实际上线的效果，有很多评估指标，通用的比如AUC、F1，测试集表现等。不同的业务还能根据实际业务定义相应的业务指标。</p>
<p>在特征的选取上，排序阶段则是可以尽量把相关的side info都特征化，毕竟这个阶段的目标就是精确，而更多的信息往往能够得到更好的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再总结一下流程，首先，使用多路召回并合并，从所有item中找到最适合推荐给用户的近千的item。进入排序阶段后，如果item过多导致排序时间长，可以加入粗排阶段，用一些简单的排序模型对召回返回的item进行一次筛选，进一步缩小item范围。接着再使用精确度较高的主排序模型进行精准排序。最后，再根据一些业务策略筛选，比如使实际推荐结果多样化，或者去除已读item等，然后再推荐给用户。</p>
<p>而为了验证模型效果和继续优化模型，我们要继续收集用户的各种行为和反馈。</p>
<p>这些行为和反馈一部分可以实时的用来更新在线推荐模型，让用户的实时行为在下一次刷新中即可得到体现。<br>而所有这些数据都应该被记录下来补充进我们的离线训练数据，从而用更大的模型进行离线训练，从而周期性地对模型进行更新。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Andrew Ng在coursera上的机器学习课程</a><br><a href="https://arxiv.org/abs/1301.3781v3" target="_blank" rel="noopener">word2vec论文:Efficient Estimation of Word Representations in Vector Space</a><br><a href="https://arxiv.org/abs/1603.04259" target="_blank" rel="noopener">item2vec论文:Item2Vec: Neural Item Embedding for Collaborative Filtering</a><br><a href="https://zhuanlan.zhihu.com/p/58160982" target="_blank" rel="noopener">知乎张俊林专栏：全能的FM模型</a><br><a href="https://quinonero.net/Publications/predicting-clicks-facebook.pdf" target="_blank" rel="noopener">gbdt&amp;lr论文：Practical Lessons from Predicting Clicks on Ads at Facebook</a><br><a href="https://arxiv.org/abs/1606.07792" target="_blank" rel="noopener">wide and deep论文:Wide &amp; Deep Learning for Recommender Systems</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/" class="post-title-link" itemprop="url">简单的触发词识别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 14:01:49" itemprop="dateCreated datePublished" datetime="2020-04-21T14:01:49+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-10 17:37:52" itemprop="dateModified" datetime="2020-05-10T17:37:52+08:00">2020-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文参考andrew Ng, Sequence Model,  notebook-Trigger word detection.</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当你对苹果手机叫出”hey siri”，或对小米手机叫出”小爱同学”时，手机助手会立刻出现，这就是触发词识别系统，是一种识别音频并且在接收到某个触发词的时候激活的程序。不同于一般的语音识别需要大量的数据(超过10W小时)来训练，触发词系统的训练相对简单很多。</p>
<p>当你完成这个程序的时候，你可以将它扩展并布置到自己的电脑上，每当你说出某个激活词的时候，你的电脑可以随即自动打开某个app，或者是播放某一首音乐，听起来是不是很棒(吧？)。</p>
<p>因为声音数据是序列数据，我们用RNN&amp;GRU来做这个用识别触发词的程序，当程序听见语音”激活”的时候就给出一个某种反应。</p>
<h2 id="创建语音数据集"><a href="#创建语音数据集" class="headerlink" title="创建语音数据集"></a>创建语音数据集</h2><p>语音数据是很难获取的一类数据，这里我们需要的样本是10秒钟的数据，其中会随时出现我们的激活词。如果我们自己录制这些样本，因为数量比较大，这将会相当困难，于是我们考虑使用音频合成来制作我们的数据集。<br>首先，我们需要一些用于合成的元数据。因此我们需要去到各种环境中用不同人，不同口音录制”激活”以及任何其它语音。<br>将它们分为 positive\negative\background三类，positive为不同人不同口音念我们的激活词， negative 则是随机的其它词，background则是各种背景音，持续10秒。<br>PS：因为口音和词语长短不同，positive和negative的语音文件长度不定。</p>
<p>收集完语音后，我们需要对其进行处理。<br>一般来说，录制的声音文件根据设备的不同，拥有不同的HZ数。这里假设我们采集的样本为44100HZ，即录制的音频文件每秒有44100个数字。</p>
<p>要直接处理这种文件相对来说是较为困难的，所以更流行的做法是将数据用傅里叶变换转化为频谱(spectrogram)，这是信号处理相关的知识。这里我们直接用软件包实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; graph_spectrogram(&quot;audios&#x2F;train_example.wav&quot;)</span><br></pre></td></tr></table></figure>
<img src="/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/spectrogram-img.png" class="" title="频谱片">

<p>频谱图直观上体现的是频率(y轴)和时间(x轴)的图像关系，偏绿的颜色表示频率较高，而蓝色则相反。</p>
<p>频谱输出的数据维度是由程序的超参数和输入数据的长度决定的，这里我们使用的转换程序，10秒的数据将拥有5511个timestep，即Tx=5511.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;spectrogram shape:&quot;, x.shape)</span><br></pre></td></tr></table></figure>
<p>输出为(101,5511)。<br>因此我们可以定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tx &#x3D; 5511 </span><br><span class="line">n_freq &#x3D; 101 # 每个timestep中输入到模型中的频率数</span><br><span class="line">Ty &#x3D; 1375 # 我们程序的输出将会把10秒切分为1375份</span><br></pre></td></tr></table></figure>

<h3 id="合成语音"><a href="#合成语音" class="headerlink" title="合成语音"></a>合成语音</h3><p>三个步骤</p>
<ol>
<li>首先我们随机选取一个background音频</li>
<li>随机将0-4个正样本音频片段插入</li>
<li>随机将0-2个负样本音频片段插入<br>因为是我们控制的插入，我们同时可以得到Ylabel数据，即第几个timestep为激活词刚刚说完的时刻，记为y&lt;t&gt;=1,但一般来说为了避免label数据过于稀疏，我们会把激活词结束后的一段timestep的y都置为1，这里我们选择的一段为50个timestep。</li>
</ol>
<p>使用pydub包来处理音频，这个包将会用ms作为时间轴最小单位，10秒的数据将会有10000个timestep.</p>
<p>注意，合成后的音频应该依然为10秒，即正负样本都应该被background完全容纳，且二者互相不能重叠。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activates, negatives, backgrounds &#x3D; load_raw_audio()</span><br></pre></td></tr></table></figure>
<p>先来实现几个工具方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># 获取插入位置</span><br><span class="line">def get_random_time_segment(segment_ms):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    从10000个timestep中随机取一个timestep，作为之后的插入位置</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    segment_ms -- 要插入音频的ms长度</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    segment_time -- a tuple(segment_start, segment_end) in ms，插入的开始和结束timestemp</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    segment_start &#x3D; np.random.randint(low&#x3D;0, high&#x3D;10000-segment_ms)   # 确保插入的音频不会超出background的结尾</span><br><span class="line">    segment_end &#x3D; segment_start + segment_ms - 1</span><br><span class="line">    </span><br><span class="line">    return (segment_start, segment_end)</span><br><span class="line"></span><br><span class="line"># 检查是否发生重叠</span><br><span class="line">def is_overlapping(segment_time, previous_segments):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Arguments:</span><br><span class="line">    segment_time -- a tuple(segment_start, segment_end) 新插入片段的起止时间</span><br><span class="line">    previous_segments -- a list of tuples(segment_start, segment_end) 已经插入的片段的起止时间列表</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    True or False 代表是否发生重叠</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    segment_start, segment_end &#x3D; segment_time</span><br><span class="line"></span><br><span class="line">    overlap &#x3D; False</span><br><span class="line">    </span><br><span class="line">    for previous_start, previous_end in previous_segments:</span><br><span class="line">        # 作业提示可以用 if ... &lt;&#x3D; ... and ... &gt;&#x3D; ... 这种形式实现，我没想出来呢</span><br><span class="line">        if (previous_start &gt; segment_end or segment_start &gt; previous_end) &#x3D;&#x3D; False :</span><br><span class="line">            overlap &#x3D; True</span><br><span class="line"></span><br><span class="line">    return overlap</span><br><span class="line"></span><br><span class="line"># 向background中随机位置插入音频片段，确保不会发生重叠和超出</span><br><span class="line">def insert_audio_clip(background, audio_clip, previous_segments):</span><br><span class="line">    &quot;&quot;&quot; </span><br><span class="line">    Arguments:</span><br><span class="line">    background -- 10秒钟的背景音频.  </span><br><span class="line">    audio_clip -- 要插入的音频. </span><br><span class="line">    previous_segments -- 已经插入在background中的音频的起止时间</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    new_background -- 插入音频后的新的background</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # Get the duration of the audio clip in ms</span><br><span class="line">    segment_ms &#x3D; len(audio_clip)</span><br><span class="line">    </span><br><span class="line">    segment_time &#x3D; get_random_time_segment(segment_ms)</span><br><span class="line">    </span><br><span class="line">    while is_overlapping(segment_time, previous_segments):</span><br><span class="line">        segment_time &#x3D; get_random_time_segment(segment_ms)</span><br><span class="line"></span><br><span class="line">    previous_segments.append(segment_time)</span><br><span class="line">    </span><br><span class="line">    # 将音频在background的对应位置叠加进去</span><br><span class="line">    new_background &#x3D; background.overlay(audio_clip, position &#x3D; segment_time[0])</span><br><span class="line">    </span><br><span class="line">    return new_background, segment_time</span><br></pre></td></tr></table></figure>

<p>插入了激活词语音后，我们就需要对Ylabel做出更新，如我们上面所说，将结束位置的后面50个y都更新为1。<br>因为我们的y的维度为1375而音频数据维度为10000，所以要记得做一下缩放。还要确保如果音频插入在background的尾部，导致后面没剩下50个值，注意不要越界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def insert_ones(y, segment_end_ms):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Arguments:</span><br><span class="line">    y -- numpy array of shape (1, Ty),训练样本的标签值</span><br><span class="line">    segment_end_ms -- 插入的激活音频的结束时间</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    y -- 更新后的 labels</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 缩放</span><br><span class="line">    segment_end_y &#x3D; int(segment_end_ms * Ty &#x2F; 10000.0)</span><br><span class="line">    </span><br><span class="line">    for i in range(segment_end_y, segment_end_y + 50):</span><br><span class="line">        if i &lt; Ty:</span><br><span class="line">            y[0, i] &#x3D; 1</span><br><span class="line">    </span><br><span class="line">    return y</span><br></pre></td></tr></table></figure>

<p>接下来就可以创建我们的训练样本了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def create_training_example(background, activates, negatives):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Creates a training example with a given background, activates, and negatives.</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    background -- a 10 second background audio recording</span><br><span class="line">    activates -- a list of audio segments of the word &quot;activate&quot;</span><br><span class="line">    negatives -- a list of audio segments of random words that are not &quot;activate&quot;</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    x -- the spectrogram of the training example</span><br><span class="line">    y -- the label at each time step of the spectrogram</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 减小噪音</span><br><span class="line">    background &#x3D; background - 20</span><br><span class="line"></span><br><span class="line">    y &#x3D; np.zeros((1,Ty))</span><br><span class="line"></span><br><span class="line">    previous_segments &#x3D; []</span><br><span class="line">    </span><br><span class="line">    # 随机插入0-4段激活音频</span><br><span class="line">    number_of_activates &#x3D; np.random.randint(0, 5)</span><br><span class="line">    random_indices &#x3D; np.random.randint(len(activates), size&#x3D;number_of_activates)</span><br><span class="line">    random_activates &#x3D; [activates[i] for i in random_indices]</span><br><span class="line">    </span><br><span class="line">    for random_activate in random_activates:</span><br><span class="line">        background, segment_time &#x3D; insert_audio_clip(background, random_activate, previous_segments)</span><br><span class="line">        segment_start, segment_end &#x3D; segment_time</span><br><span class="line">        y &#x3D; insert_ones(y, segment_end)</span><br><span class="line"></span><br><span class="line">    # 随机插入0-2段negative语音</span><br><span class="line">    number_of_negatives &#x3D; np.random.randint(0, 3)</span><br><span class="line">    random_indices &#x3D; np.random.randint(len(negatives), size&#x3D;number_of_negatives)</span><br><span class="line">    random_negatives &#x3D; [negatives[i] for i in random_indices]</span><br><span class="line"></span><br><span class="line">    for random_negative in random_negatives:</span><br><span class="line">        background, _ &#x3D; insert_audio_clip(background, random_negative, previous_segments)</span><br><span class="line">    </span><br><span class="line">    # 标准化一波 </span><br><span class="line">    background &#x3D; match_target_amplitude(background, -20.0)</span><br><span class="line"></span><br><span class="line">    # 导出训练样本</span><br><span class="line">    file_handle &#x3D; background.export(&quot;train&quot; + &quot;.wav&quot;, format&#x3D;&quot;wav&quot;)</span><br><span class="line">    print(&quot;File (train.wav) was saved in your directory.&quot;)</span><br><span class="line">    </span><br><span class="line">    # 绘制频谱图</span><br><span class="line">    x &#x3D; graph_spectrogram(&quot;train.wav&quot;)</span><br><span class="line">    </span><br><span class="line">    return x, y</span><br></pre></td></tr></table></figure>

<p>然后我们就用这个方法去创建一大堆的训练样本。<br>然后将创建好的训练样本赋值给 <strong><em>X</em></strong> 和 <strong><em>Y</em></strong></p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>我们用keres来实现这个模型。<br>模型共四层</p>
<ul>
<li>第一层是一个卷积层，因为我们的频谱数据为1维，所以是一维卷积(196个滤波器，滤波器长度15，步幅为4)，卷积后再做一次BN，并用ReLu激活，再用Dropout进行一次正则化。</li>
<li>第二层是一个GRU层，保证网络的记忆能力，并且也对输出的数据做Dropout和BN处理。</li>
<li>第三层继续用一个GRU层。</li>
<li>最后一层为全连接，且接sofxmax作为输出。</li>
</ul>
<p>如下：</p>
<img src="/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/model.png" class="" title="模型图片">

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def model(input_shape):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用keras构造训练模型</span><br><span class="line">    </span><br><span class="line">    Argument:</span><br><span class="line">    input_shape -- 模型输入数据的形状</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    model -- keras model 实例</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    X_input &#x3D; Input(shape &#x3D; input_shape)</span><br><span class="line">    </span><br><span class="line">    # Layer 1: CONV layer </span><br><span class="line">    X &#x3D; Conv1D(filters&#x3D;196,kernel_size&#x3D;15,strides&#x3D;4)(X_input)   # CONV1D</span><br><span class="line">    X &#x3D; BatchNormalization()(X)                                 # Batch normalization</span><br><span class="line">    X &#x3D; Activation(&quot;relu&quot;)(X)                                   # ReLu activation</span><br><span class="line">    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                    # dropout (use 0.8)</span><br><span class="line"></span><br><span class="line">    # Layer 2: First GRU Layer</span><br><span class="line">    X &#x3D; GRU(units&#x3D;128, return_sequences &#x3D; True)(X)           # GRU (use 128 units and return the sequences)</span><br><span class="line">    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                 # dropout (use 0.8)</span><br><span class="line">    X &#x3D; BatchNormalization()(X)                              # Batch normalization</span><br><span class="line">    </span><br><span class="line">    # Layer 3: Second GRU Layer</span><br><span class="line">    X &#x3D; GRU(units&#x3D;128, return_sequences &#x3D; True)(X)           # GRU (use 128 units and return the sequences)</span><br><span class="line">    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                 # dropout (use 0.8)</span><br><span class="line">    X &#x3D; BatchNormalization()(X)                              # Batch normalization</span><br><span class="line">    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                 # dropout (use 0.8)</span><br><span class="line">    </span><br><span class="line">    # Layer 4: Time-distributed dense layer</span><br><span class="line">    X &#x3D; TimeDistributed(Dense(1, activation &#x3D; &quot;sigmoid&quot;))(X) # time distributed  (sigmoid)</span><br><span class="line"></span><br><span class="line">    model &#x3D; Model(inputs &#x3D; X_input, outputs &#x3D; X)</span><br><span class="line">    </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<p>注意上面最后一层的 TimeDistributed 层，<a href="https://machinelearningmastery.com/timedistributed-layer-for-long-short-term-memory-networks-in-python/" target="_blank" rel="noopener">这里</a>有关于它的使用的完全解释。<br>简单的说，它是使用timestep来进行操作，且对每个timestep的数据都共享权重。<br>比如这里我们用它包装了Dense，即是说对每个timestep的结果，都使用同样的参数计算Dense输出结果。</p>
<p>接下来就可以进行训练了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opt &#x3D; Adam(lr&#x3D;0.0001, beta_1&#x3D;0.9, beta_2&#x3D;0.999, decay&#x3D;0.01)</span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;, optimizer&#x3D;opt, metrics&#x3D;[&quot;accuracy&quot;])</span><br><span class="line">model.fit(X, Y, batch_size &#x3D; 5, epochs&#x3D;100)</span><br></pre></td></tr></table></figure>
<p>得到：<br>Epoch 100/100<br>26/26 [==============================] - 34s - loss: 0.0610 - acc: 0.9796 </p>
<p>接下来如果有开发集，可以对模型进行测试，开发集样本最好来自真实分布，即去真实的环境说话进行录音。</p>
<h2 id="预测和更多操作"><a href="#预测和更多操作" class="headerlink" title="预测和更多操作"></a>预测和更多操作</h2><p>接下来就可以用这个训练好的模型进行预测了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; graph_spectrogram(filename)</span><br><span class="line">x  &#x3D; x.swapaxes(0,1)</span><br><span class="line">x &#x3D; np.expand_dims(x, axis&#x3D;0)</span><br><span class="line">predictions &#x3D; model.predict(x)</span><br></pre></td></tr></table></figure>

<p>还可以在触发的时候做更多的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consecutive_timesteps &#x3D; 0</span><br><span class="line">for i in range(Ty):</span><br><span class="line">        consecutive_timesteps +&#x3D; 1</span><br><span class="line">        if predictions[0,i,0] &gt; threshold:</span><br><span class="line">            # 任何操作</span><br><span class="line">            whatever_you_wanna_do()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">机器学习中的各种优化器算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-16 00:20:14 / 修改时间：00:40:42" itemprop="dateCreated datePublished" datetime="2020-04-16T00:20:14+08:00">2020-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">基础算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>深度学习中的优化器有很多种，除了我们熟悉的梯度下降外，还有一些诸如 RMSProp，adam 等优秀的优化器。来了解一波~</p>
<h2 id="梯度下降-GD-BGD-MBGD"><a href="#梯度下降-GD-BGD-MBGD" class="headerlink" title="梯度下降 GD,BGD,MBGD"></a>梯度下降 GD,BGD,MBGD</h2><p>梯度下降（GD：gradient descent）大家都很熟悉，这里也不做详细介绍。整体就是先初始化求解参数，然后通过求解损失函数对求解参数的导数来对我们的求解参数进行更新，直到收敛。 </p>
<p>梯度下降分为BGD（batch：批量梯度下降），SGD（stochastic：随机梯度下降）和 MBGD(Mini-Batch：小批量梯度下降)，区别在于每次更新梯度时使用的样本的数量，分别为全部样本，单个样本和一部分样本。</p>
<p>梯度下降找到的最优解一般为函数的一个鞍点，即局部最优解。<br>MBGD和SGD因为样本较少，随机性太强，梯度往往震荡很大，如下：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/GDvsMBGD.png" class="" title="GDvsMBGD">

<p>要解决这个问题，使用MBGD进行优化时我们可以对学习率进行衰减来使之收敛。</p>
<p>PS:因为计算机本身的一些性质，将批次量设置为2的幂数计算会更快。</p>
<p>当然，还有比小批次下降更快的算法。但在学习它们之前，我们首先要了解指数加权平均。</p>
<h2 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h2><p>什么是指数加权平均？</p>
<p>参考吴恩达老师对此的讲解，用一个例子来进行说明：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/LondonTempreture.png" class="" title="LondonTempreture">

<p>上图是伦敦一年之中每天的温度情况，我们来对它做一些处理，把每天的温度值记作Vn。则：<br>V0=0， V1 = 0.9*V0 + 0.1*θ1， V2=0.9V1 + 0.1*θ2，…<br>θ为上图中当天真实的温度值，这个0.9我们记作β，那么公式记为：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/formulaVt.png" class="" title="formulaVt">

<p>稍微进行一下联想，这个V可以近似看做是之前1/(1-β)天的平均值，当我们分别取β=0.9(红色曲线)和0.98(绿色曲线)时，图像为：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/TempretureHandled.png" class="" title="TempretureHandled">

<p>β取0.9，我们把这个式子展开：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/UnfoldFormulaV.png" class="" title="UnfoldFormulaV">

<p>θ随着时间推后是β的指数级衰减，且一般来说，指数加权的衰减大约会在1/(1-β)后衰减到大约三分之一的程度，比如0.9的1/(1-0.9)次方约等于0.35，所以我们说它大约是最近10天的平均值。这就是指数加权平均名称的由来。</p>
<p>指数加权平均减少了存储空间的使用，当我们需要某个V的值时，只需要通过计算即可获得，因此它在机器学习中得到了大量的应用。</p>
<p>细心的你可能注意到，我们的V0取值为0，这会在计算初期的时候产生较大的误差值。<br>因此在很多时候，我们会对V的值进行<strong><em>偏差修正</em></strong>。<br>使 Vt = Vt/(1-β^t)  ，从而对Vt进行放大，而随着t的增大，放大率会逐渐趋于1。</p>
<p>有了这个基础，我们就可以介绍一些其它的优化器方法。</p>
<h2 id="动量梯度算法（momentum）"><a href="#动量梯度算法（momentum）" class="headerlink" title="动量梯度算法（momentum）"></a>动量梯度算法（momentum）</h2><p>算法的主要思想其实很简单，就是把我们刚才学习的指数加权平均用来计算梯度，然后用计算得到的梯度来进行参数更新。<br>在上面的梯度下降算法中，考虑多维度的情况，如下：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/momentumExample.png" class="" title="momentumExample">

<p>于收敛来说，竖直方向的震荡显然是无益的，我们希望能够减小竖直方向的震荡。</p>
<p>动量梯度下降的步骤如下<br>第t次迭代：</p>
<ol>
<li>用当前小批量样本 计算 参数W和 偏差b的导数</li>
<li>Vdw = βVdw + (1-β)dw， Vdb = βVdb + (1-β)db</li>
<li>W := W - αVdw,   b := b-αVdb </li>
</ol>
<p>end<br>我们还是对批次数量进行迭代，整个算法中中有2个超参数，α和β，α为学习率，β是我们上面学习到的指数加权。</p>
<p>为什么咋这么做可以有效呢？因为指数加权平均的平均，它就让垂直方向上相反的震荡被平均从而变小，而水平方向的震荡方向是相同的，平均值依然很大，故整体收敛速度就加快了。</p>
<p>PS:动量梯度下降时基本不用偏差修正，β基本都是选择0.9。</p>
<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>RMSprop全称为均方根传递(Root Mean Square prop), 它也可以加速梯度下降。<br>计算方式如下：</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/RMSPropStep.png" class="" title="RMSPropStep">

<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/RMSPropImg.png" class="" title="RMSPropImg">
<p>RMSprop主要的思想是缩小大的震荡，加快小的震荡。如上图，垂直方向的震荡很大，而水平方向很小，RMSprop就会缩小垂直方向的震荡，加快水平方向的速度。<br>原理很简单，如果垂直方向的震荡较大，那么Sdb就会很大，那么作为除数，更新速度就减慢了，相反，水平方向较慢，Sdw就较小，W的更新速度就加快了。<br>当然，实际应用中，并没有垂直水平这么简单，我们加快的是慢的维度，减慢的是快的维度。<br>而且为了防止除0发生，通常在分母上我们会加一个很小的EPSON，大概10e-8</p>
<p>接下来，我们把RMSprop和动量结合起来，会得到一个更好的优化算法。<br>为了防止冲突，RMSprop中的β，我们用β_2表示</p>
<h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>adaptive moment estimation 自适应矩估计<br>adam优化算法实际上就是将RMSprop和动量梯度下降结合起来的算法。<br>在机器学习领域和深度学习领域中，曾经提出了非常多的优化算法，但大多数算法都不能很好的适应于不同的网络结构，adam算法是少有的在非常多网络结构中都能够产生非常好效果的算法。</p>
<p>在机器学习领域和深度学习领域中，曾经提出了非常多的优化算法，比如Adagrad,Adadelta等，但大多数算法都不能很好的适应于不同的网络结构，adam算法是少有的在非常多网络结构中都能够产生非常好效果的算法。</p>
<p>初始化Vdw，Sdw,  Vdb, Sdb为0</p>
<img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/AdamStep.png" class="" title="AdamStep">

<p>l为网络层数，两个β分别是动量梯度和RMSprop中的加权，α为学习率，同样，为了防止除0发生，通常在分母上我们会加一个很小的EPSON，大概10e-8（上图没加）。</p>
<p>几个超参数，一般β1选择0.9，β2选择0.999，EPSON选择10e-8。<br>而α，一个好的方法就是逐渐减小学习速率，使用一个衰减率来对学习率进行衰减。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/04/03/BERT%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/03/BERT%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">BERT笔记-简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-03 13:48:42" itemprop="dateCreated datePublished" datetime="2020-04-03T13:48:42+08:00">2020-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-05 23:04:37" itemprop="dateModified" datetime="2020-05-05T23:04:37+08:00">2020-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>BERT，全名 Bidirectional Encoder Representation from Transformers。是Google AI团队在2018年推出的一个NLP模型，在机器阅读理解顶级水平测试SQuAD1.1上全面超越人类表现，并在11项NLP测试中拿到最佳成绩。这也导致BERT的大火。</p>
<p>BERT的出现彻底改变了pre-train产生词向量和下游NLP训练任务间的关系。</p>
<p>//todo 留坑</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toulondu.github.io/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toulon Du">
      <meta itemprop="description" content="Sharing Knowledge And Learn More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toulon's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Transformer模型简介(笔记)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-02 22:04:42 / 修改时间：22:21:58" itemprop="dateCreated datePublished" datetime="2020-04-02T22:04:42+08:00">2020-04-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Transformer来自Google 2017年的一篇文章，在原来的Attention&amp;RNN模型上抛弃了RNN，用全attention的结构取得了更好的效果。<br>这里做一做自己学习的笔记，也算一个简单的介绍。<br>内容图片很多来自于原论文<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>和<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a>这篇文章。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>原论文给出的结构如下：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/structureOfTransformer.png" class="" title="transformer结构">
<p>可以看到由左右两个部分，左边的Encoders和右边的Decoders组成。两边都有一个”N×”,表示各自由N个同样的结构重复N次组成，原文中是6。就是下面图中的样子。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/encodersAndDecoders.png" class="" title="展开">

<h2 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h2><p>我们来看一看Encoder部分。</p>
<p>因为是NLP的案例，所以我们首先要把我们的输入数据，即词变成词向量，这通过embedding实现，embedding后的数据作为Encoder的输入。<br>虽然有很多encoder，但embedding只用在最下面一层的encoder上，其它的encoder都是用上一层encoder的输出作为输入。</p>
<p>每个encoder都是一样的结构，都由两个子结构组成：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/EachEncoder.png" class="" title="encoder组成">

<p>self-attention的作用是，当你在处理某个具体的词时，self-attention允许你从句子中的其它位置处寻找线索，从而对当前词的理解和预测起到帮助。</p>
<h3 id="self-attention-细节"><a href="#self-attention-细节" class="headerlink" title="self-attention 细节"></a>self-attention 细节</h3><p>计算self-attention主要有以下几个步骤</p>
<p><strong>第一步</strong><br>计算self-attention的第一步是从每个输入向量中创建出3个向量(Querry,Key,Value)。他们通过把embedding分别与三个矩阵相乘得到，三个矩阵通过训练过程得到。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformerSelfAttentionVectors.png" class="" title="QSV">

<p>Q,S,V较之embedding的维度要小，在文中的维度是64，而embedding的维度是512。不必完全一样，但这是一种使得计算比较稳定的结构选择。</p>
<ul>
<li>Q = WQ * x</li>
<li>K = WK * x</li>
<li>V = WV * x</li>
</ul>
<p><strong>第二步</strong><br>计算self-attention的第二步是计算一个score。 假设我们正在计算的句子的第一个单词为”Thinking”。我们需要把输入的句子中的每一个词与这个词运算来得到一个score，这个score决定了我们在encode当前词的时候句子其它位置所施加的影响。</p>
<p>计算方法是把当前次的Q与要计算的词的K值进行点乘。即如果我们要计算#1位置处的self-attention，第一个我们要计算的score将是把q1和k1点乘，第二个socre则是把q1和k2进行点乘。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/SelfAttentionScore.png" class="" title="计算score">


<p><strong>第三步和第四步</strong><br>第三步和第四步是将得到的score除以8，这个8是QKV向量的维度64的平方根。这可以让梯度更加稳定(直接归一值差距较大)。当然可以不是8，这里只是一个默认值。接着将结果传递给一个softmax操作，这将把socre的值标准化，使它们都为正，且和为1。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/selfAttentionSoftmax.png" class="" title="计算权重">

<p><strong>第五步</strong><br>第五步是将每个V与第四步的结果相乘。这一步从直觉上讲是保留当前词想要关注的其它词语的完整性，同时丢掉不相关的词语(通过乘以了非常小的数)。</p>
<p><strong>第六步</strong><br>将得到的带权重的数据向量相加。这将得到self-attention层在这个位置(我们这里是第一个词)的输出。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/selfAttentionOutput.png" class="" title="encoder输出">

<p>这就是self-attentionde的计算过程，结果向量我们将传递给接下来的 feed-forward nertal network处理。<br>当然，在实际实现中，这些计算都可以通过矩阵形式的计算从而更加快速。</p>
<p><strong>self-attention的矩阵计算</strong><br>使用矩阵，第二步到第六步实际上可以在一个公式内进行计算：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/selfAttentionMatrixCalculation.png" class="" title="矩阵计算公式">



<h3 id="multi-headed"><a href="#multi-headed" class="headerlink" title="multi-headed"></a>multi-headed</h3><p>文章进一步用一个叫做”multi-headed” attention的结构增强了self-attention。它从2个方面提升了attention层的表现：<br><strong>扩张了模型关注其他位置的能力</strong><br>在我们上面的例子中，对thinking的编码就包含了句中其它位置词的影响(当然，最大的影响依然是它自己)。在解析一些有明显指向性的代词时就显得非常有用。比如“The animal didn’t cross the street because it was too tired”中的”it”指代的谁。<br><strong>给了attention层多重”表述子空间”</strong><br>这主要通过多组[WQ,WK,QV]来实现，文中使用了8组WQ,WK,QV，这些矩阵都通过随机初始化赋值。即是说我们会得到8组QKV，从而得到8个输出矩阵。每一个都是输入数据的一个表述子空间。</p>
<p>在传递给feed-forward network前，我们需要将他们处理成一个矩阵。通过将这8个矩阵堆叠起来，再与一个权重矩阵WO相乘得到。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformer_attention_heads_weight_matrix_o.png" class="" title="concat结果">

<p>以上大概就是 multi-headed self-attention 的内容。原文将他们放到一张图上：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/encoderTotalLook.png" class="" title="整体造型">

<h3 id="position-encoding"><a href="#position-encoding" class="headerlink" title="position encoding"></a>position encoding</h3><p>因为放弃了使用RNN，那么句子中词与词的位置关系就被忽略了，文中使用了一种position encoding的方式将位置信息补入模型中。<br>这通过给每一个input embedding加上一个vector来实现。这些vector遵循一种<strong><em>特殊的模式</em></strong>，它存储了每个词的位置信息，通过把它与embedding相加，从而把这种信息代入到后面的QKV和点乘的计算过程中。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformer_positional_encoding_vectors.png" class="" title="位置编码">

<p>如果我们的embedding是512维的向量，那么要加的positional encoding 向量也是512维。</p>
<p>关于位置编码，文中使用的是三角函数的形式。</p>
<p>大概说一下什么是位置编码和为什么要使用三角函数。<br>要对位置进行编码，最简单的方式莫过于直接使用单词在文本中的位置，即1，2，3，…，N。但缺点过于明显，如果文本较长，那么位置编码的大小跨度就太大了，将这样的数据加入到模型训练中，很有可能是会喧宾夺主的抢占embedding的重要性。<br>同样，将刚才的顺序除以文本长度也是不行的，如1/N,2/N,3/N,…1。<br>我们需要位置信息，其中一个重要的信息就是相对位置信息，而这种处理方式，会导致相隔同样距离的两个词，在长度不同的文本中得到的相对位置信息不一致，甚至差距较大。<br>总结之后，那么真正适合用来做位置编码的函数似乎就是 连续且有界的周期性函数。有界保证值域不会太大，周期性保证一定程度上编码的差异会摆脱文本长度的影响，而连续则保证了两个比较靠近的词不会出现差距很大的情况。</p>
<p>于是文中使用了sin和cos函数，连续而且周期稳定，值域[-1,1]。</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/PosEncodingformula.png" class="" title="位置编码公式">

<p>加入了dmodel和i两个参数，dmodel是embedding的维度，在文中就是512，用于增大位置编码的空间表现范围。i为向量的某一维度，dmodel=512，那么i就是[0,255],这样在奇偶维度分别使用sin和cos。这样就从取值范围和取值方法两个方向上增加了取值的多样性。让位置编码更加科学。</p>
<p>当然，这个函数作者应该也是通过自身的经验与不断的实验得到的。</p>
<p>PS：GOOGLE BERT中用了新的取位置信息的方法，position embedding，这是后话。</p>
<h3 id="残差网络-Residual-network-的使用"><a href="#残差网络-Residual-network-的使用" class="headerlink" title="残差网络(Residual network)的使用"></a>残差网络(Residual network)的使用</h3><p>另一个细节，就是哪里跑不掉的resNet的使用：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/resInEncoder.png" class="" title="resNet的使用">

<p>同样，在decoder中也使用到了resNet，如果是一个2个encoder和decoder的transformer，它长这样：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/resInTransformer.png" class="" title="resNet的使用2">

<h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>介绍完Encoder，大多数Decoder里的组件的作用也明朗了。接下来看看他哥俩如何一起工作。</p>
<p>再贴一下模型结构图：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/structureOfTransformer.png" class="" title="transformer结构">
<p>可以看到Decoder中有一个 Encoder-Decoder Attention 层，它接受Encoder部分最后的输出作为计算attention的Key和Value，接受它下面的self-attention层的输出作为Query。</p>
<p>其次，Decoder部分的self-attention层也与Encoder中的不同，不同于Encoder中计算单词两两间的attention，Decoder中计算的是当前单词和它前面的单词的attention，同样，也要加入位置信息。</p>
<p>文章中有张非常形象的动图：</p>
<img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformerDecodingGif.gif" class="" title="transformer结构">

<p>注意在decoder中做self-attention的时候，当前输入只应该看到当前时刻以前的输出，比如在输出第二个词的时候，输入中是不应该出现第三个词的信息的。文中处理这种情况的方法是用了一个倒三角矩阵(第i行j列的元素表示第i个输入和第j个输入的attention)，将对角线右侧元素全部设置为负无穷，这样就防止了模型看到未来的信息。</p>
<h2 id="最后一层"><a href="#最后一层" class="headerlink" title="最后一层"></a>最后一层</h2><p>decoder将输出一堆floats组成的向量，将它转换成词语，就是最后一层的工作(通常是一个Linear+Softmax)。</p>
<p>Linear layer是一个简单的全连接层，将decoder的输出投射为一个比原来大很多的向量，叫做logits vector。</p>
<p>如果我们的词空间有10000个单词，那么10000就是这个logits vector的维度，向量中每个元素对应一个具体的词。接下来你就清楚了，softmax的作用是将这个logits vector的结果变成概率，概率最高的元素对应的词就是我们的输出。</p>
<h2 id="关于训练"><a href="#关于训练" class="headerlink" title="关于训练"></a>关于训练</h2><p>todo…</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>todo…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a><br><a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a><br><a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">哈佛大学的pytorch版本源码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Toulon Du</p>
  <div class="site-description" itemprop="description">Sharing Knowledge And Learn More</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Toulon Du</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
