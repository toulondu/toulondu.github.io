<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>袁老的宿舍</title>
    <link href="/2021/05/24/%E8%A2%81%E8%80%81%E7%9A%84%E5%AE%BF%E8%88%8D/"/>
    <url>/2021/05/24/%E8%A2%81%E8%80%81%E7%9A%84%E5%AE%BF%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<p>那是一个晴天，天空亮堂堂的，零星地飘着几朵懒散的云，不热。阳光透过运动场旁边并不高大的一排梧桐倾泻到我和陈静的头上。</p><p>2021年5月22日，袁隆平老先生逝世。一边伤感于这位伟大老人的离开，心底里又想起一些在西南大学的往事。</p><p>大二下学期，迫于学业的压力和贪玩快两年积累的内疚，我上自习的频率逐渐频繁起来。一开始我习惯跑去八教学楼，但不知是八教学楼的采光不好还是离寝室太近，经常有沉不下来的感觉，后来便跑远了一些，去了二十七教学楼。现在回想起来，大概还是每次去二十七教的路上会经过二十九教半月楼的缘故。半月楼得名于其如同弯月一般的形状，楼体直径很大，去往二十七教需要通过半月楼一楼的小平台。 小平台两面通风，又托庇于旁边教学楼的高大，冬暖夏凉，一直是众多同学排练节目的首选场所。彼时恰同学少年，每天自习途中有此靓丽景色，舍近求远，也是颇为值得。</p><p>我与陈静便是在二十七教的自习室中认识的，她比我大一级，那时她刚决定考研，天天很早就跑到教室最后排开始自习。而我也是一个上课和自习都喜欢跑后排去的人，有一次她没墨了管我借笔，便算是认识了。自习室关门一起离开时偶尔聊上几句，逐渐地就熟稔起来。一段时间之后，我逐渐有了发展这段关系的想法，于是跟她聊的话题也逐渐扩展开来。</p><p>西南大学很大，官方对这个大的定义是9500亩，由原来的农业大学和师范大学合并而来。原来的两个学校成了合并之后的南北两区。我是一个好动好看的人，北区能走的地方基本上都有我的足迹，因此也有不少属于我自己的“秘密空间”。跟陈静说起这些地方，她一般都兴致寥寥，独独对我说的老图书馆里一个放满老书的小房间非常感兴趣。于是那天我们就提前收了书本，去了老图书馆。</p><p>之所以叫老图书馆，不仅仅是因为当时西大刚建成了一座豪华高大的新图书馆。老图书馆真的很老，它只有六层，坐落在一座小山坡的顶上，从坡下往上看，你只能从被风撩开的叶间才能看到它的一角。楼体侧面的外墙除了几乎爬满的爬山虎，还有很多我叫不出来名字的植物，层层叠叠堆在一起。从图书馆的正门进去，左右是两个楼道，都通往楼上各层的自习室，图书馆的自习室更像是言几又的感觉，书架和座位交错地布置，书架上几乎都是专业书籍。每层的自习室大概占据楼层三分之二的面积。而入口的正面直走，则是一条长长的走廊，走廊两边放着用来检索书籍的装着windows2000系统的老式电脑。</p><p>穿过走廊，才来到剩下的这三分之一，藏书楼。如果要在整个西南大学让我选出我最喜欢的地方，那就是这里了。藏书楼的修建时间非常早，想来也没有做很宏伟的规划，所以面积很小，每层楼的空间都非常逼仄。先被一条不足一米宽的过道分成上下两个半区，再被中间仅能容一个人通过的楼道拆成一个田字。面积很小，但书很多，内容从小说诗歌散文到windows95的基本操作原理无一不包。书架与书架的间距只有大概0.5米，如果一个人站在书架前看书，另一个人需要用尽力气压缩自己才能通过。每两个书架间通道的尽头，是一个非常老式的铁窗，铁质的窗沿早已成了褐色。而我最喜欢做的一件事，就是挑上一本写满了笔记和感想的书籍，靠着窗户的墙壁坐下，然后一直看到闭馆的通知响起。</p><p>发现这个小房间的过程纯属意外，那天我在顶楼的角落找了一本大概是历史之类的书籍，然后准备像平常一样靠在墙边看，但我看到角落里墙边这次不是窗户，而是挂着一个长度拖到地的窗帘，我觉得奇怪，掀开一看，结果是一扇开着的门，开着灯，里面也正常放着三个书架。我第一反应是以为自己发现了类似武侠小说中藏经阁内放顶级秘籍的场所。然而我进去翻了翻，与外面书架上的书也没什么不同。</p><p>未完待续</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021前端面试题</title>
    <link href="/2021/03/15/2021%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/03/15/2021%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>金三银四招聘季，身边很多朋友也在各种面试。就着大家的反馈，总结一些前端在面试中遇到的问题。</p><h3 id="1-javascript的垃圾回收机制"><a href="#1-javascript的垃圾回收机制" class="headerlink" title="1.javascript的垃圾回收机制"></a>1.javascript的垃圾回收机制</h3><p>有2种，标记清除和引用计数。  </p><ol><li>标记清除：从根出发，遍历本地函数内局部变量、全局变量、调用链上的函数的变量和参数等给所有的引用进行标记，并级联标记子孙引用。最后，所有未被标记的变量等都将被清除。</li><li>引用计数: 很好理解，每个变量都会有一个计数，用于统计被引用次数。在注销或者删除一个引用时计数会减1，在绑定引用时则加1。每到一个垃圾回收周期会将所有引用计数为0的变量清除。</li></ol><h3 id="2-JavaScript的事件循环"><a href="#2-JavaScript的事件循环" class="headerlink" title="2.JavaScript的事件循环"></a>2.JavaScript的事件循环</h3><p>js的异步任务有两种：</p><ul><li>宏任务：setTimeout, setInterval, I/O 等。</li><li>微任务：Promise，process.nextTick(node独有)</li></ul><p>其它为同步任务，同步任务会立即执行。 PS：new Promise((resolve,reject)=&gt;{console.log(‘hello’)})为同步任务。</p><p>执行顺序：<br>1)执行完所有的同步任务后，此时执行栈为空。<br>2)执行所有微任务栈中的任务，执行期间新的微任务也会在此过程中执行<br>3)从宏任务中去一个任务到执行栈<br>4)回到第1)步  </p><h3 id="3-import和require有哪些区别"><a href="#3-import和require有哪些区别" class="headerlink" title="3.import和require有哪些区别"></a>3.import和require有哪些区别</h3><p>老问题，不展开写了。<br>require野生，import标准<br>require可以动态，import静态<br>import有default，require没有<br>兼容性不同<br>require有很多实践，比如amd/cmd/umd</p><h3 id="4-webpack的loader和plugin有什么区别"><a href="#4-webpack的loader和plugin有什么区别" class="headerlink" title="4.webpack的loader和plugin有什么区别"></a>4.webpack的loader和plugin有什么区别</h3><p>loader即为文件加载器，操作的是文件，将文件A通过loader转换成文件B，是一个单纯的文件转化过程。<br>plugin即为插件，是一个扩展器，丰富webpack本身，增强功能 ，针对的是在loader结束之后，webpack打包的整个过程，他并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。</p><h3 id="5-怎么写一个webpack-plugin"><a href="#5-怎么写一个webpack-plugin" class="headerlink" title="5.怎么写一个webpack plugin"></a>5.怎么写一个webpack plugin</h3><p>官网：<a href="https://webpack.js.org/contribute/writing-a-plugin/" target="_blank" rel="noopener">https://webpack.js.org/contribute/writing-a-plugin/</a><br>文章：<a href="https://segmentfault.com/a/1190000019010101" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019010101</a></p><p>几代webpack，plugin的写法基本没有变化，主要就是通过webpack提供的hook，在合适的时刻做一些自定义的事情。</p><ol><li>编写一个JavaScript命名函数。</li><li>在它的原型上定义一个apply方法。</li><li>指定挂载的webpack事件钩子。</li><li>处理webpack内部实例的特定数据。</li><li>功能完成后调用webpack提供的回调。</li></ol><p>编写插件之前要理解compiler和compilation两个对象。<br>webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable。<br>compiler负责编译, compilation负责创建bundles，二者都是Tapable的实例。</p><p>Tapable暴露出挂载plugin的方法，使我们能 将plugin控制在webapack事件流上运行。</p><img src="/2021/03/15/2021%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/webpack-flow.png" srcset="/img/loading.gif" class="" title="webpack流"><p>apply属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。通过Function.prototype.apply方法，你可以把任意函数作为插件传递(this 将指向compiler)。我们可以在配置中使用这样的方式来内联自定义插件。</p><pre><code class="hljs plain">&#x2F;&#x2F; tapable库暴露了很多Hook（钩子）类，为插件提供挂载的钩子。const &#123;    SyncHook,    SyncBailHook,    SyncWaterfallHook,    SyncLoopHook,    AsyncParallelHook,    AsyncParallelBailHook,    AsyncSeriesHook,    AsyncSeriesBailHook,    AsyncSeriesWaterfallHook &#125; &#x3D; require(&quot;tapable&quot;);&#x2F;&#x2F; 实例化一个钩子const hook1 &#x3D; new SyncHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);&#x2F;&#x2F; 绑定事件到webapck事件流 apAsync&#x2F;tapPromise&#x2F;taphook1.tap(&#39;hook1&#39;, (arg1, arg2, arg3) &#x3D;&gt; console.log(arg1, arg2, arg3)) &#x2F;&#x2F;1,2,3&#x2F;&#x2F; 执行绑定的事件 callAsync&#x2F;promisehook1.call(1,2,3)</code></pre><h3 id="6-babel插件怎么编写"><a href="#6-babel插件怎么编写" class="headerlink" title="6.babel插件怎么编写"></a>6.babel插件怎么编写</h3><p>babel的本质是操作AST(abstract syntax tree)来完成代码的转译。<br>所以说babel其实是一个编译器。而编译器的工作过程无非3个部分：</p><img src="/2021/03/15/2021%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/babel-flow.png" srcset="/img/loading.gif" class="" title="webpack流"><ul><li>parse:把源代码转换成抽象的表示，比如AST</li><li>transform：根据编译器的功能对AST做一些特殊处理</li><li>generate：将第二步经过transform的AST生成新的代码。</li></ul><p>所以，写babel插件，就是在这些过程中，主要是transform过程中做一些自定义的操作，即操作AST。</p><p>AST由一个又一个的节点构成，操作AST就是操作这些节点，我们可以对这些节点进行增删改等操作。<br>一个常见的identifier节点：</p><pre><code class="hljs plain">&#123;  type:&#39;Identifier&#39;,  name:&#39;btn&#39;&#125;</code></pre><p>更多的节点规范见： https//github.com/estree/estree</p><p>AST是一棵树，对节点进行操作，自然需要遍历。不过这里我们不需要自己写遍历。只需要通过Babel提供的Visitor对象来进行操作即可。Visitor上挂载所有以type命名的方法，Babel会遍历AST，节点会根据自己的type进入不同的方法执行。比如箭头函数的type为ArrowFunction。那么Babel解析的代码可能是：</p><pre><code class="hljs plain">const visitor &#x3D; &#123;ArrowFunction(path)&#123;path.replaceWith(t.FunctionDeclaration(id.params,body))&#125;&#125;</code></pre><p>所以，将源代码和目标代码都解析成AST，观察它们，找找看如何增删改AST可以达到目的。<br>可以在<a href="https://astexplorer.net" target="_blank" rel="noopener">这里</a>完成此工作。</p><h3 id="7-浏览器渲染过程"><a href="#7-浏览器渲染过程" class="headerlink" title="7.浏览器渲染过程"></a>7.浏览器渲染过程</h3><p>浏览器拿到HTML之后的渲染过程：（不同内核实现不一样，但大体差不多）</p><ol><li>解析HTML，构建DOM tree。</li><li>解析CSS，构建CSSOM tree。</li><li>合并DOM tree和CSSOM tree，生成render tree。</li><li>布局（layout/reflow），计算各元素尺寸、位置。</li><li>绘制（paint/repaint），绘制页面像素信息。</li><li>浏览器将各层的信息发送给GPU，GPU将各层合成，显示在屏幕上。</li></ol><p>当修改了DOM或CSSOM，上述过程中的一些步骤就会重复执行。</p><p><strong>构建OM</strong>：要经过Bytes → characters → tokens → nodes → object model这个过程。</p><img src="/2021/03/15/2021%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/om-builder.png" srcset="/img/loading.gif" class="" title="webpack流"><p>TIPS：<br>解析HTML遇到外部CSS立即请求 —-CSS文件合并，减少HTTP请求；</p><p>新的CSS style修改CSSOM，会重新渲染页面 —-CSS文件应放在头部，缩短首次渲染时间</p><p>遇到<code>&lt;img&gt;</code>会发出请求，但不会阻塞，服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；（最好图片都设置尺寸，避免重新渲染）</p><p>遇到<code>&lt;script&gt;</code> 标签，会立即执行js代码，阻塞渲染。（script最好放置页面最下面）</p><p>js修改DOM会重新渲染。 （页面初始化样式不要使用js控制） </p><h3 id="8-回流reflow和重绘repaint"><a href="#8-回流reflow和重绘repaint" class="headerlink" title="8.回流reflow和重绘repaint"></a>8.回流reflow和重绘repaint</h3><p><strong>回流reflow</strong><br>当某个部分发生了变化影响了布局，需要倒回去重新渲染， 该过程称为reflow（回流）。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。</p><p>改变窗囗大小，改变文字大小，添加/删除样式表，内容的改变，如用户在输入框中敲字，激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活)，操作class属性，脚本操作DOM，计算offsetWidth和offsetHeight，设置style属性都会导致回流发生。</p><p><strong>repaint重绘</strong><br>如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow（在IE下需要换一下说法，reflow 要比 repaint 更缓慢）。</p><p>reflow一定引起repaint，而repaint不一定要reflow。reflow的成本比repaint高很多，DOM tree里每个结点的reflow很可能触发其子结点、祖先结点、兄弟结点的reflow。reflow(回流)是导致DOM脚本执行低效的关键因素之一。</p><p> 现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。<br>优化，尽量避免reflow：</p><p>优化回流：</p><ul><li><p>尽可能限制reflow的影响范围，修改DOM层级较低的结点。不要通过父级元素影响子元素样式。最好直接加在子元素上。改变子元素样式尽可能不要影响父元素和兄弟元素的尺寸。</p></li><li><p>不要一条一条的修改DOM的style，最好通过设置class的方式。 避免触发多次reflow和repaint。</p></li><li><p>经常reflow的元素，比如动画，position设为fixed或absolute，使其脱离文档流，不影响其它元素的布局。</p></li><li><p>权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。</p></li><li><p>不要用tables布局。tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p></li><li><p>避免使用css expression（每次都会重新计算）。</p></li><li><p>减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</p></li><li><p>避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</p></li><li><p>尽量不要频繁的增加、修改、删除元素，可以先把DOM节点抽离到内存中进行复杂的操作然后再display到页面上。（display:none的节点不会被加入render tree，而visibility:hidden会；display:none会触发reflow，而visibility:hidden只会触发repaint，因为layout没有变化）。</p></li><li><p>让要进行复杂操作的元素进行“离线处理”，处理完后一起更新。比如使用DocumentFragment，DocumentFragment节点不属于文档树，继承的parentNode属性总是null。即将元素添加到DocumentFragment中，再将DocumentFragment添加到页面</p></li><li><p>使用display:none，先隐藏后显示，只会引起两次reflow和repaint。因display:none的元素不在render tree，对其操作不会引起其他元素的reflow和repaint。</p></li><li><p>使用cloneNode和replaceChild，引发一次reflow和repaint。</p></li></ul><h3 id="9-设计和实现一个-LRU-最近最少使用-缓存机制。它应该支持以下操作：-获取数据-get-和-写入数据-put-。"><a href="#9-设计和实现一个-LRU-最近最少使用-缓存机制。它应该支持以下操作：-获取数据-get-和-写入数据-put-。" class="headerlink" title="9.设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。"></a>9.设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</h3><p>这个题主要利用js的Map对象在迭代时会根据对象中元素的插入顺序来进行的特点。因此不需要我们自己记录每个key插入和被使用的时间。</p><pre><code class="hljs plain">&#x2F;&#x2F; 新添加的元素会被插入到map的末尾，整个栈倒序查看class LRUCache &#123;  constructor(capacity) &#123;    this.secretKey &#x3D; new Map();    this.capacity &#x3D; capacity;  &#125;  get(key) &#123;    if (this.secretKey.has(key)) &#123;      let tempValue &#x3D; this.secretKey.get(key);      this.secretKey.delete(key);      this.secretKey.set(key, tempValue);      return tempValue;    &#125;    else return -1;  &#125;  put(key, value) &#123;    &#x2F;&#x2F; key存在，仅修改值    if (this.secretKey.has(key)) &#123;      this.secretKey.delete(key);      this.secretKey.set(key, value);    &#125;    &#x2F;&#x2F; key不存在，cache未满    else if(this.secretKey.size&lt;this.capacity)&#123;      this.secretKey.set(key, value);    &#125;    &#x2F;&#x2F; 添加新key，删除旧key    else&#123;      this.secretKey.set(key,value);      &#x2F;&#x2F; 删除map的第一个元素，即为最长未使用的      this.secretKey.delete(this.secretKey.keys().next().value);    &#125;  &#125;&#125;</code></pre><h3 id="10-防抖和节流函数"><a href="#10-防抖和节流函数" class="headerlink" title="10.防抖和节流函数"></a>10.防抖和节流函数</h3><pre><code class="hljs plain">&#x2F;&#x2F;防抖function deVabrint(func, interval &#x3D; 100) &#123;  let timer;  return function () &#123;    clearTimeout(timer);    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;      func.apply(this, arguments);    &#125;, interval);  &#125;;&#125;&#x2F;&#x2F;节流function bottoleFunc(func, interval) &#123;  let start &#x3D; new Date() - 0;  return function () &#123;    let now &#x3D; new Date() - 0;    if (now - start &gt; interval) &#123;      func.apply(this, arguments);      start &#x3D; new Date() - 0;    &#125;  &#125;;&#125;</code></pre><h3 id="11-grpc的优缺点"><a href="#11-grpc的优缺点" class="headerlink" title="11.grpc的优缺点"></a>11.grpc的优缺点</h3><p>RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。如下图所示就是一个典型的RPC结构图。</p><p><strong>gRPC vs. Restful API</strong><br>gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：</p><ul><li>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。</li><li>另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</li><li>gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）</li></ul><p><strong>使用场景</strong>  </p><ul><li>需要对接口进行严格约束的情况</li><li>对于性能有更高的要求时。</li></ul><p>但是，通常我们不会去单独使用gRPC，而是将gRPC作为一个部件进行使用，这是因为在生产环境，我们面对大并发的情况下，需要使用分布式系统来去处理，而gRPC并没有提供分布式系统相关的一些必要组件。而且，真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等等必要的组件。</p><h3 id="12-http2-0的相关特性"><a href="#12-http2-0的相关特性" class="headerlink" title="12.http2.0的相关特性"></a>12.http2.0的相关特性</h3><p>HTTP/2 的首要目标是通过完全的请求,响应多路复用,头部的压缩头部域来减小头部的体积,添加了请求优先级,服务端推送.<br>为了支持这些特性,他需要大量的协议增加头部字段来支持,例如新的流量控制,差错处理,升级机制.而这些是每个web开发者都应该在他们的应用中用到的.</p><p><a href="https://www.cnblogs.com/yixiaogo/p/11932966.html" target="_blank" rel="noopener">https://www.cnblogs.com/yixiaogo/p/11932966.html</a></p><ul><li><p>二进制帧层：它指HTTP消息在客户端和服务端如何封装和传输.</p></li><li><p>流,消息，帧<br>流：已经建立的连接之间双向流动的字节，它能携带一个至多个消息。<br>消息：一个完整的帧序列，它映射到逻辑的请求和响应消息。<br>帧：在HTTP/2通信的最小单元。每个桢包括一个帧头，里面有个很小标志，来区别是属于哪个流。  </p></li><li><p>请求和响应的多路复用：在HTTP/2中,新的二进制帧层,解除了这个限制.使得所有的请求和响应多路复用.通过允许客户端和服务端把HTTP消息分解成独立的帧,交错传输,然后在另一端组装.</p></li><li><p>流的优先级：为了能方便流的传输顺序,HTTP/2.0提出,使每个流都有一个权重(1-256)和依赖.</p></li><li><p>每个源一个连接</p></li><li><p>流量控制</p></li><li><p>服务端推送：服务器为单个客户端请求发送多个响应的能力。也就是说，除了对原始请求的响应之外，服务器还可以向客户端推送额外的资源（图12-5），而不需要客户端明确请求每一个资源！</p></li><li><p>头部压缩</p></li></ul><h3 id="13-viewport-和移动端布局方案"><a href="#13-viewport-和移动端布局方案" class="headerlink" title="13.viewport 和移动端布局方案"></a>13.viewport 和移动端布局方案</h3><p>TODO</p><h3 id="14-vue的依赖收集原理"><a href="#14-vue的依赖收集原理" class="headerlink" title="14.vue的依赖收集原理"></a>14.vue的依赖收集原理</h3><p>早期使用Object.defineProperty实现，后改造成Proxy，但原理相同。<br>主要基于Dep.target，Dep和dep.addSub<br>首先会遍历整个state数据结构，给每个数据都加上一个get监控和set监控，在某个数据被get的时候就会进行依赖收集。</p><pre><code class="hljs plain">function defineReactive(obj, key) &#123;        var dep &#x3D; new Dep();        var val  &#x3D; obj[key]        Object.defineProperty(obj, key, &#123;        get() &#123;                        if (Dep.target) &#123;                                &#x2F;&#x2F; 收集依赖                dep.addSub(Dep.target)            &#125;                        return val        &#125;    &#125;);&#125;</code></pre><p>Dep.target会永远指向当前正被解析的watcher，watch的watcher，页面的watcher等等。简单想，指向哪个watcher，那么就是那个 watcher 正在使用数据，数据就要收集这个watcher。</p><p>Dep 是一个构造函数，用于创建实例，并带有很多方法</p><p>于是，收集流程大概是这样<br>1、页面的渲染函数执行， name 被读取<br>2、触发 name的 Object.defineProperty.get 方法<br>3、于是，页面的 watcher 就会被收集到 name 专属的闭包dep 的 subs 中</p><p>PS:<br>基础数据类型，只使用 【闭包dep】 来存储依赖<br>引用数据类型，使用 【闭包dep】 和 【 <strong>ob</strong>.dep】 两种来存储依赖</p><h3 id="15-怎么给一个购物车做架构设计"><a href="#15-怎么给一个购物车做架构设计" class="headerlink" title="15.怎么给一个购物车做架构设计"></a>15.怎么给一个购物车做架构设计</h3><p><a href="https://www.v2ex.com/t/669861" target="_blank" rel="noopener">https://www.v2ex.com/t/669861</a></p><h3 id="16-手写一个Promise"><a href="#16-手写一个Promise" class="headerlink" title="16.手写一个Promise"></a>16.手写一个Promise</h3><p>两个版本</p><p>简单版：</p><pre><code class="hljs plain">function myPromise(constructor)&#123;    let self&#x3D;this;    self.status&#x3D;&quot;pending&quot; &#x2F;&#x2F;定义状态改变前的初始状态    self.value&#x3D;undefined;&#x2F;&#x2F;定义状态为resolved的时候的状态    self.reason&#x3D;undefined;&#x2F;&#x2F;定义状态为rejected的时候的状态    function resolve(value)&#123;        &#x2F;&#x2F;两个&#x3D;&#x3D;&#x3D;&quot;pending&quot;，保证了状态的改变是不可逆的       if(self.status&#x3D;&#x3D;&#x3D;&quot;pending&quot;)&#123;          self.value&#x3D;value;          self.status&#x3D;&quot;resolved&quot;;       &#125;    &#125;    function reject(reason)&#123;        &#x2F;&#x2F;两个&#x3D;&#x3D;&#x3D;&quot;pending&quot;，保证了状态的改变是不可逆的       if(self.status&#x3D;&#x3D;&#x3D;&quot;pending&quot;)&#123;          self.reason&#x3D;reason;          self.status&#x3D;&quot;rejected&quot;;       &#125;    &#125;    &#x2F;&#x2F;捕获构造异常    try&#123;       constructor(resolve,reject);    &#125;catch(e)&#123;       reject(e);    &#125;&#125;myPromise.prototype.then&#x3D;function(onFullfilled,onRejected)&#123;   let self&#x3D;this;   switch(self.status)&#123;      case &quot;resolved&quot;:        onFullfilled(self.value);        break;      case &quot;rejected&quot;:        onRejected(self.reason);        break;      default:          &#125;&#125;</code></pre><p>进阶版：</p><pre><code class="hljs plain">const PENDING &#x3D; &quot;pending&quot;;const FULFILLED &#x3D; &quot;fulfilled&quot;;const REJECTED &#x3D; &quot;rejected&quot;; function Promise(excutor) &#123;    let that &#x3D; this; &#x2F;&#x2F; 缓存当前promise实例对象    that.status &#x3D; PENDING; &#x2F;&#x2F; 初始状态    that.value &#x3D; undefined; &#x2F;&#x2F; fulfilled状态时 返回的信息    that.reason &#x3D; undefined; &#x2F;&#x2F; rejected状态时 拒绝的原因    that.onFulfilledCallbacks &#x3D; []; &#x2F;&#x2F; 存储fulfilled状态对应的onFulfilled函数    that.onRejectedCallbacks &#x3D; []; &#x2F;&#x2F; 存储rejected状态对应的onRejected函数     function resolve(value) &#123; &#x2F;&#x2F; value成功态时接收的终值        if(value instanceof Promise) &#123;            return value.then(resolve, reject);        &#125;        &#x2F;&#x2F; 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。        setTimeout(() &#x3D;&gt; &#123;            &#x2F;&#x2F; 调用resolve 回调对应onFulfilled函数            if (that.status &#x3D;&#x3D;&#x3D; PENDING) &#123;                &#x2F;&#x2F; 只能由pending状态 &#x3D;&gt; fulfilled状态 (避免调用多次resolve reject)                that.status &#x3D; FULFILLED;                that.value &#x3D; value;                that.onFulfilledCallbacks.forEach(cb &#x3D;&gt; cb(that.value));            &#125;        &#125;);    &#125;    function reject(reason) &#123; &#x2F;&#x2F; reason失败态时接收的拒因        setTimeout(() &#x3D;&gt; &#123;            &#x2F;&#x2F; 调用reject 回调对应onRejected函数            if (that.status &#x3D;&#x3D;&#x3D; PENDING) &#123;                &#x2F;&#x2F; 只能由pending状态 &#x3D;&gt; rejected状态 (避免调用多次resolve reject)                that.status &#x3D; REJECTED;                that.reason &#x3D; reason;                that.onRejectedCallbacks.forEach(cb &#x3D;&gt; cb(that.reason));            &#125;        &#125;);    &#125;     &#x2F;&#x2F; 捕获在excutor执行器中抛出的异常    &#x2F;&#x2F; new Promise((resolve, reject) &#x3D;&gt; &#123;    &#x2F;&#x2F;     throw new Error(&#39;error in excutor&#39;)    &#x2F;&#x2F; &#125;)    try &#123;        excutor(resolve, reject);    &#125; catch (e) &#123;        reject(e);    &#125;&#125; Promise.prototype.then &#x3D; function(onFulfilled, onRejected) &#123;    const that &#x3D; this;    let newPromise;    &#x2F;&#x2F; 处理参数默认值 保证参数后续能够继续执行    onFulfilled &#x3D;        typeof onFulfilled &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onFulfilled : value &#x3D;&gt; value;    onRejected &#x3D;        typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onRejected : reason &#x3D;&gt; &#123;            throw reason;        &#125;;    if (that.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123; &#x2F;&#x2F; 成功态        return newPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;            setTimeout(() &#x3D;&gt; &#123;                try&#123;                    let x &#x3D; onFulfilled(that.value);                    resolvePromise(newPromise, x, resolve, reject); &#x2F;&#x2F; 新的promise resolve 上一个onFulfilled的返回值                &#125; catch(e) &#123;                    reject(e); &#x2F;&#x2F; 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);                &#125;            &#125;);        &#125;)    &#125;     if (that.status &#x3D;&#x3D;&#x3D; REJECTED) &#123; &#x2F;&#x2F; 失败态        return newPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;            setTimeout(() &#x3D;&gt; &#123;                try &#123;                    let x &#x3D; onRejected(that.reason);                    resolvePromise(newPromise, x, resolve, reject);                &#125; catch(e) &#123;                    reject(e);                &#125;            &#125;);        &#125;);    &#125;     if (that.status &#x3D;&#x3D;&#x3D; PENDING) &#123; &#x2F;&#x2F; 等待态        &#x2F;&#x2F; 当异步调用resolve&#x2F;rejected时 将onFulfilled&#x2F;onRejected收集暂存到集合中        return newPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;            that.onFulfilledCallbacks.push((value) &#x3D;&gt; &#123;                try &#123;                    let x &#x3D; onFulfilled(value);                    resolvePromise(newPromise, x, resolve, reject);                &#125; catch(e) &#123;                    reject(e);                &#125;            &#125;);            that.onRejectedCallbacks.push((reason) &#x3D;&gt; &#123;                try &#123;                    let x &#x3D; onRejected(reason);                    resolvePromise(newPromise, x, resolve, reject);                &#125; catch(e) &#123;                    reject(e);                &#125;            &#125;);        &#125;);    &#125;&#125;;</code></pre><h3 id="JavaScript的new-做了什么"><a href="#JavaScript的new-做了什么" class="headerlink" title="JavaScript的new 做了什么"></a>JavaScript的new 做了什么</h3><p>比如 <code>const p = new Persion(&#39;xxx&#39;)</code><br>1.添加一个{}对象，将函数的this指向这个对象。然后将对象返回。<br>2.将Person函数prototype原型也指向这个对象的<strong>proto</strong>。 即 <code>p.__proto = Person.prototype</code>。</p><h3 id="react-内部如何识别-class-组件和-function-组件"><a href="#react-内部如何识别-class-组件和-function-组件" class="headerlink" title="react 内部如何识别 class 组件和 function 组件"></a>react 内部如何识别 class 组件和 function 组件</h3><p>直接区分是不是class是不行的，因为在被babel等工具转译之后二者都是function。</p><p>好像可以使用原型机制。 如果所有的class都继承自React.Component，通过 <code>XXX.prototype instanceof React.Component</code>可以达到效果。</p><p>但有时候我们检查的组件可能是继承至别的React组件的React.Component副本。这个时候instanceof就抓瞎了。</p><p>所以，react在React.Component的prototype上加了一个属性：<code>isReactComponent</code>:  </p><pre><code class="hljs plain">class Component &#123;&#125;Component.prototype.isReactComponent &#x3D; &#123;&#125;;&#x2F;&#x2F; We can check it like thisclass Greeting extends Component &#123;&#125;console.log(Greeting.prototype.isReactComponent); &#x2F;&#x2F; ✅ Yes</code></pre><h3 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h3><ol><li>当我们在组件上设置事件处理器时，React并不会在改DOM元素上直接绑定事件处理器，而是在react内部自定义一套事件系统，在这个系统上进行统一的事件订阅和分发</li><li>react利用事件委托机制在Document上统一监听DOM事件，在根据触发的target将事件分发到具体的组件实例，实际我们在事件里面拿到的event其实并不是原始的DOM事件对象，而是一个合成事件对象</li></ol><p><strong>为什么需要</strong><br>1 .抹平浏览器之间的兼容性差异，react还会通过其他事件来模拟一些低版本不兼容的事件<br>2 .事件合成，自定义高级事件，比如onChange事件，为表单元素定义了统一的值来变动事件<br>3 .React打算更多优化。比如利用事件委托，大部分事件最总绑定了Document，而不是dom节点本身，这样简化了dom事件处理逻辑，减少了内存的开销。react自己实现了一套模拟事件冒泡的机制<br>4 .react干预了事件的分发。Fiber架构，优化了用户的交互体验，干预事件的分发，不同的事件有不同的优先级。高的优先级事件可以中断渲染，让用户代码即使响应用户交互</p><p><a href="https://www.jianshu.com/p/440f0fd43c8f" target="_blank" rel="noopener">https://www.jianshu.com/p/440f0fd43c8f</a></p><h3 id="css扇形-一个元素"><a href="#css扇形-一个元素" class="headerlink" title="css扇形(一个元素)"></a>css扇形(一个元素)</h3><pre><code class="hljs plain">.fan&#123;  border-radius:50%;  border:100px solid transparent;  width:0;  border-top-color: red;&#125;</code></pre><h3 id="Sleep-函数-手写"><a href="#Sleep-函数-手写" class="headerlink" title="Sleep 函数(手写)"></a>Sleep 函数(手写)</h3><ol><li>用while循环，强阻断</li><li>setTimeout 回调</li><li>Promise + setTimeout + async/await</li></ol><h3 id="es5-实现-es6-extend"><a href="#es5-实现-es6-extend" class="headerlink" title="es5 实现 es6 extend"></a>es5 实现 es6 extend</h3><p>TODO</p><h3 id="二叉树所有根到叶子路径组成的数字之和"><a href="#二叉树所有根到叶子路径组成的数字之和" class="headerlink" title="二叉树所有根到叶子路径组成的数字之和"></a>二叉树所有根到叶子路径组成的数字之和</h3><p>略。</p><h3 id="Form-JSON-schema"><a href="#Form-JSON-schema" class="headerlink" title="Form JSON schema"></a>Form JSON schema</h3><p>TODO</p><h3 id="怎么实现动画，js动画的缺陷"><a href="#怎么实现动画，js动画的缺陷" class="headerlink" title="怎么实现动画，js动画的缺陷"></a>怎么实现动画，js动画的缺陷</h3><p>TODO</p><p>未完待续…</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的git命令介绍和简单的git工作流</title>
    <link href="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <url>/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的-git-命令介绍"><a href="#常用的-git-命令介绍" class="headerlink" title="常用的 git 命令介绍"></a>常用的 git 命令介绍</h1><p>Git 是一款非常强大的工具，但如果你并不了解每个命令敲下去之后分支会如何交互，交互之后又会怎样影响历史记录，那 git 使用起来可能也没那么让你的同事舒服。</p><p>比如当你发现 push 有问题而在不知道问题原因时强行执行了 git push，或者习惯来使用 pull+merge 来合并代码，你的同事也许会在心里默默地画了一个圈圈。</p><p>所以在讲解我们的 git 工作流前，我们先来学习一下基本的 git 命令，明白这些命令背后的逻辑。</p><h2 id="1-merge"><a href="#1-merge" class="headerlink" title="1.merge"></a>1.merge</h2><p>我们都知道 git 代码管理是基于多分支，你可以通过分支很方便地将不同的代码修改隔离开，并且很好地和同事完成分工且不会互相影响。并且即使你提交了错误的代码，也能够保证不影响生产环境。</p><p>而<code>git merge</code>则是可以把一个分支的代码与另一个分支进行合并的命令，合并的方式有 2 种，<code>fast-forward</code> 和 <code>no-fast-forward</code>。</p><h3 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h3><p><code>fast-forward</code> 很简单，当你的分支跟你想合并的分支想比没有额外的提交时，merge 就会使用 <code>fast-forward</code> 合并，这也是 git 首先尝试的合并方式。合并时不会创建任何额外的提交，而是将我们正在合并的分支上的 commit 直接合并到当前分支。</p><p>比如我从 dev 分支 checkout 了一个新分支 feat/nothing，然后修改了一些东西并提交。</p><p>此时我 dev 分支相对于之前没有任何变化，此时在 dev 分支上执行<code>git merge feat/nothing</code>，执行的就是 fast-forward 合并。简单修改了 dev 分支 HEAD 的指针指向就达到了合并的效果：</p><p>合并前:</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/before_git_merge.png" srcset="/img/loading.gif" class="" title="fast-forward-merge"><p>合并后：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/after_git_merge.png" srcset="/img/loading.gif" class="" title="fast-forward-merge"><h3 id="No-fast-forward-—no-ff"><a href="#No-fast-forward-—no-ff" class="headerlink" title="No-fast-forward (—no-ff)"></a>No-fast-forward (—no-ff)</h3><p>但实际情况肯定没有这么美好，很多时候我们在新分支上修改代码后，原分支也会有一些新的提交。此时我们要在原分支合并我们的新分支，就需要执行<code>no-fast-forward</code>合并。</p><p><code>no-fast-forward</code>的合并，git 会创建一个新的 commit，这个新的 commit 的上一次提交会同时指向合并的 2 个分支。</p><p>举个例子，我在<code>dev</code>上 checkout 一个新分支<code>feat/no-fast-forward</code>，然后在<code>feat/no-fast-forward</code>上新建了 c.js 文件并提交，同时在 dev 上新建了 d.js 文件并提交。此时我们的分支情况如下：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/before_no_fast_merge.png" srcset="/img/loading.gif" class="" title="no-fast-forward-merge"><p>当我们在 dev 分支上执行<code>git merge feat/no-fast-forward</code>之后，我们看看发生了什么：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/after_no_fast_merge.png" srcset="/img/loading.gif" class="" title="no-fast-forward-merge后"><p>很清晰的可以看到，正如我们上面所说，git 创建了一个新的 commit，同时指向了 2 个合并的分支提交。</p><h2 id="2-rebase"><a href="#2-rebase" class="headerlink" title="2.rebase"></a>2.rebase</h2><p>除了 <code>git merge</code> 以外，还有一种可以合并分支代码的方式，叫做变基，即 <code>git rebase</code>。 这也是我们推荐使用的命令，因为它比 merge 强大得多！</p><p><code>git rebase</code> 会把当前分支的提交复制到指定的分支之后。  我将这句话进行了加粗，希望你多看两遍。这也是 rebase 和 merge 最大的区别，执行 rebase 时，git 不会纠结要保留或者要删除哪些修改，执行 rebase 命令的分支总是含有我们最新的修改。这样我们可以保留一个漂亮的、线性的 git 历史。</p><p>看一个例子：</p><p>我在 <code>dev</code> 上 checkout 了一个新分支 <code>feat/rebase-feat</code>，然后分别在 <code>dev</code> 和 <code>feat/rebase-feat</code> 上进行了一次提交。然后我们的分支变成了这样：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/before_git_rebase.png" srcset="/img/loading.gif" class="" title="rebase前"><p>此时我们在 <code>feat/rebase-feat</code> 上执行 <code>git rebase dev</code> 命令，至于为什么我们要在 feat 分支上执行 rebase 而不是 dev 上执行，接下来会说到。</p><p>执行之后分支变成了这样：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/after_git_rebase.png" srcset="/img/loading.gif" class="" title="rebase后"><p>再回头来看变基这个名字，即“重新设置基线”。 重新设置的是你的当前分支的开始点，而这个开始点则是基于你 rebase 的目标分支(称作跟踪分支)。</p><p>执行 git rebase 命令后，git 会把你当前分支的开始时间轴移动到跟踪分支的最新提交之后。这样，你的当前分支也就成为了最新的跟踪分支。</p><p>而这一系列的操作都是基于文件事务进行处理的，这个事务类似于数据库的事务，所以你不用担心事务失败等异常情况影响文件的一致性。你可以在 rebase 的过程中随时回退和取消 rebase 事务。</p><p>看懂了上面这段，你也就明白了我们为什么不在公共分支 dev 上执行 rebase 了。如果你不明白，我提示一下，新的 commit 会向后放，那么其它从公共分支拉分支的用户，都需要再 rebase，这显然不科学。而且在公共分支上 rebase 还会修改公共分支的提交历史，这也很不 ok。</p><p>综上，当你在 feat 分支上开发完成之后，想要把主分支 master 的修改合到你的分支上，这种情况使用 rebase 就要优于 merge，把你的提交放在主分支的提交之后，且不会创建新的提交。历史更加清晰。</p><p>除了合并代码之外，git rebase 还有很多功能，它可以让我们自由控制我们的提交。</p><ul><li>reword：修改提交信息；</li><li>edit：修改此提交；</li><li>squash：将提交融合到前一个提交中；</li><li>fixup：将提交融合到前一个提交中，不保留该提交的日志消息；</li><li>exec：在每个提交上运行我们想要 rebase 的命令；</li><li>drop：移除该提交。</li></ul><h3 id="squash"><a href="#squash" class="headerlink" title="squash"></a>squash</h3><p>我们来尝试一下 squash，其它的举一反三即可。</p><p>我们很多人在自己的分支上开发时，因为各种原因，commit 也许会很频繁。比如：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/many_commits.png" srcset="/img/loading.gif" class="" title="many_commits"><p>很显然，这很糟糕，如果让你的同事或者上级看到这些令人尴尬的提交记录，想必是你的一次社会性死亡。</p><p>这个时候 squash 就可以派上用场了,它可以帮助我们将多个提交合并成一个。</p><p>(1) 首先执行 <code>git log</code> 查看提交记录：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/git_logs.png" srcset="/img/loading.gif" class="" title="git_logs"><p>此时我们的目的是将最近的这三个提交进行合并，那么我们就复制它们之前的那一次提交记录的 commit sha，即 69d79e992e480999a5e89957bcf8e01b3e9e6933。</p><p>(2) 执行 <code>git rebase -i 69d79e992e480999a5e89957bcf8e01b3e9e6933</code></p><p>也可以执行 <code>git rebase -i HEAD~3</code>，跟上诉命令效果一样。执行后我们会看到如下的 vim 编辑界面，让我们对这几次提交作处理：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/squash_step_1.png" srcset="/img/loading.gif" class="" title="squash_step_1"><p>将你要 squash 的提交标识为 squash(至少保留一个 pick)。</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/squash_step_2.png" srcset="/img/loading.gif" class="" title="squash_step_2"><p>接着保存并退出,我们会进入下一个 vim 编辑界面，这里让我们处理这三次提交的提交信息：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/squash_step_3.png" srcset="/img/loading.gif" class="" title="squash_step_3"><p>这里你可以任意修改，比如只保留:</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/squash_step_4.png" srcset="/img/loading.gif" class="" title="squash_step_4"><p>接着保存退出，我们就完成了 rebase，重新查看历史：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/squash_step_5.png" srcset="/img/loading.gif" class="" title="squash_step_5"><p>很好！只剩下一次提交了！</p><p>PS:至于 fixup,drop,edit 等功能，尝试在第一次 vim 时将对应提交的 pick 修改为这些关键字，建议你自己去试一试。</p><h2 id="3-代码冲突"><a href="#3-代码冲突" class="headerlink" title="3.代码冲突"></a>3.代码冲突</h2><p>当你在做 merge 或者 rebase 时，都难免会出现代码冲突。</p><p>git 会向你展示冲突出现的位置，你可以手动移除你不想保留的修改，保存你想要的修改。(merge 时的冲突处理后需要重新提交，rebase 则不用。)</p><p>这里建议使用编译器或者 git 可视化工具提供的功能来解决冲突。比如 vscode、fork 等。</p><h2 id="4-reset-重置"><a href="#4-reset-重置" class="headerlink" title="4.reset(重置)"></a>4.reset(重置)</h2><p>当你进行了错误的提交(比如有 bug)时，或许你需要使用到 git reset。</p><p>它可以修改当前 HEAD 的指向，从而不再使用那次错误的提交。</p><p>重置分为软重置和硬重置。</p><h3 id="软重置"><a href="#软重置" class="headerlink" title="软重置"></a>软重置</h3><p>软重置只会移动 HEAD 的指向，而不会删除该指向之后的修改。</p><p>我们在 2 次提交中分别提交 something.js 和 anything.js 后：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/before_soft_reset.png" srcset="/img/loading.gif" class="" title="before_soft_reset"><p>此时执行 <code>git reset --soft HEAD~2</code>：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/after_soft_reset.png" srcset="/img/loading.gif" class="" title="after_soft_reset"><p>提交回到了 2 次提交之前，但通过 git status 可以看到，something.js 和 anything.js 并未删除：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/soft_reset_files.png" srcset="/img/loading.gif" class="" title="soft_reset_files"><h3 id="硬重置"><a href="#硬重置" class="headerlink" title="硬重置"></a>硬重置</h3><p>硬重置与软重置唯一的不同，就是你重新指向的那次提交之后的修改都会被丢弃。这包括工作目录中的和暂存区的修改。</p><p>对应上面的例子，则 anything.js 和 something.js 将会被删除。</p><h2 id="5-revert"><a href="#5-revert" class="headerlink" title="5.revert"></a>5.revert</h2><p>git revert 是另一种撤销修改的方式。</p><p>不同于 git reset，它不会修改分支的历史(git reset 会直接删除提交记录)。</p><p>执行 <code>git reset commit-id</code> 将会创建一次新的提交，并且会将 commit-id 对应的提交的修改移除。</p><h2 id="6-fetch"><a href="#6-fetch" class="headerlink" title="6.fetch"></a>6.fetch</h2><p>在我们进行开发时，我们会拥有一个远程分支，指向我们在 gitlab 上的库的某个分支。当你想获取远程分支上的最新代码时，便可以使用 fetch。</p><p>fetch 不会以任何方式影响你的本地分支，它只是单纯的下载新数据。要将这些修改合并到你的代码中，你依然需要执行 merge 或者 rebase。</p><h2 id="7-remote"><a href="#7-remote" class="headerlink" title="7.remote"></a>7.remote</h2><p>remote 可以用来管理你的远程仓库地址。</p><p>一般来说，当我们通过 clone 来拉取了一个远端的代码后，git 会默认在 remote 中给我们添加一个 origin 源。</p><p>通过 <code>git remote -v</code> 可以查看当前的 remote 源：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/git_remote_v.png" srcset="/img/loading.gif" class="" title="git_remote_v"><p>此时你应该明白，当你执行 <code>git push origin master</code> 的时候，你是在做什么了，是在向远端 origin 对应的仓库的 master 分支提交代码。</p><p>如果你是想把本地的一个目录提交到某个新建的远端 git 仓库上，怎么做呢？</p><p>首先，我在 gitlab 上新建了一个名为 my-project 的 project，地址为 <a href="mailto:git@gitlab.xxxx.com">git@gitlab.xxxx.com</a>:dulb/my-project.git</p><p>接着我在我想要提交的本地目录通过 git init 命令将此目录初始化为一个 git 目录:</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/git_init.png" srcset="/img/loading.gif" class="" title="git_init"><p>接着使用 <code>git remote add</code> 来添加远端 git 仓库地址</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/git_remote_add.png" srcset="/img/loading.gif" class="" title="git_remote_add"><p>ps:这个 origin 可以是任何名字，你也可以通过 <code>git remote rename</code> 随时修改成任何你觉得更清晰的名字：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/git_remote_rename.png" srcset="/img/loading.gif" class="" title="git_remote_rename"><p>接着你就可以使用 git push 将你的代码提交到远端了。</p><p>remote 可以有多个，如果你在开源社区 github 并希望对某个 project 进行代码贡献，一般的做法就是 fork 该库到你自己的空间。然后在本地时，你通过 remote 维护两个远端仓库，一个指向你 fork 的远端库，一个指向原 project 本身。这样，到你最终的 merge request 被通过合并前，你的代码不会以任何形式出现在该 project 的 github 空间中。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有一些命令，比如 cherry-pick，reflog 等，略。</p><h1 id="最简单的-git-工作流"><a href="#最简单的-git-工作流" class="headerlink" title="最简单的 git 工作流"></a>最简单的 git 工作流</h1><p>掌握了基本的 git 命令之后，在我们具体的项目中，我们使用什么方式来进行代码提交呢？</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/git_work_flow.png" srcset="/img/loading.gif" class="" title="git_work_flow"><p>如上是一个比较完整的 git 工作流，但大多数的实际项目不比开源项目，开发人员一般不会太多。</p><p>如果我们的开发团队只有 5 个人左右，我们并不需要这么完整的工作流。</p><p>所以在当前公司我们并没有使用上图这种相对复杂的 git 工作流，而是采用一种相对简单的方式，这里简单地介绍一下流程。</p><h2 id="简单工作流"><a href="#简单工作流" class="headerlink" title="简单工作流"></a>简单工作流</h2><p>假设目前我们的远端代码仓库为<a href="mailto:git@gitlab.xxxx.com">git@gitlab.xxxx.com</a>:dulb/my-project.git</p><p>而 master 分支为我们的保护分支(不允许直接 push 代码)。</p><p>当我们想要为其贡献代码的时候，步骤如下</p><h3 id="1-克隆代码"><a href="#1-克隆代码" class="headerlink" title="1.克隆代码"></a>1.克隆代码</h3><p><code>git clone git@gitlab.seeyon.com:dulb/my-project.git</code></p><h3 id="2-修改代码"><a href="#2-修改代码" class="headerlink" title="2.修改代码"></a>2.修改代码</h3><p>当开发一个新的 feature 时，在 master 分支上通过<code>git checkout -b feat/feature-desc</code>切换一个新的 feature 分支，再在此分支上进行开发。</p><h3 id="3-提交代码"><a href="#3-提交代码" class="headerlink" title="3.提交代码"></a>3.提交代码</h3><p>分支开发完成后，首先通过<code>git add</code> 和 <code>git commit</code>将代码将提交到本地分支中。<br>在将此代码 push 到远端仓库前，_需要在本地获取最新的 master 代码并合并到分支代码中_，这样能够保证管理员在合并代码时不会出现冲突。<br>首先通过<code>git fetch origin master</code>下载远端 master 分支最新的代码。<br>接着使用<code>git rebase origin master</code>合并远端 master 最新的代码并处理可能的冲突。<br>最后使用<code>git push origin feat/feature-desc</code>将分支代码推送到远端仓库。</p><h3 id="4-提交-merge-request"><a href="#4-提交-merge-request" class="headerlink" title="4.提交 merge request"></a>4.提交 merge request</h3><p>merge request 顾名思义，即一个合并请求，即请求将分支代码合并到另一个分支上，此处我们是请求将 feat/feature-desc 分支合并到 master 中。</p><p>上一步完成之后，登录到 gitlab，你会在顶部看到这么一条信息：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/auto_mr_btn.png" srcset="/img/loading.gif" class="" title="auto_mr_btn"><p>这是 gitlab 提供的提交 merge request 的快捷方式。<br>如果你没看到这条消息也没关系，进入对应的仓库点击左边的 merge request 选项卡即可：</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/menu_tab.png" srcset="/img/loading.gif" class="" title="menu_tab"><p>点击创建一个 merge request，将来到如下页面:</p><img src="/2020/09/29/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/mr_detail.png" srcset="/img/loading.gif" class="" title="mr_detail"><p><code>title</code>,<code>description</code>我就不作介绍了。 不过这里注意 Title 输入框下面的这个<code>start the title with WIP</code>按钮，如果你的分支尚在开发中并不希望被合并，你就可以点击这个按钮，它会在 title 前面添加一个 WIP 前缀,即 work-in-progress，这样可以阻止这个分支被合并，当你完成开发之后再取消这个状态即可。</p><p><code>assignee</code>是指定合并人。 <code>milestone</code>是 project 的里程碑，<code>label</code>则是给你的这个 mr 打上标签，这三个属性都选择合适的值即可。</p><p><code>Source branch</code>和<code>Target branch</code>则分别是你要合并的源分支和目标分支，即将源分支的代码合并到目标分支中，我们这里是将 feat/feature-desc 合并到 master 中，则如上图所示。</p><p>下面还有 2 个 checkbox，第一个表示管理员点击合并后，将删除你提交到远端的这个<code>feature-desc</code>分支(不是本地)，故当你完成了这个 feature 开发的开发时，勾选此选项。<br>第二个则是合并你分支上的 commit 记录，勾选此选项后，即使你的分支拥有 10 个 commit，在 master 上只会看到一个。</p><p>最下面的三个选项卡 Commit/pipelines/Changes 则分别是 commit 信息，流水线和代码修改记录。也是 code reviewer 或者管理员主要关注的区域。<br>在这里可以看到本次 mr 的代码变化，pipeline 是否通过(目前我们通过 Jenkins 构建而不是 gitlabci，故这里的 pipeline 没用。)</p><p>提交之后，提醒管理员(可以考虑假如通过 hook 给管理员发送邮件)合并代码即可。</p><h2 id="分支命名规范和代码提交规范"><a href="#分支命名规范和代码提交规范" class="headerlink" title="分支命名规范和代码提交规范"></a>分支命名规范和代码提交规范</h2><p>这里介绍一种基于提交消息的轻量级约定—约定式提交，它主要是用于规范 git commit 信息。使用这种规则，我们可以得到更加清晰可读的提交记录，还能方便我们之后编写基于这种规范的自动化工具。</p><p>主要的做法是在提交信息中描述新特性、bug 修复和破坏性变更。</p><p>这里我直接引用官方说明：</p><p>提交说明的结构如下所示：</p><pre><code class="hljs plain">&lt;类型&gt;[可选的作用域]: &lt;描述&gt;[可选的正文][可选的脚注]</code></pre><p>提交说明包含了下面的结构化元素，以向类库使用者表明其意图：</p><p>fix:  类型   为  fix  的提交表示在代码库中修复了一个 bug（这和语义化版本中的  PATCH  相对应）。<br>feat:  类型   为  feat  的提交表示在代码库中新增了一个功能（这和语义化版本中的  MINOR  相对应）。<br>BREAKING CHANGE:  在可选的正文或脚注的起始位置带有  BREAKING CHANGE:  的提交，表示引入了破坏性 API 变更（这和语义化版本中的  MAJOR  相对应）。 破坏性变更可以是任意   类型   提交的一部分。<br>其它情况:  除  fix:  和  feat:  之外的提交   类型   也是被允许的，例如  @commitlint/config-conventional（基于  Angular 约定）中推荐的  chore:、docs:、style:、refactor:、perf:、test:  及其他标签。 我们也推荐使用 improvement，用于对当前实现进行改进而没有添加新功能或修复错误的提交。 请注意，这些标签在约定式提交规范中并不是强制性的。并且在语义化版本中没有隐式的影响（除非他们包含 BREAKING CHANGE）。  可以为提交类型添加一个围在圆括号内的作用域，以为其提供额外的上下文信息。例如  feat(parser): adds ability to parse arrays.。</p><p>比如我要提交的代码是在开发一个新的特性，开发了一个订单详情页面。那么我在提交代码时，应该：</p><pre><code class="hljs plain">git commit -m &quot;feat: 增加了一个订单详情页面. (...更多的描述)&quot;</code></pre><p>更多的例子可以查看<a href="https://www.conventionalcommits.org/zh-hans/v1.0.0-beta.4/" target="_blank" rel="noopener">官方介绍</a>。</p><p>进一步的，你可以使用 git hook 来对 commit 信息进行校验，禁止不符合规范的提交。</p><p>将之引申，我们在创建分支的名字时，也可以使用类似的约定，比如 feature 分支，分支名为 feat/xxxx， 比如修复 bug，分支名为 fix/xxxx。</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react项目前端单元测试方案</title>
    <link href="/2020/07/20/react%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/20/react%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>测试，是现代软件开发过程中一个必须的组成成分，任何的产品想要真正推向市场，都必须经过一轮又一轮的测试，以及来保证产品的可用性，增强团队对于产品的信心。 而单元测试，则是其中的一个组成成分，软件行业发展到今天，它的角色也越来越重要，逐渐成为最基本的测试实践之一。</p><p>但据我所了解到的情况来看，写单元测试在很多的人和团队的眼中更像是一种“政治正确”。 看见大家都在做单元测试，社区都说要写单元测试，技术负责人一看，“咦，不行，我们不能落后，我们也要写”。于是团队成员在一种极其不情愿的情况下写起了单元测试，这样的单元测试，难怪大多数开发人员觉得是负担。</p><p>所以，在进入正题之前，我想先简要的阐述一下我对于单元测试的观点，即为什么要做单元测试？</p><p>PS：本文使用的测试框架为 Jest + React testing library。但将会跳过这些框架的语法介绍部分，更偏向于介绍如何写的的实践部分。要阅读文章包含的代码部分，读者最好对 react+javascript 有基本的掌握。</p><h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>单元测试可以提高代码和软件的质量保障，这一点应该没有人会反对。但真正进行推行的时候，“没啥作用”，“浪费时间”，“又是工作量” 这些声音却总是不绝于耳。</p><p>上面提到单元测试如今逐渐成为一种行业标准和政治正确，但总还是有团队在执行的时候“将在外君命有所不受”，一边说着：“要写真正有用的测试，作用不大的测试应该砍掉”，一边理所当然地看心情写测试。最终的结果往往就是最终的项目基本没有覆盖单元测试。</p><p>要克服这个心里障碍，我们就要弄清楚我们到底是为什么要写单元测试。 单元测试真的是浪费时间么？ 肯定不是， 从一个最底层开发者的角度， 假设你开发了某一项功能，将之发布的前提是手工测试通过。而后来这个模块又出现了一个新需求，因为做这个新功能你对原来的代码有一些改动，于是在发布前你除了测试了新功能是否有问题外，还必须手工测试一下以前的功能是否受到的影响。然后这时又来了一个新功能。。。你逐渐发现你每次要测试的东西越来越多。 后来某一天，来了一个新的架构师，他觉得你们之前的编码臃肿而”丑陋“，”为了便于未来的扩展“，他让你重构你的代码。这时的你是绝望的，因为没有单元测试保证，你的任何改动都需要进行手工测试保证无误，于是最终你选择了跑路。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ionic在移动端react项目中的使用</title>
    <link href="/2020/07/20/ionic%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AFreact%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/07/20/ionic%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AFreact%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近接触了一个移动端的 2C 项目， 上一次做 2C 的项目已经可以追溯到遥远的毕业第一年了。能够把这些年间歇看到的 2C 的一些知识点进行应用还是挺有趣的。 在项目中，我们使用了 ionic 来作为移动端 h5 的组件库，经过一个多月的使用，也总结了一些经验。</p><h1 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h1><p>我们都知道做 h5 或者 SPA 较之原生 app 在性能上的巨大差距。于是市面上有很多 hybird 的库都是封装原生的实现，提供 js 的编码接口，其代表就是 React Naive。 但使用 RN 本身需要一定的原生开发经验，对开发人员有一定的要求，一方面我担心未来的坑不好踩，另一方面也担心新人培养成本和未来团队在维护的时候产生较大的技术困难。还有一点也是今年 airbnb 等使用 RN 的代表公司放弃 RN 给我留下的心理阴影- -。</p><p>之所以选用 ionic 作为前端的组件库是因为我在做调研的时候被它的介绍所吸引了。跨平台、高性能保证、使用 web-component 作组件封装、对目前的前端三大框架都做了支持、简洁响应式并支持主题切换的 UI 设计、同样封装了大量原生方法并提供 api。官网的介绍确实是比较诱人了，另一方面，ionic 本身也是一个维护了很多年的项目，且 4.0+新版本的发布也才过去不久，github 上的更新频率也足够快，整体值得信赖。<br>而我们项目本身又是一个 MVP 试错的新项目以及我作为程序员喜欢尝鲜的特点，我最终决定试一试。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>先说使用一个多月后的一个总体感觉。<br>首先，坑确实不少。</p><ol><li><p>组件样式修改和自定义有难度。这一点有点成也 web-compnent，败也 web-component。ionic 使用 web-component 作组件封装，组件的 dom 结构和 css 都封装在 shadow dom 中，修改样式的方式就是使用 css 变量并向外暴露。这样的方式除了修改 css 变量本身稍显麻烦意外本来没有什么问题，但 ionic 给我的感觉是做的不够彻底。经常遇到需要修改的 css 样式没通过 css 变量做，而是需要直接写样式覆盖，或者写死于全局样式让人担心覆盖后产生的影响，或者写死于 shadow-dom 内无法修改的情况。一方面找这种 css 存在层级比较麻烦，另一方面也增加了开发者和 UI 的沟通成本。</p></li><li><p>提供的组件库不是特别全。就组件库的完整度来说，ionic 还有一段路要走。在实际使用的时候，因为已经引入了 ionic，所以我们暂时没有考虑引入其它的组件库，那么就会遇到不少组件需要自己开发的情况，对于小项目组来说也是一项负担。项目做了一个月，自开发的比较耗时的公共组件数量就达到 4 个，未来肯定会更多。而且自开发的组件和 DOM 结构要接入 ionic 生态，比如支持 theme，使用 css 变量等，也算是负担。</p></li><li><p>Documentation 的完整度不足且只有英文，虽然有文档也有 example，但 example 有些敷衍，文档整体结构和描述也不够清晰。且目前没有中文文档，对于团队成员的培养也是一个问题。</p></li><li><p>对 react 支持不足，不少组件目前还没有 react 版本，或者有了 react 版本文档却没有更新，依然写着“not support react”。</p></li></ol><p>优点当然也是存在的：</p><ol><li>主题切换确实比较方便，只要定义好 css 结构并且做好自定义组件和各种 html css 的接入(按照 ionic 的方式使用 root 和 host 下的 css 变量)。那么主题就真正可以做到一键切换。对于我们这种用户独立部署的产品来说非常实用。</li><li>性能还不错。不同组件在 ios 和 android 都使用了原生来实现，且通过 mode 来进行样式的切换。不管从样式和手势体验还是性能上给到用户的使用感受确实很有原生 app 的感觉。</li><li>因为使用了 web-component，所以 dom 结构非常清晰。对 css 调试和单元测试都提供了一些方便。</li></ol><h1 id="实践经验总结"><a href="#实践经验总结" class="headerlink" title="实践经验总结"></a>实践经验总结</h1><p>ionic 官网的指南和 doc 在<a href="https://ionicframework.com/docs" target="_blank" rel="noopener">这里</a>。</p><p>下面总结一些使用过程中记录下来的点。关于安装这些就跳过不讲了，ionic 提供了自己的 cli，但功能并不多，我们也没有使用。</p><h2 id="关于样式"><a href="#关于样式" class="headerlink" title="关于样式"></a>关于样式</h2><p>ionic 提供的组件间的样式是自隔离的，但 ionic 本身也有一些全局的样式。如果你想要使用所有 ionic 的特性，你需要引入它们。主要有以下几个文件：</p><ul><li><strong>core.css</strong>：这是唯一一个必须引入的全局样式文件。它包含了 app 的特定样式，允许 color 属性跨组件工作。如果不引入这个文件，一些组件元素的颜色可能会出现问题。</li><li><strong>structure.css</strong>: 推荐。应用于 html 标签的样式，以及类似 box-sizing=border-box 等默认样式，保证了滚动等行为更像原生体验。</li><li><strong>typography.css</strong>:推荐。字体相关</li><li><strong>normalize.css</strong>: 推荐。使浏览器渲染元素更加稳定。</li><li><strong>padding.css</strong>:定义了一些修改 padding 或者 margin 的样式。<a href="https://ionicframework.com/docs/layout/css-utilities#content-space" target="_blank" rel="noopener">这里查看详情</a></li><li><strong>float-elements.css</strong>: 提供了一些 float 相关的样式，给予 breakpoint 和 side，<a href="https://ionicframework.com/docs/layout/css-utilities#element-placement" target="_blank" rel="noopener">这里查看详情</a></li><li><strong>text-alignment.css</strong>:提供了一些关于字体排列的样式。<a href="https://ionicframework.com/docs/layout/css-utilities#text-alignment" target="_blank" rel="noopener">这里查看详情</a></li><li><strong>text-transformation.css</strong>:提供一些字母大小写，首字母大写等样式。<a href="https://ionicframework.com/docs/layout/css-utilities#text-transformation" target="_blank" rel="noopener">这里查看详情</a></li><li><strong>flex-utils.css</strong>:flex 相关的一些样式，<a href="https://ionicframework.com/docs/layout/css-utilities#flex-properties" target="_blank" rel="noopener">这里查看详情</a></li><li><strong>display.css</strong>: 基于 breakpoint 用于控制显示隐藏的样式。<a href="https://ionicframework.com/docs/layout/css-utilities#element-display" target="_blank" rel="noopener">这里查看详情</a></li></ul><p>在项目中不一定要全部引入，根据实际情况按需进行引入即可。<a href="https://ionicframework.com/docs/layout/css-utilities" target="_blank" rel="noopener">这里有上述样式列表的各种样式使用例子</a>。</p><h2 id="关于主题-theming"><a href="#关于主题-theming" class="headerlink" title="关于主题 theming"></a>关于主题 theming</h2><h3 id="colors"><a href="#colors" class="headerlink" title="colors"></a>colors</h3><p>ionic 有九种默认的颜色可供切换并应用到众多组件上。每种颜色有多个属性，包括本来的颜色和 shade 以及 tint。</p><p>所以要修改一个颜色，你得修改这个颜色的所有相关属性。每个颜色由 <code>base,contrase,shade,tint</code>几种属性组成。前面两者还需要一个 rgb 属性的额外设置。听起来比较麻烦，但 ionic 提供了颜色生成器，你只需要提供一个主题 color，其它有生成器帮你生成。<a href="https://ionicframework.com/docs/theming/colors" target="_blank" rel="noopener">生成器在这里</a></p><p>比如要向 ionic 中添加一个新的 color，第一步，先在全局中加入变量：</p><pre><code class="hljs plain">:root &#123;  --ion-color-favorite: #69bb7b;  --ion-color-favorite-rgb: 105,187,123;  --ion-color-favorite-contrast: #ffffff;  --ion-color-favorite-contrast-rgb: 255,255,255;  --ion-color-favorite-shade: #5ca56c;  --ion-color-favorite-tint: #78c288;&#125;</code></pre><p>接着，创建一个使用这些变量的 class。class 名字需要是 .ion-color-{COLOR-NAME}格式。如下：</p><pre><code class="hljs plain">.ion-color-favorite &#123;  --ion-color-base: var(--ion-color-favorite);  --ion-color-base-rgb: var(--ion-color-favorite-rgb);  --ion-color-contrast: var(--ion-color-favorite-contrast);  --ion-color-contrast-rgb: var(--ion-color-favorite-contrast-rgb);  --ion-color-shade: var(--ion-color-favorite-shade);  --ion-color-tint: var(--ion-color-favorite-tint);&#125;</code></pre><p>接着你就可以在任何的组件中使用它了：</p><pre><code class="hljs plain">&lt;ion-button color&#x3D;&quot;favorite&quot;&gt;Favorite&lt;&#x2F;ion-button&gt;</code></pre><p>当然，你在 style 中定义的变量，你还可以在其它任何地方使用。</p><h3 id="CSS-变量"><a href="#CSS-变量" class="headerlink" title="CSS 变量"></a>CSS 变量</h3><p>所有的主题实现基于 css 变量。所以修改主题样式非常方便，通过修改 ionic 的 css 变量即可实现。通过在一处定义变量，其它地方使用的方式。ionic 可以非常方便的对样式进行动态修改。这以前需要像 sass 这样的预处理器，但 css 变量让这一切变得简单。<br>可以将变量声明在:root 下创建全局的 css 变量，也可以声明在上面说到的 mode 样式下来将变量作用域缩小到一种 mode。当然还可以进一步声明在一个组件上或者某个具体的 class 下。</p><p>比如希望把某 container 下的–background 变量进行修改：</p><pre><code class="hljs plain">.xxx_container &#123;  --ion-color-secondary: #006600;  --ion-color-secondary-rgb: 0,102,0;  --ion-color-secondary-contrast: #ffffff;  --ion-color-secondary-contrast-rgb: 255,255,255;  --ion-color-secondary-shade: #005a00;  --ion-color-secondary-tint: #1a751a;&#125;</code></pre><p>这样，xxx_container 下面的 ionic 元素使用这些 css 变量的地方就会改变。</p><h3 id="ionic-modes"><a href="#ionic-modes" class="headerlink" title="ionic modes"></a>ionic modes</h3><p>ionic 使用 modes 来定制化组件在不同平台的样式，每个平台的默认 mode 不同，但可以通过全局配置被重写。</p><p>默认配置如下：<br>|Platform | Mode | Description|<br>|—|—|—|<br>|ios | ios | ios Viewing on an iPhone, iPad, or iPod will use the iOS styles.|<br>|android | md | Viewing on any Android device will use the Material Design styles.|<br>|core | md | Any platform that doesn’t fit any of the above platforms will use the Material Design styles.|</p><p>举个例子，安卓平台的 ionic app 将会使用 md 模式。即<code>&lt;html class=&quot;md&quot;&gt;</code></p><p><strong>覆盖 mode 样式</strong>：<br>如上我们可以看到 ionic 根据不同平台在 html 标签上加了一个 class，那么我们可以巧妙地使用它来对某一种模式的样式进行覆盖：</p><pre><code class="hljs plain">.ios ion-badge &#123;  text-transform: uppercase;&#125;</code></pre><p>同样，有很多全局的 css 变量可以被覆盖，如 <a href="https://ionicframework.com/docs/theming/colors" target="_blank" rel="noopener">ionic 的颜色变量</a>，<a href="https://ionicframework.com/docs/theming/themes" target="_blank" rel="noopener">主题变量</a>和<a href="https://ionicframework.com/docs/theming/advanced" target="_blank" rel="noopener">全局组件变量</a>。</p><h3 id="themes-主题"><a href="#themes-主题" class="headerlink" title="themes 主题"></a>themes 主题</h3><p>ionic 提供了一些全局变量，它们在整个组件库中使用，从而通过修改它们可以修改整个 app 的主题。<br>主要分为 Application Colors 和 Stepped Colors 两类，前者可以修改大多数 ionic 组件的样式，后者则用于为某些组件提供更多的变化。</p><p><strong>Application Colors</strong>：</p><p>这个类型的 colors 会在 ionic 的大多数地方用到。<br>注意其中的 background 和 text color 也都需要设置一个 rgb 变量。<a href="https://ionicframework.com/docs/theming/advanced#the-alpha-problem" target="_blank" rel="noopener">原因</a></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>–ion-background-color</td><td>整个 app 的背景色</td></tr><tr><td>–ion-background-color-rgb</td><td>整个 app 的背景色, rgb format</td></tr><tr><td>–ion-text-color</td><td>整个 app 的文字颜色</td></tr><tr><td>–ion-text-color-rgb</td><td>整个 app 的文字颜色, rgb format</td></tr><tr><td>–ion-backdrop-color</td><td>背景组件的颜色</td></tr><tr><td>–ion-backdrop-opacity</td><td>背景组件透明度</td></tr><tr><td>–ion-overlay-background-color</td><td>叠加层(overlays)的背景色</td></tr><tr><td>–ion-border-color</td><td>边框颜色</td></tr><tr><td>–ion-box-shadow-color</td><td>Box shadow 颜色</td></tr><tr><td>–ion-tab-bar-background</td><td>Tab Bar 背景</td></tr><tr><td>–ion-tab-bar-background-focused</td><td>焦点 Tab Bar 的背景</td></tr><tr><td>–ion-tab-bar-border-color</td><td>Tab Bar 的边框色</td></tr><tr><td>–ion-tab-bar-color</td><td>Tab Bar 的颜色</td></tr><tr><td>–ion-tab-bar-color-selected</td><td>选中的 Tab Button 颜色</td></tr><tr><td>–ion-toolbar-background</td><td>Toolbar 背景色</td></tr><tr><td>–ion-toolbar-border-color</td><td>Toolbar 边框颜色</td></tr><tr><td>–ion-toolbar-color</td><td>Toolbar 内组件的颜色</td></tr><tr><td>–ion-toolbar-segment-color</td><td>Toolbar 中细分按钮的颜色</td></tr><tr><td>–ion-toolbar-segment-color-checked</td><td>Toolbar 中选中的细分按钮的颜色</td></tr><tr><td>–ion-toolbar-segment-background</td><td>Toolbar 中细分按钮的背景色</td></tr><tr><td>–ion-toolbar-segment-background-checked</td><td>Toolbar 中选中的细分按钮的背景色</td></tr><tr><td>–ion-toolbar-segment-indicator-color</td><td>Toolbar 中细分按钮指示器(indicator)的颜色</td></tr><tr><td>–ion-item-background</td><td>Item 的背景色</td></tr><tr><td>–ion-item-border-color</td><td>Item 的边框颜色</td></tr><tr><td>–ion-item-color</td><td>Item 内组件的颜色</td></tr><tr><td>–ion-placeholder-color</td><td>Inputs 中 placeholder 的颜色</td></tr></tbody></table><p><strong>stepped colors</strong>：</p><p>当然，整个 ionic 的颜色没有那么简单，在设计时还使用来不同的背景和文字颜色的阴影。为适应这种模式，ionic 创建来阶梯色(stepped color)。</p><p>简单的梗概 <code>ion-background-color</code>和<code>--ion-text-color</code>将会改变大部分组件的表现，但某些 ionic 组件可能会看起来有一些 broken。特别是在应用一些暗色主题的时候。</p><p>这是因为在一些组件中为 background-color 和 text-color 加了一些 lighten 或者 darken 的阴影。所以，如果你要修改这二者，那么也请同步更改对应的 steped colors。</p><p><a href="https://ionicframework.com/docs/theming/themes" target="_blank" rel="noopener">官方文档的最下方</a>提供了一个 stepped color 的生成器，我们只需要选择好再复制即可。不用劳神。</p><h2 id="在-react-中的使用"><a href="#在-react-中的使用" class="headerlink" title="在 react 中的使用"></a>在 react 中的使用</h2><p>先说一说 ionic 的一些组件</p><h3 id="IonReactRouter"><a href="#IonReactRouter" class="headerlink" title="IonReactRouter"></a>IonReactRouter</h3><pre><code class="hljs plain">export declare class IonReactRouter extends React.Component&lt;BrowserRouterProps&gt; &#123;    render(): JSX.Element;&#125;</code></pre><p>上述是它的声明，所以这就是一个 React-router 中的 BrowserRouter 的 wrap。它与后者大体表现相同，直接使用它替代后者即可。 一些微小的区别可以在<a href="https://ionicframework.com/docs/react/navigation" target="_blank" rel="noopener">这里</a>查看。<br>例如：</p><pre><code class="hljs plain">&lt;IonApp&gt;  &lt;IonReactRouter&gt;    &lt;Switch&gt;      &lt;Redirect path&#x3D;&quot;&#x2F;&quot; exact to&#x3D;&quot;&#x2F;home&quot; &#x2F;&gt;      &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;HomePage&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;&#x2F;login&quot; exact component&#x3D;&#123;Login&#125; &#x2F;&gt;    &lt;&#x2F;Switch&gt;  &lt;&#x2F;IonReactRouter&gt;&lt;&#x2F;IonApp&gt;</code></pre><h3 id="IonPage-IonHeader-IonContent"><a href="#IonPage-IonHeader-IonContent" class="headerlink" title="IonPage,IonHeader,IonContent"></a>IonPage,IonHeader,IonContent</h3><ul><li><p><strong>IonPage</strong>: 是每个页面的基本组件(拥有 route/url 的组件)。包含一些主要的全屏组件模块，比如 header，title 和 content 组件。将 IonPage 用作根组件很重要，因为它有助于确保过渡正常工作，并提供 Ionic 组件依赖的基本 CSS。</p></li><li><p><strong>IonHeader</strong>: 组件顾名思义，存在于页面顶部并且不会随着内容变化滚动。除了处理一些 flex 布局意外，主要是用于装载其它组件，比如 IonToolbar(返回等按钮) 或者 IonSearchbar(搜索框)。</p></li><li><p><strong>IonContent</strong>: 则是页面的内容区域。用于提供和装载用户交互的可滚动内容。</p></li></ul><p>基本上一个正常的 page 的 dom 最外层就是</p><pre><code class="hljs plain">&lt;IonPage&gt;  &lt;IonHeader&gt;&#123;&#x2F;* content of header *&#x2F;&#125;&lt;&#x2F;IonHeader&gt;  &lt;IonContent&gt;&#123;&#x2F;* content of content *&#x2F;&#125;&lt;&#x2F;IonContent&gt;&lt;&#x2F;IonPage&gt;</code></pre><h3 id="关于-slot-属性"><a href="#关于-slot-属性" class="headerlink" title="关于 slot 属性"></a>关于 slot 属性</h3><p>用于表示你所插入的组件的放置位置，此属性来源于 web-component，如下是 webcomponent 标准中对它的解释:<br><strong>web component 中的一个占位符，你可以填充自己的标记，这样你就可以创建单独的 DOM 树并将它们呈现在一起。关联的 DOM 接口是 HTMLSlotElement。</strong></p><p>比如我想把一个退出按钮放在 header 的末尾：</p><pre><code class="hljs plain">&lt;IonHeader&gt;  &lt;IonToolbar&gt;    &lt;IonButtons slot&#x3D;&quot;end&quot;&gt;      &lt;IonButton onClick&#x3D;&#123;exit&#125;&gt;退出&lt;&#x2F;IonButton&gt;    &lt;&#x2F;IonButtons&gt;  &lt;&#x2F;IonToolbar&gt;&lt;&#x2F;IonHeader&gt;</code></pre><p><a href="https://github.com/mdn/web-components-examples/tree/master/element-details" target="_blank" rel="noopener">这里还有一个官方的例子</a>。</p><h3 id="组件封装和使用-styled-component-时的样式覆盖"><a href="#组件封装和使用-styled-component-时的样式覆盖" class="headerlink" title="组件封装和使用 styled-component 时的样式覆盖"></a>组件封装和使用 styled-component 时的样式覆盖</h3><p>贴个最简单的例子：</p><pre><code class="hljs plain">const DEMOWarning: FC&lt;&#123; text?: string; content?: string &#125;&gt; &#x3D; (&#123;  text &#x3D; &#39;Default Title&#39;,  content,&#125;) &#x3D;&gt; &#123;  return (    &lt;WarningContainer&gt;      &lt;IonItem&gt;        &lt;IonIcon icon&#x3D;&#123;informationCircleOutline&#125; &#x2F;&gt;        &lt;IonLabel&gt;&#123;text&#125;&lt;&#x2F;IonLabel&gt;      &lt;&#x2F;IonItem&gt;      &lt;p&gt;&#123;content&#125;&lt;&#x2F;p&gt;    &lt;&#x2F;WarningContainer&gt;  );&#125;;const WarningContainer &#x3D; styled.div&#96;  padding: 0 1rem;  background-color: props.theme.bg_color;  ion-item &#123;    --background-color: props.theme.bg_color;    --inner-border-width: 0;    --padding-start: 0;    --padding-top: 0;    --inner-padding-start: 0;  &#125;  p &#123;    margin: 0;  &#125;&#96;;</code></pre><p>可以看到可以直接使用 web-component 的名字选中 dom。<br>一些样式直接写，一些样式用 css 变量覆盖。这也是我上面说的不统一的地方之一。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>todo…</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://ionicframework.com/docs/components" target="_blank" rel="noopener">Ionic 官网组件文档</a></li><li><a href="https://ionicframework.com/docs/" target="_blank" rel="noopener">Ionic 官方指南，使用文档</a></li><li><a href="https://github.com/ionic-team/ionic-framework" target="_blank" rel="noopener">Ionic github repo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强大的前后端解耦方式-openapi_generator代码生成</title>
    <link href="/2020/07/17/%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6%E6%96%B9%E5%BC%8F-openapi-generator%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <url>/2020/07/17/%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6%E6%96%B9%E5%BC%8F-openapi-generator%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h1><p>对接口，接口联调，对字段，这些词汇对一个 web 开发者来说肯定不陌生，而且大多数时候听到这些词脑中就会下意识的觉得烦躁。</p><p>作为话不多更偏向就是干的程序员群体，对于联调和对接口这种涉及到大量沟通的事情多有抵触，而且这些事情本身的内容更偏向于劳动型而不是技术型，开发者本身的驱动性也并不强。<br>但另一方面这个事情本身却又非常重要。不管是系统与系统之间，还是随着前后端分离的主流，系统内部的前后端开发之间，都涉及到大量的通过接口进行通信的功能。</p><p>当然，在代码的世界里，有问题，就绝对不缺少解决方案。多年来为来解决这个问题，社区诞生了很多解决方案。</p><p>早期 api 开发人员会手动编写文档，维护一个接口通信文档，谁需要使用 api 服务，就把文档扔给对方，api 有更新时，同时去更新文档。这种方式的缺点太多就不赘述了。 而且，现在都还有使用这种方式的公司，我最近就遇到了。微笑: )</p><p>为了解决可读性等问题，出现了类似 RAP,NEI 等 api 管理方案。这些平台提供了单独部署，管理 api 接口并提供清晰的 api 展示界面，mock 数据等功能。提供了非常方便且实用的特性，它们也很够用了。但依然有一点问题，需要 api 开发人员在修改代码后去更新文档，而这一点，难以保证。</p><p>swagger 等工具做了这件事，只要你按照它提供的规范编写 api 和注释，写完或更新了 api 的同时，就能自动生成对应的 api 接口文档。<br><br>选用这些方式，适当的删减和组合，就可以大幅度提高接口对接的效率。似乎非常完美了，程序员们都很开心。</p><p>但技术的提升没有止境，闲下来的程序员们又开始想，要对接某个服务提供的 api，我要写很多的对接代码，这些代码有些是包装对方的 api，有的是为了做数据类型转换。比如作为一个前端，为了防止传递每个字段时我都需要确认一下它的类型，我想用 typescript 将接口调用进行封装，这样我就可以通过 typescript 的静态检查节约调用时繁琐的调参了。</p><p>但这些类型的编程，第一很枯燥，第二包含了大量的样板代码，第三，对方的接口文档已经提供了字段和字段类型，甚至有些告诉了我字段校验方式，我在包装接口时还要再写一次，好烦哦。</p><p>到这时，openapi-generator 就登场了。它基于 openapi 规范，为各种语言提供了生成这些代码的工具。 举个例子，api 开发人员写好了接口，此时有一个使用 JavaScript 的团队想要使用，只需要 run 一次 generator 命令，就能得到 typesript 包装好的方法，而且这些方法可以是返回 Promise，可以是 callback，可以是 async，这都由你决定。</p><h1 id="OpenAPI-是什么"><a href="#OpenAPI-是什么" class="headerlink" title="OpenAPI 是什么"></a>OpenAPI 是什么</h1><p>其实它的前身就是 Swagger 规范(当然我们现在说到 swagger 更多指的 swagger UI 和 Codegen 等工具)，它是目前描述 RESTful API 最流行的标准。经过 Reverb Technologies 和 SmartBear 等公司多年的发展，后来 SmartBear 捐赠给了 OpenAPI Initiative，现在主要由社区驱动。</p><p>OpenApi 是一种规范，它与语言无关。用于描述 RESTful web 服务， 只要你遵照此规范，就能使用相关工具生成文档、创建模拟应用、生成代码。</p><p>而 openapi-generator，就是基于 openapi 规范编写的 api 生成代码。</p><h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h1><p>说了这么多，那 openapi-generator 生成的代码长啥样呢？</p><p>举一个生成 typescript+fetch 的例子，一个登录接口：</p><pre><code class="hljs plain">&#x2F;&#x2F;apiasync login(requestParameters: LoginRequest): Promise&lt;string&gt; &#123;    const response &#x3D; await this.loginRaw(requestParameters);    return await response.value();&#125;&#x2F;&#x2F;modelexport interface LoginRequest &#123;    loginParam?: LoginParam;&#125;export interface LoginParam &#123;    &#x2F;**     *     * @type &#123;string&#125;     * @memberof LoginParam     *&#x2F;    mobile?: string;    &#x2F;**     *     * @type &#123;string&#125;     * @memberof LoginParam     *&#x2F;    authCode?: string;&#125;</code></pre><p>如上，这样你在调用接口的时候就可以不用操心那些琐事了，直接进行声明式的编程：</p><pre><code class="hljs plain">let params:LoginParam &#x3D; &#123;  mobile:&#39;18888888888&#39;,  authCode:&#39;000000&#39;&#125;const res &#x3D; yield call(userApi.login, &#123;loginParam:params&#125;);</code></pre><p>而且因为是 ts，在你传递错误参数和参数类型错误时，ts 的静态类型检查会直接告诉你错误。真香。 进一步的，假如将 generator 命令做进 cicd 中，一旦后端修改了接口代码，自动 run 得到新的前端代码，修改部分的错误就会直接暴露出来，直接驱动对接方进行对应的修改。</p><h1 id="openapi-generator-介绍和使用"><a href="#openapi-generator-介绍和使用" class="headerlink" title="openapi-generator 介绍和使用"></a>openapi-generator 介绍和使用</h1><p>正式介绍一下正主 openapi-generator。它的<a href="https://openapi-generator.tech/" target="_blank" rel="noopener">官方网站在这里</a>, <a href="https://github.com/OpenAPITools/openapi-generator" target="_blank" rel="noopener">github 在这里</a>。</p><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>为什么要使用 openapi generator 呢，除了功能上的强大，还有一些值得注意的点：</p><ul><li>完全免费，且使用的是 Apache 许可证 2.0 开发源代码。对于生成的代码文件没有任何约束，你可以任意使用。</li><li>已经被大量公司在产品中进行使用，这说明了它的功能非常稳定。</li><li>社区驱动，代码贡献者众多，更新快，维护者积极，生态完备。</li><li>语言支持非常广泛，基本覆盖所有主流的 api 客户端代码生成，并且还在增加。</li></ul><h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装命令行工具：<br>openapi generator cli 的安装有多种方式</p><pre><code class="hljs plain">&#x2F;&#x2F;npm package：全局安装最新版本的 openapi generatornpm install @openapitools&#x2F;openapi-generator-cli -g&#x2F;&#x2F;homebrewbrew install openapi-generator</code></pre><p>还有 docker，jar 包，bash 等方式。在官网就能直接找到。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>通过 <code>openapi-generator help</code>可以看到它所提供的命令</p><img src="/2020/07/17/%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6%E6%96%B9%E5%BC%8F-openapi-generator%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/commands.png" srcset="/img/loading.gif" class="" title="openapi-generator命令"><p>这里只说最重要的 generate 命令，也就是真正用于生成代码的一个命令。它提供的参数非常多，可以使用<code>openapi-generator help generate</code>查看，这里贴出简要版本：</p><img src="/2020/07/17/%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E8%A7%A3%E8%80%A6%E6%96%B9%E5%BC%8F-openapi-generator%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/generate-command.png" srcset="/img/loading.gif" class="" title="generate命令">  <p>比如我最常使用到的一些参数：</p><ol><li>-i 指定输入的符合 OpenAPI 规范的文档。openapi generator 代码的生成主要基于 yaml 文件，其中配置了 api 的相关信息。说起来比较干燥，这里有一个<a href="https://raw.githubusercontent.com/openapitools/openapi-generator/master/modules/openapi-generator/src/test/resources/2_0/petstore.yaml" target="_blank" rel="noopener">官方提供的 yaml 的例子：petstore.yaml</a>。对于一个具体的 api，文件中描述了 api 的 http method，描述，方法名，参数名，参数类型，返回值类型，url 等各种信息。</li><li>-g 指定使用的生成器 generator。 不同的 generator 对应不同的语言和语言内部使用的工具库，比如上面例子中用到的 typescipt-fetch。 还有类似 go,ruby,php,javascript,typescript-axios 等，<a href="https://openapi-generator.tech/docs/generators/" target="_blank" rel="noopener">这里可以查看全部 generator</a>。</li><li>-o 指定输出目录，即生成的代码放置的位置，默认为当前目录。</li><li>-p 或者–additional-properties 指定 generate 选项，指定了 generator 使用的配置。比如<strong>allowUnicodeIdentifiers</strong>控制 unicode 的标识是否可以在方法名或参数名中使用，<strong>prependFormOrBodyParameters=true</strong>表示将 form 或者 body 参数添加到参数列表的最上面，<strong>modelPropertyNaming</strong>则控制属性名称的命令方式，可以是 camelCase 驼峰，可以是 snake_case，也可以是 original 保留 api 使用的属性名等，还有<strong>supportsES6=true</strong>表示生成的代码可以使用 es6 特性等等。</li></ol><p>一个例子：</p><pre><code class="hljs plain">openapi-generator generate -i http:&#x2F;&#x2F;localhost:xxxx&#x2F;api&#x2F;api-docs.yaml  --additional-properties allowUnicodeIdentifiers&#x3D;true,prependFormOrBodyParameters&#x3D;true,modelPropertyNaming&#x3D;original,supportsES6&#x3D;true -g typescript-fetch -o .&#x2F;src&#x2F;open-api</code></pre><h3 id="yaml-生成"><a href="#yaml-生成" class="headerlink" title="yaml 生成"></a>yaml 生成</h3><p>以应用最广泛的 java 为例，要得到这个 yaml 文件非常简单。只要你会使用 Swagger，就没有任何难点。</p><p>如下为 login 接口的 Controller:</p><pre><code class="hljs plain">@PostMapping(value &#x3D; &quot;&#x2F;login&quot;)@ApiOperation(value &#x3D; &quot;登录&quot;, httpMethod &#x3D; &quot;POST&quot;, response &#x3D; String.class)public String login(@RequestBody LoginParam param) &#123;    return loginInfoService.login(param.getMobile(), param.getAuthCode());&#125;</code></pre><p>然后 swagger 生成的 yaml 元数据文件为：</p><pre><code class="hljs plain">&#x2F;login:    post:      operationId: login      requestBody:        content:          &#39;*&#x2F;*&#39;:            schema:              $ref: &#39;#&#x2F;components&#x2F;schemas&#x2F;LoginParam&#39;      responses:        200:          description: default response          content:            &#39;*&#x2F;*&#39;:              schema:                type: stringcomponents:  schemas:    LoginParam:          type: object          properties:            mobile:              type: string            authCode:              type: string</code></pre><p>这个文件就可以直接交给 openapi-generator 进行代码生成！ 假设访问这个 yaml 文件的 url 为<code>http://127.0.0.1:8080/v3/api-docs.yaml</code>。我们在命令中使用-i 指定这个地址即可。</p><p>到此就完成了代码的生成，是不是非常的简单？</p><h3 id="生成的代码"><a href="#生成的代码" class="headerlink" title="生成的代码"></a>生成的代码</h3><p>对于生成的代码，我们有时肯定希望做一些修改，直接修改生成的文件肯定是不行的，因为你不可能每次重新生成后都再去改一次。</p><p>就 typescript-fetch 这个 generator 生成的代码而言，是支持很多扩展方式的。它暴露了一个 BaseAPI 类来提供这些封装好的 api 方法，而这个 BaseAPI 类除开这些访问 api 的函数外，还提供了如下几个方法：</p><ul><li>constructor</li></ul><pre><code class="hljs plain">constructor(protected configuration &#x3D; new Configuration()) &#123;  this.middleware &#x3D; configuration.middleware;&#125;</code></pre><p>实例化这个类的时候可以配置，包括用于在 url 前面添加统一 path 的 basePath, 设置 token 或 apiKey 的 accessToken 和 apiKey，设置 http header 信息的 headers 等。囊括了很多在调用 api 时需要做的自定义操作。比如用 basePath 设置/api 头方便做代理转发，用 headers 方法在 http header 中加入 token 令牌等。</p><ul><li>withMiddleware<br>用于注册 fetch 的中间件，分为 withPreMiddleware 和 withPostMiddleware 两种，分别在 fetch 前和 fetch 之后执行。如果你希望在拦截所有请求做一些处理，或者在所有请求返回之后做一些统一的处理，在这里进行相关工作就非常方便。<br>比如，接口统一加’/api’前缀并对返回做错误处理：</li></ul><pre><code class="hljs plain">const interceptFetchRes &#x3D; (context: RequestContextWithRes) &#x3D;&gt; &#123;  const &#123; response &#125; &#x3D; context;  if (response.status &lt; 200 || response.status &gt;&#x3D; 300) &#123;    &#x2F;&#x2F;统一错误处理  &#125;else&#123;    return Promise.resolve(response);  &#125;&#125;;let client &#x3D; new DefaultApi(new Configuration(&#123; basePath: &#39;&#x2F;api&#39; &#125;));client &#x3D; client.withPostMiddleware(interceptFetchRes);</code></pre><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>现在的互联网充满了各种碎片化的数据和服务，基于此也诞生了大量将这些服务进行整合的 mashup 程序。比如打通整个电影院-片单-排片-选座-支付流程的美团，就整合了这条线上各个参与者的接口。而如果大家都使用 openapi 的方式提供 api 服务，可想而知可以提高多少的开发效率。</p><p>当然，如果项目内部进行前后端分离，graphQL 这样的新贵也逐渐崭露头角，但目前我在自身对 graphQL 中的实践还处于摸索阶段，暂时就不献丑了～</p><p>btw. 电影院终于要重新开工了，憋死我了！</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户体验要素</title>
    <link href="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/"/>
    <url>/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>现实生活中，我们每天都在与无数的产品打交道。而我们也经常会吐槽某些产品那令人感到糟糕的体验。比如很容易沾灰的物品，容易被误操作的开关，手无法舒适安放的座椅，按键排列杂乱无章的遥控器等。这说明现实中还有很多的产品仅仅只是完成了作为一个产品的功能，细微却很重要的体验却经常被忽略了。当然，很多时候，功能本身也是用户体验的一种。</p><p>造成这种情况的主要原因就是因为在做一个产品的时候，我们并没有“设计”。整个创造产品的过程更像是一个逐步完成产品特性和功能的开发过程，做到可以“用”，就投向市场了。</p><p>“车内需要有一个可以触发喇叭的按钮”这是一个功能，而开始思考“应该把这个按钮放在不需要低头寻找，且开车时触手可及的地方”这样的问题，就是用户体验的设计。</p><p>很明显，用户体验对于任何产品都非常的重要， 对于一个网站更是如此。</p><p>对于 C 端产品来说，用户体验意味着转化率(CR)，CR 也是最直观衡量你的用户体验的指标。<br>而对于 B 端产品，用户体验则对应着效率，减少用户犯错的几率。</p><p>要完成一个用户体验好的产品，核心的要素就是 以用户为中心的设计。在 web 产品设计和构建的过程中，因为需求和技术等原因经常会做出各种妥协的决定，以此作为指导方针，能够保证方案上的妥协不是随机决定的。</p><p>最近在看的这一本《用户体验要素》，就是以用户体验的角度，来讲一个网站的设计。</p><p>这篇文章主要是读书笔记，同时也能分享一下知识~</p><h1 id="2-认识用户体验要素"><a href="#2-认识用户体验要素" class="headerlink" title="2.认识用户体验要素"></a>2.认识用户体验要素</h1><h2 id="网页设计建设的五个层面"><a href="#网页设计建设的五个层面" class="headerlink" title="网页设计建设的五个层面"></a>网页设计建设的五个层面</h2><p>网页用户体验的设计，书中将之分为五个层面。<br>表现层-框架层-结构层-范围层-战略层<br>从右至左，从抽象到具体。</p><p><strong>表现层</strong>：用户实际看到的网页，文字和图片。页面上的各种信息和事件。最为具体。<br><strong>框架层</strong>：各种元素的位置，框架层用于优化网页的布局，以达到这些元素的最大效果和效率。<br><strong>结构层</strong>：结构的具体表达方式。比如框架层确定了 A 页面上某个交互元素的位置，而结构层则是用来设计用户如何到达这个页面，并且之后能去什么地方。用计算机的话来讲就是定义了页面的路由跳转关系。其次，框架层定义了导航条上元素的排列方式，允许用户浏览不通的商品分类。而结构层则确定了哪些类别应该出现在那里。<br><strong>范围层</strong>：简单来将就是确定网站的功能范围，应该有哪些功能。<br><strong>战略层</strong>：顾名思义，战略包含了 网站的 owner 想要从网站得到什么，网站的 user 想要从网站得到什么。用需求来概括这一层的作用可能比较合适。</p><p>在进行设计和建设时，应该自下而上进行，每一层面都应该由它下面的层来决定，而不应该偏离。<br>当然，并不是说每个层面的工作都应该在下一个层面开始前完成，这样太过死板，你和你的用户可能都会感到头疼。更好的方式是让每一个层面的工作在下一个层面的工作结束前完成。如下：</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/five_layer.png" srcset="/img/loading.gif" class="" title="五个层面"><p>一句话来讲，在我们知道基本的形状前，不能为房屋加上房顶。</p><h2 id="基本的双重性"><a href="#基本的双重性" class="headerlink" title="基本的双重性"></a>基本的双重性</h2><p>从网站的设计上，又有两种不同的类型。<br>一些网站是“应用软件”型，它们的设计者偏向于从传统的桌面和客户端软件的角度来考虑解决方案，更加关注任务以及任务流程和解决。<br>一些网站是“信息”型，它们的设计者则更偏向于从媒体和信息技术的角度来考虑解决方案。</p><p>为了解决网页这种基本的双重性质，我们把这五个层面从中间分开。在左边主要描述功能型的平台类产品，这边我们主要关注任务。思考所有的操作如何发生，人们如何完成，把网站看作用户完成任务的工具。<br>在右边则用于描述信息型的媒介类产品。这边主要关注信息。网站应该提供哪些信息，如何展示提供更好的用户体验等。</p><h2 id="用户体验要素"><a href="#用户体验要素" class="headerlink" title="用户体验要素"></a>用户体验要素</h2><p>结合上面二者，我们来看一下每一层设计的时候我们的关注点要素。这些要素我们将在后买呢详细说明。</p><p><strong>战略层</strong><br>两种类型的产品在战略层关注的东西一致，即用户需求和产品目标。</p><p><strong>范围层</strong><br>进入范围层后。<br>关注点在功能性产品上转变为 创建功能规格(functional specification)：对产品的功能组合的详细描述。<br>关注点在信息型产品上转变为 内容需求(content requirement)：对各种内容元素的要求的详细描述。</p><p><strong>结构层</strong><br>功能性产品关注 交互设计(interaction design)，定义系统如何响应用户的请求。<br>信息型产品关注 信息架构(informatio architecture),合理安排元素以促进人类理解信息。</p><p><strong>框架层</strong><br>首先，在框架层，两种产品都要关注 信息设计(information design)，一种促进理解的信息表达方式。<br>其次<br>功能性产品还要关注 界面设计(interface design)，即安排好能让用户与系统产生互动的界面元素。<br>信息型产品还要关注 导航设计(navigation design)，屏幕上元素的组合，好让用户更好的在信息中穿行。</p><p><strong>表现层</strong><br>在表现层，两种产品的关注要素一致，都是为最终产品创建 感知体验(sensory experience)。</p><p>概括如下：</p><p>就我个人的经历来看，在真正设计网页时，或多或少也会考虑到上诉这些要素。但因为没有一个成体系的结构，是很难做到有效的全局设计的。<br>书中这种结构化的方式非常有利于我们在设计时进行有层次和专注的思考。</p><p>当然，在现实世界中，这些区域的界限并没有这么明确。很多问题我们需要同时重视多个区域。如今的产品也很少只属于信息型或者应用型产品，大多都是二者的综合。于是在每一层中这些要素都要相互作用才能完成该层的目标。</p><p>还有两个额外的因素会对用户体验造成影响。一是内容，二是技术。很少有用户会仅仅因为你的网站首页很漂亮而一直使用它，更多原因是因为你有优质的内容。而如果技术上实现不了，你做了再好的交互设计，却也无法落地。</p><p>接下来，我们分别深入每一层，来具体地了解这些用户体验要素。</p><h1 id="3-战略层"><a href="#3-战略层" class="headerlink" title="3.战略层"></a>3.战略层</h1><p>战略层的关注点是<strong>产品目标</strong>和<strong>用户需求。</strong></p><h2 id="产品目标"><a href="#产品目标" class="headerlink" title="产品目标"></a>产品目标</h2><p>对于这两点，我们必须<strong>明确</strong>。当我们越清楚地表达我们想要什么，以及确切的知道其他人想要从我们这里得到什么，我们就能越精确地满足双方的需求。</p><p>如何定义产品目标？<br>常见的做法是使用像<strong>商业目标</strong>来描述内部的战略目标，但这样的做法不是太狭义就是太广义了。一方面我们的产品目标可能不仅于此，另一方面，我们也希望用更具体的词汇来定义我们期望产品“本身”能够完成的事情。</p><p>一个合格的产品目标，需要能够告诉我们这个产品要如何支持企业的目标，或者如何满足用户的需求。要在太具体和太宽泛间取得平衡，我们应该避免在尚未充分了解问题之前就试图得出结论。明确地定义“成功的条件”，而不是“通往成功的路径”(避免在这个阶段跑得太快)。</p><p>其次，用户体验无形之中影响着企业的<strong>品牌形象</strong>。大多数的机构和公司，都是靠着用户体验来树立品牌形象的。 所以，将你期望的企业品牌形象明确地写进产品目标，将会提高呈现出积极品牌形象的机会。</p><p>最后，则是在产品目标中定义好<strong>成功标准</strong>。比赛都有终点，做一个产品，你必须有办法知道，达到什么情况你才能算达到的终点。</p><p>成功标准对于不同的产品当然是不同的。<br>作为内容型网站，你希望用户体验的改造能够提升用户在你的网站停留的平均时间。<br>作为依赖广告收入的网站，你希望提高广告的点击率。<br>作为为用户提供问题解答的网站，你希望减少客服中心的电话数量。</p><p>但并不是所有情况下都具备这种可以简单判断成功与否的标准。比如长时间段内指标的提升，你很难保证这是源于用户体验的改造还是其它原因。 有时候网站的访问量大幅下降，可能只是因为你的竞争对手砸了一大波钱搞 618。所以，尽量避免断章取义的目标，务必后退一步，看看网站之外发生来什么，确保你了解了事情的全貌。</p><h2 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h2><p>设计产品最容易陷入的一个陷阱就是“我觉得用户需要什么”，如此设计的理想用户其实是“那些与我们完全一样的人”。很明显，这违背了我们一直强调的“从用户的角度”来设计网站。</p><p>产生这种情况的一个原因是确认用户的需求本身太复杂，因为用户群体间存在着很大的差异性。要确认这些群体的需求，首先必须定义谁是我们的客户，然后就可以对他们进行调研。调研方式包括询问和观察其行为。 在此过程中得到需求，同时也能确定优先级。</p><h3 id="用户细分"><a href="#用户细分" class="headerlink" title="用户细分"></a>用户细分</h3><p>划分用户群体有很多方法，比如应用<strong>人口统计学</strong>，根据性别、年龄、教育水平、婚姻状况、收入等进行划分，粒度可以很粗略，也可以很具体。<br>还可以利用<strong>消费心态档案</strong>(描述用户对事物的观点和看法的心理分析方法)，虽然用户心理和年龄、性别、地区等息息相关。但即使是同样地区同样年龄的人，很多喜好也是不同的，想想你和你的同班同学们。<br>对于网站而言，还有一些重要的考虑因素：</p><ul><li>用户对技术和网页本身的看法。(上网时间、对计算机依赖性、对技术性产品的熟悉程度、是否喜欢升级产品、传统还是喜欢新技术等)</li><li>专业程度。为新手和为专业人士设计的产品肯定是非常不同的。要么只为其中一种提供，要么就位 2 种用户提供不同的方式</li><li>用户的社会角色</li></ul><p>完成细分后，你可能需要根据实际情况对你的细分用户群进行调整，比如某两个群体的需求一致，就需要合并。</p><h3 id="可用性和用户研究"><a href="#可用性和用户研究" class="headerlink" title="可用性和用户研究"></a>可用性和用户研究</h3><p>如何弄清楚用户具体想要什么呢？ 我们需要进行<strong>用户研究</strong>。用户研究有很多方法：</p><ul><li>市场调查方法：问卷，用户访谈，焦点小组都属于市场调查</li><li>现场调查：用一整套全面的方式，了解在日常生活情景中的用户行为。这种方式花费更多时间，但对用户会有更加深刻的理解，包括他们如何使用产品的细节等。</li><li>任务分析：轻量级的现场调查，去了解某一个具体任务的完成场景和过程。</li><li>用户测试：邀请用户来测试你的产品。测试范围随目的的不同而变化。 比如测试功能可用性，测试完整的网站，测试原型等，对应的产品完成阶段就从低保真到完整产品之间。</li><li>招募用户参与活动：任何可以让你洞察到用户的使用习惯和如何看待并使用你的产品的活动。</li><li>创建人物角色：或者叫做用户模型，也许我们更喜欢称之为用户画像。即使用更加形象的方式来代表一个具体的细分用户群体。这种更具体的方式使得你在设计的时候能够更加把用户放在心上。<br>比如你正在完整一个为用户提供旅游信息查询的产品。也许你就应该创建这样几个角色：<br>1.陈慧：女，27 岁，未婚，上海某金融公司员工，年收入 30W。热爱旅游，每个长假和年假都有出游计划，更喜欢出国游，对旅行时食物和住宿的品质要求较高。 2.张强：男，42 岁，已婚，有两个孩子，经营者一间数据线加工厂，喜欢在闲暇之余带家人到能够放松身心的地方旅行。<br>当然，这样的信息很多是我们编造的，为了让这些角色更加栩栩如生。甚至更进一步的你可以为这些人物添加照片，并将他们打印出来贴在办公室，随时提醒着你。如果增加了某个功能，陈慧需要它吗？对张强又有什么影响呢？</li></ul><h2 id="团队角色和流程"><a href="#团队角色和流程" class="headerlink" title="团队角色和流程"></a>团队角色和流程</h2><p>产品目标和用户需求制定过程中除了上述要点，还要与企业内部许多人进行谈话，尽量全面的了解和收集大家对于二者的不同看法。 进行决策时，除了企业政治原因不得不参与的人，尽量邀请产品真正的相关者，比如一个售后相关的产品，决策者可能就需要市场部门代表，客服部门代表等。当然，也不要忽略了真正与客户接触最多的普通一线员工。 大多数产品团队都存在的一个问题是：用户的反馈很少能够传递到需要这些信息的产品团队中去。</p><p>其次，定义好的产品目标和用户需求文档不是需求清单，更应该提供不同目标间的关系分析，并加以说明等。<br>文档尽量简洁明了的切中要点。上百页的资料没人愿意细读，直截了当更加高效。<br>其次，文档应该透明，让所有需要的参与者都能阅读，以帮助他们在工作中做出正确的决定。<br>最后，战略是设计用户体验流程的起点，但并不意味着你需要在项目开始前完全确定下来。应该允许战略进行演变和改进。</p><h1 id="4-范围层"><a href="#4-范围层" class="headerlink" title="4.范围层"></a>4.范围层</h1><p>功能规格和内容需求。<br>当我们得到<strong>产品目标</strong>和<strong>用户需求</strong>后。我们才能进一步的弄清楚如何满足这些战略目标。当我们把这二者转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果你是一个在产品团队中工作过的开发人员，你是否有过这样的经历，产品似乎永远只是 beta 版本。项目中没有一个人去真正定义需求，虽然有产品经理，但他的精力主要集中在新功能的思考上。导致的情况是这个产品在不断变化，并且混合了一个完整产品各个阶段的功能(只要有人读到一篇文章或者看到一个新的想法，就会启发产品负责人的灵感，然后他就会考虑增加一个新的功能特性)。项目虽然美其名的使用者“先进的 work flow”方式进行管理，但却没有明确的日程安排和里程碑，项目的完成根本看不到尽头，因为没人知道这个项目的范围。每个人都认为别人肩负着设计和开发产品关键环节的责任，但实际上这个人并不存在。</p><p>所以尽管定义产品需求并将之整理成文档很麻烦，但这件事却必须做。</p><ol><li>一方面，它明确了这个项目的目标，而不再是停留在产品经理脑中的不定型的图像。这才使得从高层管理人员到入门级的工程师，人人都能够参与进来。</li><li>另一方面，明确的文档能让你把责任分配的更清晰，也更容易让某个人或者某个小组对其中的一部分进行承担。并且对于那些听起来诱人的功能和想法，你也可以把它放入文档中管理起来，并且花时间思考，这些功能是否真正服务于你的产品目标和需求，做一做减法，排列一下优先级。<br>一定要管理好这些功能和需求，不要陷入滚雪球般的<strong>范围蠕变</strong>。就像在做 scrum 时，确定好一次迭代要完成的功能，除非重大变故，在这次迭代完成前都不要改变它。</li></ol><h2 id="功能和内容"><a href="#功能和内容" class="headerlink" title="功能和内容"></a>功能和内容</h2><p>到了范围层，我们思考的主要问题从“为什么”变成了“我们要开发的是什么？”</p><p>我们之前的介绍中，范围层的要素根据功能型产品和信息型产品分为功能规格和内容需求两种。 二者看似不同，但在定义范围层时所用的方式是非常相似的。 因为内容需求往往也伴随着功能的需求。<br>所谓功能规格，功能对应需求，规格在系统完成后描述系统真正完成了什么。但大多数时候是放在一起的，所以我们会经常看到<strong>功能规格说明书</strong>，这也是范围层产出的文档。</p><p>之所以说内容需求往往也伴随着功能的需求，是因为一般来说内容常常会通过 CMS(内容管理系统)来进行管理。而 CMS 内的内容添加-编辑-审核等流程设计、内容推荐方式等，就是功能。</p><p>PS：记住把网页中的各种提示也纳入需求，不要出现“Token 过期”这样一看就是程序员写出来的提示。</p><h2 id="定义需求"><a href="#定义需求" class="headerlink" title="定义需求"></a>定义需求</h2><p>通过我们在战略层中提到的用户研究方式，我们会得到很多的需求，它们主要为三类：</p><ul><li>非常清晰的好想法，可以直接转换为真实需求并通过各种途径体现在最终产品上</li><li>用户期望的特性其实并不是他们想要的。比如用户使用时遇到某个困难，期望有某种方式可以解决。这非常正常，但这些解决方法可能行不通，或者仅仅是饮鸩止渴。但通过与用户探讨这些建议，有时候可以得出真正解决问题的完全不同的需求。</li><li>人们不知道他们是否需要的特性。这经常在头脑风暴的时候出现，抛开正在维护的产品，冒出一些“伟大”的构思。所谓只缘身在此山中，产品的设计者和开发者往往很少能够思考到这些新方向。所以，汇集各个部门的成员或不同类型的用户代表进行头脑风暴会议，是一种非常好的打开新思路的方式。</li></ul><p>还有一些得到具体需求的方法：</p><ul><li>根据你的网站运行的设备，考虑硬件需求也是必须的。</li><li>使用上一章提到的用户画像的方式，将用户投入某个用户场景进行思考，也是得到潜在需求的好方法。</li><li>从竞争对手处得到一些启示， 可以是直接竞争对手，也可以不是。</li></ul><h2 id="功能规格"><a href="#功能规格" class="headerlink" title="功能规格"></a>功能规格</h2><p>应用不当的功能规格说明书不如没有，浪费写的时间，也浪费阅读时间。这也是它名声差的原因。但实施过程中事情会发生变化，这很正常，不应该成为否认它的理由。</p><p>正确的功能规格说明书首先需要简介，足够清楚和准确。不需要包含产品的每一个细节，只需要包含设计或开发过程中有可能混淆的功能定义。其次也不需要展望产品未来的理想化状态，只需要记录在创建这个产品时已经确定下来的决议。</p><p>有几个规则对于撰写规格说明书是通用的：</p><ul><li>乐观。描述如何防止不好的情况发生而不是描述不应该做不好的事情。 如使用“如果用户想买一个没有线的风筝，系统应该引导用户到风筝线的页面” 而不是 “系统不允许用户购买没有线的风筝。”</li><li>具体，避免产生混淆。 如 使用“上一周被播放最多的视频要显示在列表的最前端” 而不是 “最受欢迎的视频要重点关注。”</li><li>避免主观的语气。 如使用 “网站的外观应该符合企业的品牌指南文档的要求” 而不是 “这个网站的风格应该是时尚、闪耀的”。</li></ul><h2 id="内容需求"><a href="#内容需求" class="headerlink" title="内容需求"></a>内容需求</h2><p>很多时候我们说的内容指的是文本，但随着 web 的发展，现在图像和音频视频内容已经越来越重要了，ins，抖音都是例子。</p><p>内容特性的规模会极大影响你对用户体验的决策。所以要做出最明智的决策，你就需要对内容的特性规模有一个大致的预估，这包括文本的子树、图片的大小、音频视频的长度和大小等。</p><p>另外，尽早地确定内容元素的负责人也是重要的。因为内容是一件艰苦的工作，内容从哪里来，谁来维护，如何更新，更新频率如何，都是需求的一部分。而且如果你的网站用户群体比较多，那你就要搞清楚这些不同用户群体需要的内容差异性是什么，因为给孩子看的内容和给孩子的父母看的内容明显是完全不同的。而“为所有人准备的内容”则应该是第三种处理方式。</p><h2 id="确定需求优先级"><a href="#确定需求优先级" class="headerlink" title="确定需求优先级"></a>确定需求优先级</h2><p>总体来说，收集潜在需求不是特别困难。但判断哪些需求应该包含到实际项目中却并不简单。</p><p>首先，在范围层我们已经有了战略目标，那么我们选择的需求肯定得为了战略目标而服务。但这之间很少有明确的一对一关联。在判断它们是否能够满足战略目标的同时，不要忘记考虑它们本身的可行性以及开发需要花费的时间成本。</p><p>如果我们的已经为战略目标制定来优先顺序，这会使我们确定需求的优先级容易很多。</p><p>但有时，不同战略目标间很难衡量重要程度，这种时候，哪个特性将纳入项目范围，往往取决于企业的政治局面。</p><p>当你在与管理层沟通战略时，他们可能不可避免地更偏向于谈论产品特性，你需要引导他们到战略因素上去。但管理层有自己的主观意见，所以某些特性总是会占上风，所以，需求定义的过程不可避免地编程了与管理层和进行谈判的过程。此时最好的方法就是要求“制定战略”。关注战略目标，而不是实现的手段。向决策者保证他所关注的特征可以用另外一种方式来满足，肯定他的意见，是解决冲突的关键，所以，沟通对于技术人员还是非常重要的。</p><h1 id="5-结构层"><a href="#5-结构层" class="headerlink" title="5.结构层"></a>5.结构层</h1><p>到此我们对产品将会包括什么特性已经有了清楚的图像。但这些需求并没有说明如何将这些分散的片段组成一个整体。这就是结构层要做的事情。</p><p>功能产品中“为用户设计结构化体验的方法”被成为<strong>交互设计</strong>。内容建设方面则是通过<strong>信息架构</strong>来构建用户体验。<br>二者都强调一个重点：确定各个将要呈现给用户的元素的<strong>模式</strong>和<strong>顺序</strong>。</p><h2 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h2><p>一般来说，技术人员的思维更容易偏向创造出 技术上效率很高的产品，但忽略来什么才是对用户而言最好的系统，这样的产品使用起来复杂而混乱。 所以，交互设计就逐渐被抬上桌面，<strong>与其针对及其的最佳工作方式来设计系统，还不如设计一个对用户而言最好的系统</strong>。</p><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>首先是使用概念模型。在设计某个特性的时候，考虑将之处理为用户所熟悉的某个概念，比如对应现实中存在的某个物品和模型，或者其它用户熟悉的概念。这样会使得用户在使用时对网站功能的期望符合他们的直觉，无形之中减少了用户对产品的学习成本。</p><p>举个栗子，各个购物网站的结账页面所采用的概念模型就是“购物车”。 作为一个购物车，我们就应该具备向之“添加”和“移除”物品的功能，这也满足我们对于它的期待。</p><p>但概念模型不必明确的告诉用户，它主要用于在交互设计的开发过程中保持使用方式的一致性。用户使用网站基本是凭直觉的，所以理想情况是我们的网站的交互行为与他们隐含的期望值完全相符合。 所以，了解用户对于网站模式的想法变得很重要，这可以帮助我们找出什么是最合适的概念模型。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>其次是错误处理，任何一个交互设计的产品都无法避免用户的“错误操作”。当用户犯错时系统要如何反应，当错误已经发生，系统如何防止用户继续犯错？这些也是交互设计的重要部分。</p><p>比较简单的一种错误可以直接通过将之在系统层面做成规则得以避免，即不给用户做出错误操作的机会。比如在汽车挂在任何非停车档位时，不允许启动汽车。也就避免了因此可能造成的错误。</p><p>不幸的是并不是所有错误都如此简单，当错误真的发生，系统应该帮助用户找出错误并改正它们，但切忌“操之过急”，记得 word 的自动改正功能吗，这就是典型的好心办了坏事。<br>还有些一旦犯错就无法纠正的情况，一种解决方法就是提供类似“撤销”的功能。<br>对于另外那些无法恢复的操作，提供大量的警告是系统唯一可提供的预防方式，但这些警告也只有在用户注意到时才有用，大量的警告可能会让用户忽略了真正重要的那一个，so，还是那句话，切忌“操之过急”。</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/error-handle.png" srcset="/img/loading.gif" class="" title="错误处理"><h2 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h2><p>信息架构研究的是人们如何认知信息的过程。对于网站产品，它关注的是呈现给用户的信息是否合理并且具有意义。</p><p>在以内容为主的网站上，信息架构主要的工作是设计组织分类和导航的结构，从而让用户可以高效率地浏览网站的内容。</p><p>信息架构要求创建分类体系。创建分类可以<strong>从上而下</strong>：根据战略层目标从最广泛的、有可能满足决策目标的内容和功能开始进行分类。缺点是可能导致内容的细节被忽略。<br>可以<strong>从下而上</strong>：即从已有资料出发，将它们放到最低一级类别中，再接着往上归属到更高的类别，以此类推。缺点是可能对当前内容过拟合，不便于容纳未来内容。<br>so，平衡。</p><h3 id="结构方法"><a href="#结构方法" class="headerlink" title="结构方法"></a>结构方法</h3><p>一个高效结构的优点是具备“容纳和适应变动”的能力。信息架构的基本单位是<strong>节点</strong>。节点可以小到一个页面元素，可以大到是一个系统，这根据你架构的对象变化。它是我们考虑架构的最小单位，也就是说此时如果你的节点是一个系统，那么这个系统内部在这次设计过程中你不需要考虑，这样更容易让你理清思路。</p><p>常见的几种结构类型：</p><ul><li><strong>层级结构(hierarchical structure)</strong>，或叫做<strong>树状结构(tree)</strong> 或者 <strong>中心辐射(hub-sub-spoke)</strong>。</li><li><strong>矩阵结构</strong>：允许用户在节点与节点间沿着两个或更多的维度移动，但维度最好不要太多。</li><li><strong>自然结构</strong>：没有固定模式，节点是逐一被连接的，也没有太强烈的分类的概念。对于坍缩一系列关系不明确或者经常演变的主题比较适合。比如娱乐或教育网站。</li><li><strong>线性结构</strong>。</li></ul><p>内容往往有很多的<strong>截面</strong>,即不同的属性。同样的一种商品，一些用户更看重价格，一些更看重大小，一些则更看重重量，这种情况，将所有截面都提供给用户，让他们自己去筛选和排列自己想要的结果似乎是不错的选择，但这其实是一种不负责任的表现，将负担扔给了用户，这会导致没人能找到自己想要的东西。审视你的战略目标和范围内的需求，识别出哪些是对于你的用户最重要的信息和截面，并提供他们的期望，才是正确的做法。</p><h3 id="语言和元数据"><a href="#语言和元数据" class="headerlink" title="语言和元数据"></a>语言和元数据</h3><p>网站中的各种用语和名词也是决定用户是否能弄清楚你的网站的重要部分。如果你的网站充斥着大量的专业术语和技术用语，可想而知用户使用起来有多么困难。</p><p>故而，“使用用户的语言”和“保持一致性”是非常重要的，我们把用来强调一致性的工具成为<strong>受控词典(controlled vocabulary)</strong>。它是用户研究中一个重要的领域，与用户谈话并了解他们的沟通方式是得到受控词典的最有效方式。</p><p>另一方面，内容或信息本身具备的信息—元数据，对于用户体验也有非常大的帮助。举个例子，小说网站的内容是一篇篇的小说，元数据则是小说的信息，比如作者，小说类型，字数，男频还是女频，文学性强弱等，在现在我们更喜欢称之为数据的维度。他们的作用自不必说，简单的用法是用来筛选和搜索，复杂点则可以结合深度学习和机器学习来做内容的精准推荐(比如淘宝的商品推荐，抖音的视频推荐等)。</p><p>扩展一下，元数据本身的来源，最容易想到的肯定是人为进行标记，也是目前大多内容产品的处理方式。但得益于深度学习和机器学习的能力，如今我们可以通过类似机器学习中协同过滤，因式分解，逻辑回归，深度学习中 MLP 甚至更复杂的模型来自动的对内容进行分类和元数据标记。</p><h3 id="产出"><a href="#产出" class="headerlink" title="产出"></a>产出</h3><p>除开命名原则和元数据的细节，信息架构或交互设计产出的主要文档是示意图。视觉化的呈现结构，是表述“分支、群组、组件之间关系”的一种最高效方式，称之为<strong>架构图</strong>。</p><p><strong>架构图</strong>最重要的是记录概念关系：哪些类别需要放一起，哪些需要保持独立，在交互过程中各个步骤要怎样相互配合？</p><p>对于绘制网站的构思作者创建来一种图解网站结构的方法，叫做<strong>视觉辞典(visual vocabulary)</strong>。<a href="http://www.jjg.net/ia/visvocab/chinese.html/" target="_blank" rel="noopener">作者的网站</a>有详细介绍。</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/visual-vocabulary.jpg" srcset="/img/loading.gif" class="" title="视觉辞典"><p>PS：将决定网站信息架构或交互设计的责任明确的落到一个人身上非常重要，这保证了它被当作来一件有意识的工作。至于他是一位专职的“交互设计师”来做，还是变成某个项目负责人、某个公共关系部门的员工或者某个技术负责人工作的一部分取决于你公司或者团队的实际情况。</p><h1 id="6-框架层"><a href="#6-框架层" class="headerlink" title="6.框架层"></a>6.框架层</h1><p>在充满概念的结构层中开始形成了大量的需求，这些需求都是来自我们的战略目标的需求。在框架层，我们要进一步提炼这些结构，确定很详细的界面外观、导航和信息设计。</p><p>结构层界定来我们的产品将使用什么方式来运作；框架层则用于确定用什么样的功能和形式来实现。在这里，我们的关注点几乎全部在独立的组件以及他们之间的相互关系上。</p><p>功能产品需要界面设计，即各种功能元素(按钮、输入框、选择框等)的布局和联系。信息产品则对应导航设计，而信息设计则是二者都需要做的，用于呈现有效的信息沟通。在一个网站中，这三者非常紧密的结合在一起，但将他们分开进行考虑，更方便我们理清楚逻辑。</p><ol><li>涉及提供给用户<strong>做某些事</strong>的能力，就属于界面设计。通过它，用户真正接触到网站的“功能”。</li><li>提供给用户<strong>去某个地方</strong>的能力，就属于导航设计。通过它，用户可以在结构中自由穿行。</li><li><strong>传达想法</strong>给用户，则属于信息设计。算是以上二者的基础。</li></ol><p>一些注意点：</p><ol><li>尽量不要“特立独行”，很多时候用户已经在其它地方养成来非常根深蒂固的用户习惯。在没有特殊原因和非常明显的收益时，不要去违背它。比如九宫格键盘的模式，你没必要在你的网站上做一个 12 宫格。</li><li>不要滥用比喻，在结构层中我们说过，不要过于强调概念模型。对于比喻也是如此，网站产品毕竟不同于现实中的概念，比如你放了一个电话图片希望通过比喻告诉用户可以点击它获取联系方式，但用户大概率会感到困惑,”这是啥？电话簿？语音信箱？还是可以直接打电话？”。 尽量去除这些会让用户猜测的行为。</li></ol><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>一个任务通常都会跨越多个界面来完成，每个界面都包含一组不同的界面元素。哪个功能要在哪个界面上完成，是我们在结构层的交互设计中已经决定的，而这些功能在界面上如何被用户所认知到，则属于界面设计的范畴。</p><p>成功的界面设计是那些能让用户一眼就看到“最重要的东西”的界面设计。反之，设计复杂系统的界面面临的最大挑战之一，就是弄清楚用户不需要知道哪些恭喜，并减少它们的可发现性。</p><p>这与程序设计不同，写代码时我们会考虑各种边际状况，好的程序员总是平等地对待每种可能性，不管它代表的是一个用户还是 1000 个。但这对界面设计师行不通的。一个设计良好的界面是要组织好用户最常采用的行为，同时让这些界面元素用最容易的方式获取和使用。 有些系统会给一些元素设置默认值，就是出于“大多数用户会填写这个值”的原因。</p><p>其次就是界面上元素的设计，现在我们更多的将他们称作“组件库”。市面上有非常多开源的组件库，大多数团队为了节约开发时间也会从中进行选择，这些组件库大多具有不同的 UI 和使用体验。比如同样的一个复选框，有的可能会占用空间更多，但用户却更好理解其行为。根据你产品的特点，从中作出权衡是不可避免的。</p><h2 id="导航设计"><a href="#导航设计" class="headerlink" title="导航设计"></a>导航设计</h2><p>任何一个网站的导航设计都必须同时完成三个目标：</p><ol><li>比如提供给用户一种在网站间跳转的方法。</li><li>必须传达出这些元素和它们所包含内容之间的关系。仅仅提供一个链接的列表是不够的，这些链接相互之间有什么关系？是否其中一些比别的更重要？它们之间相关的差异在哪？ 这能够帮助用户理解“哪些选择对他们是有效的”。</li><li>必须传达出它的内容和用户当前浏览页面之间的关系。 这能帮助用户理解“那个有效的选择会更好的支持它们的任务或他们想要达到的目标”。</li></ol><p>在实践过程中涌现了几种常见的导航系统：</p><ul><li>全局导航，类似网页顶部的导航栏、手机网站底部的 bar。</li><li>局部导航：提供给用户到达“附近地点”的通路。比如到达页面父级、兄弟级、子级的通路。</li><li>辅助导航：提供前面二者不能快速到达的相关内容的快捷途径，类似快捷方式。</li><li>上下文导航：比如内容文字中的超链接</li><li>友好导航：用户通常不会使用，但在确实需要时能够快速有效的帮助到他们的导航。比如联系信息、反馈表单和法律声明等。</li><li>远程导航：不在你网站的页面结构中而在外部，提供网站功能或者页面的目录或者索引的导航。</li></ul><h2 id="信息设计"><a href="#信息设计" class="headerlink" title="信息设计"></a>信息设计</h2><p>常常充当一种把各种设计元素聚合到一起的黏合剂的角色，决定如何呈现这些信息，使人们容易使用和理解。</p><p>有时候是视觉上的，比如确定使用柱状图还是饼状图来展示某数据，确定用望远镜还是放大镜来表示网站中“搜索”的概念。<br>有时候涉及信息的“分组”和“整理”。比如表单项目的排列顺序和分类。</p><p>不管什么时候，系统都应该给用户提供能正确使用系统的信息(无论是用户出现了错误还是刚开始使用),这都是信息设计的工作范畴。</p><h2 id="线框图"><a href="#线框图" class="headerlink" title="线框图"></a>线框图</h2><p>将信息设计、界面设计和导航设计放置到一起，形成一个统一的、有内在凝聚力的架构 就叫做<strong>页面布局</strong>。将之纳入一个详细的文档，就是页面示意图或者<strong>线框图</strong>(wire frame)。线框图是对一个页面中所有的组成部分以及它们如何组合到一起的最直观的描述。</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/wireframe.jpg" srcset="/img/loading.gif" class="" title="线框图示例"><p>线框图一般要着重注明、建议读者在必要的时候参考结构图表或 qi’taUS 和即文档、内容需求或功能规格说明，或者其他类型的详细文档。</p><p>在正是建立网站的视觉设计的流程中，线框图是必要的第一步。它作为信息架构和视觉设计汇集的地方，是争论和纠纷的中心。不同的角色都会对其中的一部分表示难以理解或者觉得有问题。解决的唯一办法是“协作”。</p><p>但记住，文档只是达到目的的手段而不是目的本身，所以，相比于花大量时间绘制一个面面俱到且精致的线框图，不如一个对于你的团队来说刚刚好的版本。比如对于一个设计师和程序员都在一起的小团队，也许一张张花在便签上的简易线框图就够用了，而对于那种大型团队，或者跨区域合作的团队，可能就需要更加正式的文档了。</p><p>总之，线框图是整合在框架层的全部三种要素的方法。</p><ul><li>通过安排和选择界面元素来整合界面设计。</li><li>通过识别和定义核心导航系统来整合导航设计。</li><li>通过放置和排列信息组成部分的优先级来整合信息设计。</li></ul><p>将三者放到一个文档中，线框图就可以确定一个建立在基本概念结构上的架构，同时指出了表现层的设计应该前进的方向。</p><h1 id="7-表现层"><a href="#7-表现层" class="headerlink" title="7.表现层"></a>7.表现层</h1><p>最终，我们终于来到了最后一层。在这里，内容、功能和美学汇集到一起来产生一个最终设计，完成其他四个层面的所有目标，并同时满足用户的感官感受。</p><p>在表现层，我们要在这里解决并弥补“产品框架层的逻辑排布”的感知呈现问题。在上一层的信息设计中，我们决定来信息元素应该如何分组和排列，在表现层的视觉设计中，我们则要决定这种安排在视觉上应该如何呈现。</p><h2 id="合理设计感知"><a href="#合理设计感知" class="headerlink" title="合理设计感知"></a>合理设计感知</h2><p>我们的设计要如何被人类的感觉器官感受到？这主要由五个方面组成：视觉、听觉、触觉、嗅觉和味觉。</p><p>除了食物和一些香味产品外，嗅觉和味觉在产品设计中基本是很少考虑的。</p><p>触觉主要还是工业设计领域的概念，当然，现在移动设备等都有震动等功能，也开始有了一些触觉交互。</p><p>声音在产品中的应用比较广泛，汽车的各种警示声，微波炉的各种通知声等。</p><p>视觉，则是我们要阐述的重点。也是用户体验设计师最擅长的领域。美感是一个比较主观的的东西，直接用“好看，酷”来评估一个视觉设计方案是不太合适的。我们应该结合我们在前面各个层面确定的目标，来看一个视觉设计对它们的支持如何。例如，产品的外观有没有破坏结构，有没有使结构中的各个模块间的区别变得不清晰？或者，外观有没有强化结构，使用户的可用选项清楚明了？</p><p>再比如传达品牌的形象。视觉设计师传达品牌形象的最主要工具之一。你能想象一个政府机构的网站却充满了漫画字体和各种明亮浮夸的配色么。</p><p>评估产品视觉设计最简单的方法之一，就是回答一个问题：当你看到产品，你的视线首先落在什么地方？这些东西是对于你的战略目标最重要的东西吗？ 简单的询问测试者和用户是最好的获得答案的方式。</p><p>一个成功的设计，用户眼睛的移动轨迹应该有 2 个特点：</p><ol><li>它们遵循一条流畅的路径。 反之则是混乱和拥挤，眼睛在各个页面元素间跳来跳去，所有的元素都在试图引起注意。</li><li>不需要太多细节来吓到用户，且为用户提供有效的引导。</li></ol><p>用户在界面上的视线移动并不是随机的，它是一种人类共有的、对于视觉刺激而产生的、一系列复杂的原始本能反应。对于设计师而言，这些反应并不是完全无法控制的。我们已经发展出了各种各样有效的视觉手段来吸引或者分散注意力。</p><h3 id="对比和一致性"><a href="#对比和一致性" class="headerlink" title="对比和一致性"></a>对比和一致性</h3><p>当一个元素在设计中显得与众不同的时候，用户就会注意到。这就是<strong>对比</strong>。你可以利用这个本能搞得行为来使用户注意到那些“你需要让用户注意到的相对更重要的东西”。比如通过给文本一些不同的颜色(比如红色)或者用一个醒目的图形将之凸显，就能达到这个目的。总之，总体的策略就是让这个“差异”足够清晰。</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/contrast.jpg" srcset="/img/loading.gif" class="" title="对比"><p>一致性也很重要，类似的场景你如果使用了完全不同的视觉处理，就会让用户感到困惑。比如视觉元素大小的一致性等。</p><p><strong>基于栅格线布局</strong>(grid-based layout)是一种通过使用“母板”来确保设计一致性的方法。</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/grid_layout.jpg" srcset="/img/loading.gif" class="" title="栅格布局"><p>PS：不要掉进“坚持使用栅格系统(或任何一种可以保持一致性的标准)”的陷阱。因为有一些情况下，他们可能行不通。</p><h3 id="内部和外部的一致性"><a href="#内部和外部的一致性" class="headerlink" title="内部和外部的一致性"></a>内部和外部的一致性</h3><p>产品在两个不同地方反映了不同的设计方法，这是内部一致性问题。<br>这个产品和公司的其它产品在设计方法上不一致，这是外部一致性的问题。</p><p>这也是现在网页设计前端频繁提到“组件库”的原因。因为一个统一完整的组件库，在很大程度上解决了上述的两个问题。</p><p>一个好的组件库，不仅每个视觉元素被相对独立且风格统一的设计，且被放到一起的时候，也能显得统一连贯且有凝聚力。</p><h3 id="配色方案和排版"><a href="#配色方案和排版" class="headerlink" title="配色方案和排版"></a>配色方案和排版</h3><p>色彩可以很大程度向外界传递品牌识别，比如可口可乐的红，淘宝的橙等。 核心的品牌色彩通常是一个更广泛的配色方案(color palette)。它应在企业的所有产品和材料中得到应用的，挑选并整合这些色彩，以便于将之进行更广泛的应用。</p><p>在大多数情况下，更亮或者醒目的色彩可用于设计你的前景色，即那些更希望被用户注意的元素。而黯淡的色彩则最好用于那些相对次要的背景元素中。</p><p>另一方面，对于某些企业，排版和字体也非常重要。</p><h2 id="设计合成品和风格指南"><a href="#设计合成品和风格指南" class="headerlink" title="设计合成品和风格指南"></a>设计合成品和风格指南</h2><p>视觉设计中对线框图最直接的模拟是<strong>视觉模型</strong>(visual mock-up)或<strong>设计合成品</strong>(design comp)。它就是一个最终的可视化产品。从线框图和设计合成品的组件之间，应该有一个简单的一对一关系。 但合成品不一定忠实再现了线框图的布局。 线框图并没有说明视觉设计的关注点，而是侧重于记录框架层。线框图是为了让我们能够独立地了解到框架层的问题，然后再去关系到表现层的问题。 它的核心概念尤其是信息设计方面应该显著地呈现在设计合成品中。</p><img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/design_comp.jpg" srcset="/img/loading.gif" class="" title="设计合成品"><p>总之，整本书都在强调，虽然文档是大量的工作。但它们是值得的，这里再增加一个理由：随着时间推移，我们的决策原因会逐渐从记忆中消失，解决特定情况的临时决策和有意识并应该一贯坚持的决策将会混杂在一起。 其次，人们最后都会离开这个工作，也许是产品周期结束，也许是人的离职。如果没有一个保留每一次梗概、符合最新的标准和惯例的风格指南，这些知识就丢失了。</p><p>承载这些设计决策的文档是<strong>风格指南</strong>(style guide)。它确定来视觉设计的每个方面，各个视觉元素、组件，影响到产品的每一个局部的标准(比如布局、配色、字体等)。它还要包括某一个模块或者网站功能的具体标准。</p><p>风格指南的总体目标是提供足够的细节来帮助人们将来做出明智的决策，因为大部分的想法都已经实现了。</p><h1 id="要素的应用"><a href="#要素的应用" class="headerlink" title="要素的应用"></a>要素的应用</h1><p>至此，阐述完了所有的理论。然而要将这些要素背后的想法付诸实施却试一次挑战，不仅仅是时间和资源的问题，很多时候，它还是一个心态的问题。</p><p>回头来看这五个层面，创建良好的用户体验最重要的工作内容是大量收集亟待解决的问题。“成功的方法”和“注定失败的方法”的差异归根结底就是两点：</p><ol><li><strong>了解你正在试着去解决的问题。</strong> 假如你已经知道主页的那个紫色的按钮是个问题，那么是它太大来还是颜色不对(表现层)？ 是这个按钮所在的页面位置不对？(框架层)？ 还是这个按钮所代表的功能不是用户所期望的(结构层)？</li><li><strong>了解这些解决办法所造成的后果。</strong>。 你的每个决策都会对上下的层面造成连锁反应，务必考虑周全，避免拆东墙补西墙。<img src="/2020/07/16/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/think_all_five.jpg" srcset="/img/loading.gif" class="" title="同时考虑五个层面"></li></ol><p>其次，大多数导致用户体验问题的决策出现在几个场景中：</p><ul><li><strong>由现状决定的设计</strong> 即有时候引文时间、技术等原因使用的临时方案。</li><li><strong>由模仿决定的设计</strong></li><li><strong>由领导决定的设计</strong></li></ul><p>在进行用户体验设计的时候，一个常见的错误就是以“节省项目时间或金钱”的名义对用户体验问题敷衍了事。或者在项目的最后来增加“用户体验评估”，而最恰当的时机已经过去了。</p><p>用户体验设计应该是一场马拉松而不是短跑。 企业中永远处在紧急状况下的开发团队太多了。似乎每个项目都是对某些被察觉的危机的回应。这样的结果就是每一个项目在它刚刚开始的时候就已经落后于计划了。</p><p>经过深思熟虑的设计决策，可能会在短期内花费一定的时间，但是它们将在一个更长时期中节省更多的时间。所以，尽管本书介绍的五个层次有的层次的产出似乎并没有类似表现层的实际的视觉效果，但它们依然不可或缺。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>产品</category>
      
    </categories>
    
    
    <tags>
      
      <tag>产品</tag>
      
      <tag>用户体验</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React官方文档知识点-Context和Hook</title>
    <link href="/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-Context%E5%92%8CHook/"/>
    <url>/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-Context%E5%92%8CHook/</url>
    
    <content type="html"><![CDATA[<p>之前的进阶中其实有Context的内容，不过那里跳过了，但Hook的一些API涉及到Context的操作。所以先熟悉一下Context的内容。<br>Hook算是React中比较新的一个特性，配合Context，这让我们在管理状态的时候更加的方便，在很多情况下，如果你的应用不是那么复杂，你甚至可以放下redux。当然这一点比较见仁见智。</p><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="hljs plain">&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。const ThemeContext &#x3D; React.createContext(&#39;light&#39;);class App extends React.Component &#123;  render() &#123;    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。    return (      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;        &lt;Toolbar &#x2F;&gt;      &lt;&#x2F;ThemeContext.Provider&gt;    );  &#125;&#125;&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。function Toolbar() &#123;  return (    &lt;div&gt;      &lt;ThemedButton &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;class ThemedButton extends React.Component &#123;  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。  static contextType &#x3D; ThemeContext;  render() &#123;    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;  &#125;&#125;</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><pre><code class="hljs plain">const MyContext &#x3D; React.createContext(defaultValue);</code></pre><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p><p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。</p><h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h3><pre><code class="hljs plain">&lt;MyContext.Provider value&#x3D;&#123;&#x2F;* 某个值 *&#x2F;&#125;&gt;</code></pre><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p>Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><p>通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p><h3 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h3><pre><code class="hljs plain">class MyClass extends React.Component &#123;  componentDidMount() &#123;    let value &#x3D; this.context;    &#x2F;* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 *&#x2F;  &#125;  componentDidUpdate() &#123;    let value &#x3D; this.context;    &#x2F;* ... *&#x2F;  &#125;  componentWillUnmount() &#123;    let value &#x3D; this.context;    &#x2F;* ... *&#x2F;  &#125;  render() &#123;    let value &#x3D; this.context;    &#x2F;* 基于 MyContext 组件的值进行渲染 *&#x2F;  &#125;&#125;MyClass.contextType &#x3D; MyContext;</code></pre><p>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</p><p>如果你正在使用实验性的 public class fields 语法，你可以使用 static 这个类属性来初始化你的 contextType。</p><pre><code class="hljs plain">class MyClass extends React.Component &#123;  static contextType &#x3D; MyContext;  render() &#123;    let value &#x3D; this.context;    &#x2F;* 基于这个值进行渲染工作 *&#x2F;  &#125;&#125;</code></pre><p>如果是函数式组件，则可以使用：</p><pre><code class="hljs plain">&lt;MyContext.Consumer&gt;  &#123;value &#x3D;&gt; &#x2F;* 基于 context 值进行渲染*&#x2F;&#125;&lt;&#x2F;MyContext.Consumer&gt;</code></pre><h2 id="更复杂的情形"><a href="#更复杂的情形" class="headerlink" title="更复杂的情形"></a>更复杂的情形</h2><h3 id="动态Context"><a href="#动态Context" class="headerlink" title="动态Context"></a>动态Context</h3><p>对于上面的 theme 例子，使用动态值（dynamic values）后更复杂的用法：<br><strong>theme-context.js</strong></p><pre><code class="hljs plain">import React from &#39;react&#39;;export const themes &#x3D; &#123;    light: &#123;      foreground: &#39;#000000&#39;,      background: &#39;#eeeeee&#39;,    &#125;,    dark: &#123;      foreground: &#39;#ffffff&#39;,      background: &#39;#222222&#39;,    &#125;,  &#125;;    export const ThemeContext &#x3D; React.createContext(    themes.dark &#x2F;&#x2F; 默认值  );</code></pre><p><strong>themedButton.js</strong></p><pre><code class="hljs plain">import React,&#123;Component&#125; from &#39;react&#39;import &#123;ThemeContext&#125; from &#39;.&#x2F;theme-context&#39;;class ThemedButton extends React.Component &#123;  render() &#123;    let props &#x3D; this.props;    let theme &#x3D; this.context;    return (      &lt;button        &#123;...props&#125;        style&#x3D;&#123;&#123;backgroundColor: theme.background&#125;&#125;      &#x2F;&gt;    );  &#125;&#125;ThemedButton.contextType &#x3D; ThemeContext;export default ThemedButton;</code></pre><p><strong>App.js</strong></p><pre><code class="hljs plain">&#x2F;&#x2F; 一个使用 ThemedButton 的中间组件function Toolbar(props) &#123;  return (    &lt;ThemedButton onClick&#x3D;&#123;props.changeTheme&#125;&gt;      Change Theme    &lt;&#x2F;ThemedButton&gt;  );&#125;export default class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123;      theme: themes.light,    &#125;;    this.toggleTheme &#x3D; () &#x3D;&gt; &#123;      this.setState(state &#x3D;&gt; (&#123;        theme:          state.theme &#x3D;&#x3D;&#x3D; themes.dark            ? themes.light            : themes.dark,      &#125;));    &#125;;  &#125;  render() &#123;    &#x2F;&#x2F; 在 ThemeProvider 内部的 ThemedButton 按钮组件使用 state 中的 theme 值，    &#x2F;&#x2F; 而外部的组件使用默认的 theme 值    return (      &lt;&gt;        &lt;ThemeContext.Provider value&#x3D;&#123;this.state.theme&#125;&gt;          &lt;Toolbar changeTheme&#x3D;&#123;this.toggleTheme&#125; &#x2F;&gt;        &lt;&#x2F;ThemeContext.Provider&gt;        &lt;div&gt;          &lt;ThemedButton &#x2F;&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;&gt;    );  &#125;&#125;</code></pre><h3 id="在嵌套组件中更新Context"><a href="#在嵌套组件中更新Context" class="headerlink" title="在嵌套组件中更新Context"></a>在嵌套组件中更新Context</h3><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context。实际就是将某个高层组件的某个深层组件要用到的state和控制state变化的函数作为context，然后不需要一层一层传递，底层组件通过Consumer来获取</p><p><strong>theme-context.js</strong></p><pre><code class="hljs plain">&#x2F;&#x2F; 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！export const ThemeContext &#x3D; React.createContext(&#123;  theme: themes.dark,  toggleTheme: () &#x3D;&gt; &#123;&#125;,&#125;);</code></pre><p><strong>theme-toggler-button.js</strong></p><pre><code class="hljs plain">import &#123;ThemeContext&#125; from &#39;.&#x2F;theme-context&#39;;function ThemeTogglerButton() &#123;  &#x2F;&#x2F; Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数  return (    &lt;ThemeContext.Consumer&gt;      &#123;(&#123;theme, toggleTheme&#125;) &#x3D;&gt; (        &lt;button          onClick&#x3D;&#123;toggleTheme&#125;          style&#x3D;&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt;          Toggle Theme        &lt;&#x2F;button&gt;      )&#125;    &lt;&#x2F;ThemeContext.Consumer&gt;  );&#125;export default ThemeTogglerButton;</code></pre><p><strong>app.js</strong></p><pre><code class="hljs plain">import &#123;ThemeContext, themes&#125; from &#39;.&#x2F;theme-context&#39;;import ThemeTogglerButton from &#39;.&#x2F;theme-toggler-button&#39;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.toggleTheme &#x3D; () &#x3D;&gt; &#123;      this.setState(state &#x3D;&gt; (&#123;        theme:          state.theme &#x3D;&#x3D;&#x3D; themes.dark            ? themes.light            : themes.dark,      &#125;));    &#125;;    &#x2F;&#x2F; State 也包含了更新函数，因此它会被传递进 context provider。    this.state &#x3D; &#123;      theme: themes.light,      toggleTheme: this.toggleTheme,    &#125;;  &#125;  render() &#123;    &#x2F;&#x2F; 整个 state 都被传递进 provider    return (      &lt;ThemeContext.Provider value&#x3D;&#123;this.state&#125;&gt;        &lt;Content &#x2F;&gt;      &lt;&#x2F;ThemeContext.Provider&gt;    );  &#125;&#125;function Content() &#123;  return (    &lt;div&gt;      &lt;ThemeTogglerButton &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;ReactDOM.render(&lt;App &#x2F;&gt;, document.root);</code></pre><h3 id="消费多个Context"><a href="#消费多个Context" class="headerlink" title="消费多个Context"></a>消费多个Context</h3><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p><pre><code class="hljs plain">&#x2F;&#x2F; Theme context，默认的 theme 是 “light” 值const ThemeContext &#x3D; React.createContext(&#39;light&#39;);&#x2F;&#x2F; 用户登录 contextconst UserContext &#x3D; React.createContext(&#123;  name: &#39;Guest&#39;,&#125;);class App extends React.Component &#123;  render() &#123;    const &#123;signedInUser, theme&#125; &#x3D; this.props;    &#x2F;&#x2F; 提供初始 context 值的 App 组件    return (      &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;        &lt;UserContext.Provider value&#x3D;&#123;signedInUser&#125;&gt;          &lt;Layout &#x2F;&gt;        &lt;&#x2F;UserContext.Provider&gt;      &lt;&#x2F;ThemeContext.Provider&gt;    );  &#125;&#125;function Layout() &#123;  return (    &lt;div&gt;      &lt;Sidebar &#x2F;&gt;      &lt;Content &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;&#x2F;&#x2F; 一个组件可能会消费多个 contextfunction Content() &#123;  return (    &lt;ThemeContext.Consumer&gt;      &#123;theme &#x3D;&gt; (        &lt;UserContext.Consumer&gt;          &#123;user &#x3D;&gt; (            &lt;ProfilePage user&#x3D;&#123;user&#125; theme&#x3D;&#123;theme&#125; &#x2F;&gt;          )&#125;        &lt;&#x2F;UserContext.Consumer&gt;      )&#125;    &lt;&#x2F;ThemeContext.Consumer&gt;  );&#125;</code></pre><p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>上面之所以要将值放到高层组件的state中，是因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。</p><h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><h2 id="诞生原因"><a href="#诞生原因" class="headerlink" title="诞生原因"></a>诞生原因</h2><ul><li>在组件之间复用状态逻辑很难</li><li>复杂组件变得难以理解<br>我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</li><li>难以理解的 class<br>Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>先看个例子</p><pre><code class="hljs plain">import React, &#123; useState &#125; from &#39;react&#39;;function Example() &#123;  &#x2F;&#x2F; 声明一个叫 “count” 的 state 变量。  const [count, setCount] &#x3D; useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。<br>useState 唯一的参数就是初始 state。不同于 this.state，这里的 state 不一定要是一个对象.</p><p><strong>声明多个state变量</strong></p><pre><code class="hljs plain">function ExampleWithManyStates() &#123;  &#x2F;&#x2F; 声明多个 state 变量！  const [age, setAge] &#x3D; useState(42);  const [fruit, setFruit] &#x3D; useState(&#39;banana&#39;);  const [todos, setTodos] &#x3D; useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);  &#x2F;&#x2F; ...&#125;</code></pre><p><strong>什么是Hook</strong><br>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。（我们不推荐把你已有的组件全部重写，但是你可以在新组件里开始使用 Hook。）</p><p>React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们先介绍这些内置的 Hook。</p><h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。</p><p>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。</p><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function Example() &#123;  const [count, setCount] &#x3D; useState(0);  &#x2F;&#x2F; 相当于 componentDidMount 和 componentDidUpdate:  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 使用浏览器的 API 更新页面标题    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。</p><p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。</p><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function FriendStatus(props) &#123;  const [isOnline, setIsOnline] &#x3D; useState(null);  function handleStatusChange(status) &#123;    setIsOnline(status.isOnline);  &#125;  useEffect(() &#x3D;&gt; &#123;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;    return &#39;Loading...&#39;;  &#125;  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;&#125;</code></pre><p>跟 useState 一样，你可以在组件中多次使用 useEffect。<br>通过使用 Hook，你可以把组件内相关的副作用组织在一起（例如创建订阅及取消订阅），而不要把它们拆分到不同的生命周期函数里。</p><h2 id="hook使用规则"><a href="#hook使用规则" class="headerlink" title="hook使用规则"></a>hook使用规则</h2><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p><ul><li>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</li></ul><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>有时候我们会想要在组件之间重用一些状态逻辑。目前为止，有两种主流方案来解决这个问题：高阶组件和 render props。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的。</p><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function useFriendStatus(friendID) &#123;  const [isOnline, setIsOnline] &#x3D; useState(null);  function handleStatusChange(status) &#123;    setIsOnline(status.isOnline);  &#125;  useEffect(() &#x3D;&gt; &#123;    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);    &#125;;  &#125;);  return isOnline;&#125;</code></pre><p>现在我们可以在两个组件中使用它：</p><pre><code class="hljs plain">function FriendStatus(props) &#123;  const isOnline &#x3D; useFriendStatus(props.friend.id);  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;    return &#39;Loading...&#39;;  &#125;  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;&#125;</code></pre><pre><code class="hljs plain">function FriendListItem(props) &#123;  const isOnline &#x3D; useFriendStatus(props.friend.id);  return (    &lt;li style&#x3D;&#123;&#123; color: isOnline ? &#39;green&#39; : &#39;black&#39; &#125;&#125;&gt;      &#123;props.friend.name&#125;    &lt;&#x2F;li&gt;  );&#125;</code></pre><p>这两个组件的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。</p><p>自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 useSomething 的命名约定可以让我们的 linter 插件在使用 Hook 的代码中找到 bug。</p><p>你可以创建涵盖各种场景的自定义 Hook，如表单处理、动画、订阅声明、计时器，甚至可能还有更多我们没想到的场景。我们很期待看到 React 社区会出现什么样的自定义 Hook。</p><h2 id="其它hook"><a href="#其它hook" class="headerlink" title="其它hook"></a>其它hook</h2><p>除此之外，还有一些使用频率较低的但是很有用的 Hook。比如，useContext 让你不使用组件嵌套就可以订阅 React 的 Context。</p><pre><code class="hljs plain">function Example() &#123;  const locale &#x3D; useContext(LocaleContext);  const theme &#x3D; useContext(ThemeContext);  &#x2F;&#x2F; ...&#125;</code></pre><p>另外 useReducer 可以让你通过 reducer 来管理组件本地的复杂 state。</p><p>接下来我们进一步的来看这些API到底做了什么。</p><h2 id="useState方法说明"><a href="#useState方法说明" class="headerlink" title="useState方法说明"></a>useState方法说明</h2><p>调用 useState 方法的时候做了什么? 它定义一个 “state 变量”。我们的变量叫 count， 但是我们可以叫他任何名字，比如 banana。这是一种在函数调用时保存变量的方式 —— useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留。</p><p>useState 需要哪些参数？ useState() 方法里面唯一的参数就是初始 state。不同于 class 的是，我们可以按照需要使用数字或字符串对其进行赋值，而不一定是对象。在示例中，只需使用数字来记录用户点击次数，所以我们传了 0 作为变量的初始 state。（如果我们想要在 state 中存储两个不同的变量，只需调用 useState() 两次即可。）</p><p>useState 方法的返回值是什么？ 返回值为：当前 state 以及更新 state 的函数。这就是我们写 const [count, setCount] = useState() 的原因。这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。</p><p>你不必使用多个 state 变量。State 变量可以很好地存储对象和数组，因此，你仍然可以将相关数据分为一组。然而，不像 class 中的 this.setState，更新 state 变量总是替换它而不是合并它。</p><h2 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h2><p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。我们来更仔细地看一下他们之间的区别。</p><h3 id="无需清除的effect"><a href="#无需清除的effect" class="headerlink" title="无需清除的effect"></a>无需清除的effect</h3><p>有时候，我们只想在 React 更新 DOM 之后运行一些额外的代码。比如<strong>发送网络请求，手动变更 DOM，记录日志</strong>，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。让我们对比一下使用 class 和 Hook 都是怎么实现这些副作用的。</p><p><strong>class</strong>:</p><pre><code class="hljs plain">class Example extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123;      count: 0    &#125;;  &#125;  componentDidMount() &#123;    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;  &#125;  componentDidUpdate() &#123;    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;&#x2F;p&gt;        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;          Click me        &lt;&#x2F;button&gt;      &lt;&#x2F;div&gt;    );  &#125;&#125;</code></pre><p><strong>使用Hook</strong>：</p><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function Example() &#123;  const [count, setCount] &#x3D; useState(0);  useEffect(() &#x3D;&gt; &#123;    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>useEffect 做了什么？ 通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。</p><p>useEffect 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><p>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</p><h3 id="需要清除的effect"><a href="#需要清除的effect" class="headerlink" title="需要清除的effect"></a>需要清除的effect</h3><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 Class 和 Hook 来实现。</p><p>在 React class 中，你通常会在 componentDidMount 中设置订阅，并在 componentWillUnmount 中清除它。</p><p>例如，假设我们有一个 ChatAPI 模块，它允许我们订阅好友的在线状态。<br><strong>使用class</strong><br>略</p><p><strong>使用Hook</strong><br>你可能认为需要单独的 effect 来执行清除操作。但由于添加和删除订阅的代码的紧密性，所以 useEffect 的设计是在同一个地方执行。<strong>如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它</strong>：</p><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function FriendStatus(props) &#123;  const [isOnline, setIsOnline] &#x3D; useState(null);  useEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    &#x2F;&#x2F; Specify how to clean up after this effect:  实际上函数名不重要，箭头函数也行，这里只是为了体现其作用    return function cleanup() &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;    return &#39;Loading...&#39;;  &#125;  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;&#125;</code></pre><p>为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p>React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。我们稍后将讨论<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update" target="_blank" rel="noopener">为什么这将助于避免 bug</a>以及<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank" rel="noopener">如何在遇到性能问题时跳过此行为</a>。</p><h3 id="使用多个effect实现关注点分离"><a href="#使用多个effect实现关注点分离" class="headerlink" title="使用多个effect实现关注点分离"></a>使用多个effect实现关注点分离</h3><p>我们的class中的声明周期函数内经常需要包含如上例子这样的不相关逻辑，而class写法里这些逻辑无疑会被分割到不同的生命周期中，比如componentWillMount中订阅，compnentWillUnmount中取消订阅等。而如果这样的代码较多，我们还要在同个生命周期中做不同的事情，让代码变得更加难以理解。<br>Hook的另一个作用，<strong>就是允许我们按照代码的用途来分离他们</strong>。</p><pre><code class="hljs plain">function FriendStatusWithCounter(props) &#123;  const [count, setCount] &#x3D; useState(0);  useEffect(() &#x3D;&gt; &#123;    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;  &#125;);  const [isOnline, setIsOnline] &#x3D; useState(null);  useEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);  &#x2F;&#x2F; ...&#125;</code></pre><h3 id="为什么每次更新的时候都需要运行effect"><a href="#为什么每次更新的时候都需要运行effect" class="headerlink" title="为什么每次更新的时候都需要运行effect"></a>为什么每次更新的时候都需要运行effect</h3><p>如果你已经习惯了使用 class，那么你或许会疑惑为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建 bug 更少的组件。</p><pre><code class="hljs plain">componentDidMount() &#123;    ChatAPI.subscribeToFriendStatus(      this.props.friend.id,      this.handleStatusChange    );  &#125;  componentWillUnmount() &#123;    ChatAPI.unsubscribeFromFriendStatus(      this.props.friend.id,      this.handleStatusChange    );  &#125;</code></pre><p>如上，考虑原来的代码，<strong>当组件已经显示在屏幕上时，friend prop 发生变化时会发生什么</strong>？ 我们的组件将继续展示原来的好友状态。这是一个 bug。而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。</p><p>在 class 组件中，我们需要添加 componentDidUpdate 来解决这个问题:</p><pre><code class="hljs plain">componentDidUpdate(prevProps) &#123;    &#x2F;&#x2F; 取消订阅之前的 friend.id    ChatAPI.unsubscribeFromFriendStatus(      prevProps.friend.id,      this.handleStatusChange    );    &#x2F;&#x2F; 订阅新的 friend.id    ChatAPI.subscribeToFriendStatus(      this.props.friend.id,      this.handleStatusChange    );  &#125;</code></pre><p>而hook就很好的解决了这一问题。</p><h3 id="跳过effect进行性能优化"><a href="#跳过effect进行性能优化" class="headerlink" title="跳过effect进行性能优化"></a>跳过effect进行性能优化</h3><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决：</p><pre><code class="hljs plain">componentDidUpdate(prevProps, prevState) &#123;  if (prevState.count !&#x3D;&#x3D; this.state.count) &#123;    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;  &#125;&#125;</code></pre><p>这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：</p><pre><code class="hljs plain">useEffect(() &#x3D;&gt; &#123;  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;&#125;, [count]); &#x2F;&#x2F; 仅在 count 更改时更新</code></pre><p>相当于把当前的count作为第二个参数传入，重渲染调用effect的时候react会比较彼时的count和我们传入的count，如果相等，则react会跳过这个effect。<br><strong>想判断哪个参数，就传入哪个参数。</strong>对于有清除操作的effect同样适用。</p><pre><code class="hljs plain">useEffect(() &#x3D;&gt; &#123;  function handleStatusChange(status) &#123;    setIsOnline(status.isOnline);  &#125;  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);  return () &#x3D;&gt; &#123;    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);  &#125;;&#125;, [props.friend.id]); &#x2F;&#x2F; 仅在 props.friend.id 发生变化时，重新订阅</code></pre><p>未来版本，可能会在构建时自动添加第二个参数。</p><p><strong>注意</strong>：<br>如果你要使用此优化方式，请确保数组中包含了<strong>所有外部作用域中会随时间变化并且在effect中使用的变量</strong>，否则你的代码会引用到先前渲染中的旧变量。参阅文档，了解更多关于<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">如何处理函数</a>以及<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" target="_blank" rel="noopener">数组频繁变化时的措施</a>内容。</p><p><strong>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行）</strong>，可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。 </p><p>如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入 [] 作为第二个参数更接近大家更熟悉的 componentDidMount 和 componentWillUnmount 思维模式，但我们有<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">更好的方式</a>来避免过于频繁的重复调用 effect。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得额外操作很方便。</p><p>我们推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" target="_blank" rel="noopener">eslint-plugin-react-hooks</a> 中的 <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">exhaustive-deps</a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p><p>此时你可能会好奇 Hook 是如何工作的。在两次渲染间，React如何知道哪个 useState 调用对应于哪个 state 变量？React 又是如何匹配前后两次渲染中的每一个 effect 的？接着来看。</p><h2 id="hook规则"><a href="#hook规则" class="headerlink" title="hook规则"></a>hook规则</h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">linter 插件</a>来强制执行这些规则：</p><ol><li>只在最顶层使用 Hook<br>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</li><li>只在 React 函数中调用 Hook<br>不要在普通的 JavaScript 函数中调用 Hook。你可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li></ol><h3 id="eslint插件"><a href="#eslint插件" class="headerlink" title="eslint插件"></a>eslint插件</h3><p>我们发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来强制执行这两条规则。</p><pre><code class="hljs plain">npm install eslint-plugin-react-hooks --save-dev</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; 你的 ESLint 配置&#123;  &quot;plugins&quot;: [    &#x2F;&#x2F; ...    &quot;react-hooks&quot;  ],  &quot;rules&quot;: &#123;    &#x2F;&#x2F; ...    &quot;react-hooks&#x2F;rules-of-hooks&quot;: &quot;error&quot;, &#x2F;&#x2F; 检查 Hook 的规则    &quot;react-hooks&#x2F;exhaustive-deps&quot;: &quot;warn&quot; &#x2F;&#x2F; 检查 effect 的依赖  &#125;&#125;</code></pre><p>回答上面的问题，React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。<br>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。但如果我们将一个 Hook (例如 persistForm effect) 调用放到一个条件语句中，Hook的调用顺序可能就会发生改变，从而导致bug。</p><pre><code class="hljs plain">&#x2F;&#x2F; 🔴 在条件语句中使用 Hook 违反第一条规则  if (name !&#x3D;&#x3D; &#39;&#39;) &#123;    useEffect(function persistForm() &#123;      localStorage.setItem(&#39;formData&#39;, name);    &#125;);  &#125;</code></pre><p>这就是为什么 Hook 需要在我们组件的最顶层调用。如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部：</p><pre><code class="hljs plain">useEffect(function persistForm() &#123;   &#x2F;&#x2F; 👍 将条件判断放置在 effect 中   if (name !&#x3D;&#x3D; &#39;&#39;) &#123;     localStorage.setItem(&#39;formData&#39;, name);   &#125; &#125;);</code></pre><p><strong>注意：如果使用了提供的 lint 插件，就无需担心此问题。</strong></p><h2 id="自定义Hook-1"><a href="#自定义Hook-1" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</p><p>在我们学习使用 Effect Hook 时，我们已经见过这个聊天程序中的组件，该组件用于显示好友的在线状态</p><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function FriendStatus(props) &#123;  const [isOnline, setIsOnline] &#x3D; useState(null);  useEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;    return &#39;Loading...&#39;;  &#125;  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;&#125;</code></pre><p>现在我们假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为绿色。我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中来，但这并不是理想的解决方案。<br>相反，我们希望在 FriendStatus 和 FriendListItem 之间共享逻辑。<br>目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: render props 和高阶组件，现在让我们来看看 Hook 是如何在让你不增加组件的情况下解决相同问题的。</p><h3 id="提取自定义-Hook"><a href="#提取自定义-Hook" class="headerlink" title="提取自定义 Hook"></a>提取自定义 Hook</h3><p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。</p><p><strong>自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。</strong></p><pre><code class="hljs plain">import &#123; useState, useEffect &#125; from &#39;react&#39;;function useFriendStatus(friendID) &#123;  const [isOnline, setIsOnline] &#x3D; useState(null);  useEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);    &#125;;  &#125;);  return isOnline;&#125;</code></pre><p>与组件中一致，请确保只在自定义 Hook 的顶层无条件地调用其他 Hook。</p><p>与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。</p><h3 id="使用自定义Hook"><a href="#使用自定义Hook" class="headerlink" title="使用自定义Hook"></a>使用自定义Hook</h3><pre><code class="hljs plain">unction FriendStatus(props) &#123;  const isOnline &#x3D; useFriendStatus(props.friend.id);  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;    return &#39;Loading...&#39;;  &#125;  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;&#125;</code></pre><pre><code class="hljs plain">function FriendListItem(props) &#123;  const isOnline &#x3D; useFriendStatus(props.friend.id);  return (    &lt;li style&#x3D;&#123;&#123; color: isOnline ? &#39;green&#39; : &#39;black&#39; &#125;&#125;&gt;      &#123;props.friend.name&#125;    &lt;&#x2F;li&gt;  );&#125;</code></pre><p>这段代码等价于原来的示例代码吗？等价，它的工作方式完全一样。如果你仔细观察，你会发现我们没有对其行为做任何的改变，我们只是将两个函数之间一些共同的代码提取到单独的函数中。</p><p>所以，<strong>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</strong></p><p>几个点：</p><ul><li><strong>自定义 Hook 必须以 “use” 开头。</strong>  不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。</li><li><strong>在两个组件中使用相同的 Hook 不会共享 state。</strong>  自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</li><li><strong>自定义 Hook 如何获取独立的 state?</strong> 每次调用 Hook，它都会获取独立的 state。由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect。 正如我们在之前章节中了解到的一样，我们可以在一个组件中多次调用 useState 和 useEffect，它们是完全独立的。</li></ul><h3 id="在多个-Hook-之间传递信息"><a href="#在多个-Hook-之间传递信息" class="headerlink" title="在多个 Hook 之间传递信息"></a>在多个 Hook 之间传递信息</h3><p>由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。</p><pre><code class="hljs plain">const friendList &#x3D; [  &#123; id: 1, name: &#39;Phoebe&#39; &#125;,  &#123; id: 2, name: &#39;Rachel&#39; &#125;,  &#123; id: 3, name: &#39;Ross&#39; &#125;,];function ChatRecipientPicker() &#123;  const [recipientID, setRecipientID] &#x3D; useState(1);  const isRecipientOnline &#x3D; useFriendStatus(recipientID);  return (    &lt;&gt;      &lt;Circle color&#x3D;&#123;isRecipientOnline ? &#39;green&#39; : &#39;red&#39;&#125; &#x2F;&gt;      &lt;select        value&#x3D;&#123;recipientID&#125;        onChange&#x3D;&#123;e &#x3D;&gt; setRecipientID(Number(e.target.value))&#125;      &gt;        &#123;friendList.map(friend &#x3D;&gt; (          &lt;option key&#x3D;&#123;friend.id&#125; value&#x3D;&#123;friend.id&#125;&gt;            &#123;friend.name&#125;          &lt;&#x2F;option&gt;        ))&#125;      &lt;&#x2F;select&gt;    &lt;&#x2F;&gt;  );&#125;</code></pre><p>我们将当前选择的好友 ID 保存在 recipientID 状态变量中，并在用户从 <code>&lt;select&gt;</code> 中选择其他好友时更新这个 state。</p><p>由于 useState 为我们提供了 recipientID 状态变量的最新值，因此我们可以将它作为参数传递给自定义的 useFriendStatus Hook。<br>如此可以让我们知道当前选中的好友是否在线。当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatus Hook 将会取消订阅之前选中的好友，并订阅新选中的好友状态。</p><p>既然函数组件能够做的更多，那么代码库中函数组件的代码行数可能会剧增。这属于正常现象 —— 不必立即将它们拆分为 Hook。但我们仍鼓励你能通过自定义 Hook 寻找可能，以达到简化代码逻辑，解决组件杂乱无章的目的。</p><h3 id="发挥想象"><a href="#发挥想象" class="headerlink" title="发挥想象"></a>发挥想象</h3><p>有个复杂的组件，其中包含了大量以特殊的方式来管理的内部状态。useState 并不会使得集中更新逻辑变得容易，因此你可能更愿意使用 redux 中的 reducer 来编写。</p><pre><code class="hljs plain">function todosReducer(state, action) &#123;  switch (action.type) &#123;    case &#39;add&#39;:      return [...state, &#123;        text: action.text,        completed: false      &#125;];    &#x2F;&#x2F; ... other actions ...    default:      return state;  &#125;&#125;</code></pre><p>Reducers 非常便于单独测试，且易于扩展，以表达复杂的更新逻辑。如有必要，您可以将它们分成更小的 reducer。但是，你可能还享受着 React 内部 state 带来的好处，或者可能根本不想安装其他库。</p><p>那么，为什么我们不编写一个 useReducer 的 Hook，使用 reducer 的方式来管理组件的内部 state 呢？其简化版本可能如下所示：</p><pre><code class="hljs plain">function useReducer(reducer, initialState) &#123;  const [state, setState] &#x3D; useState(initialState);  function dispatch(action) &#123;    const nextState &#x3D; reducer(state, action);    setState(nextState);  &#125;  return [state, dispatch];&#125;</code></pre><p>在组件中使用它，让 reducer 驱动它管理 state：</p><pre><code class="hljs plain">function Todos() &#123;  const [todos, dispatch] &#x3D; useReducer(todosReducer, []);  function handleAddClick(text) &#123;    dispatch(&#123; type: &#39;add&#39;, text &#125;);  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p>在复杂组件中使用 reducer 管理内部 state 的需求很常见，我们已经将 useReducer 的 Hook 内置到 React 中。你可以在 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">Hook API 索引</a>中找到它使用，搭配其他内置的 Hook 一起使用。</p><h1 id="Hook的API"><a href="#Hook的API" class="headerlink" title="Hook的API"></a>Hook的API</h1><p>Hook的API大致分为两类。</p><p>基础 Hook</p><ul><li>useState</li><li>useEffect</li><li>useContext</li></ul><p>额外的 Hook</p><ul><li>useReducer</li><li>useCallback</li><li>useMemo</li><li>useRef</li><li>useImperativeHandle</li><li>useLayoutEffect</li><li>useDebugValue</li></ul><h2 id="基础Hook"><a href="#基础Hook" class="headerlink" title="基础Hook"></a>基础Hook</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><pre><code class="hljs plain">const [state, setState] &#x3D; useState(initialState);</code></pre><p>除了之前介绍的用法。</p><p>还可以进行<br><strong>函数式更新</strong><br>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 setState 的两种用法：</p><pre><code class="hljs plain">function Counter(&#123;initialCount&#125;) &#123;  const [count, setCount] &#x3D; useState(initialCount);  return (    &lt;&gt;      Count: &#123;count&#125;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(initialCount)&#125;&gt;Reset&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(prevCount &#x3D;&gt; prevCount - 1)&#125;&gt;-&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(prevCount &#x3D;&gt; prevCount + 1)&#125;&gt;+&lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;</code></pre><p>如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。</p><p>注意：与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。<br>useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><p><strong>惰性初始state</strong><br>initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><pre><code class="hljs plain">const [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;  const initialState &#x3D; someExpensiveComputation(props);  return initialState;&#125;);</code></pre><p><strong>跳过state更新</strong><br>调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state。）</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><pre><code class="hljs plain">useEffect(didUpdate);</code></pre><p>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p><p>默认情况下，effect 将在每轮渲染结束后执行。前面说到过，但你可以选择让它 在只有某些值改变的时候 才执行。</p><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p><p>然而，并非所有 effect 都可以被延迟执行。例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 <strong>useLayoutEffect Hook</strong> 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p><p>虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p><p><strong>effect 的条件执行</strong><br>即前面说到的第二个参数,它是 effect 所依赖的值数组。更新后的示例如下：</p><pre><code class="hljs plain">useEffect(  () &#x3D;&gt; &#123;    const subscription &#x3D; props.source.subscribe();    return () &#x3D;&gt; &#123;      subscription.unsubscribe();    &#125;;  &#125;,  [props.source],);</code></pre><p>此时，只有当 props.source 改变后才会重新创建订阅。</p><p>再次强调，<strong>请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量</strong>。 见<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">如何处理函数</a>和<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" target="_blank" rel="noopener">数组频繁变化时的措施</a></p><p>这里确实有一点麻烦，需要自己传入对应的prop，state或二者的衍生值才能完成优化。未来编译器会更加智能，届时自动创建数组将成为可能。</p><p>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。但这需要你的effect函数确实没有引用 props、state 以及由它们衍生而来的值。</p><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><pre><code class="hljs plain">const value &#x3D; useContext(MyContext);</code></pre><p>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 value prop 决定。<br>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code>更新时，该 Hook 会触发重渲染.即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。</p><p>别忘记 useContext 的参数必须是 context 对象本身：</p><ul><li>正确： useContext(MyContext)</li><li>错误： useContext(MyContext.Consumer)</li><li>错误： useContext(MyContext.Provider)</li></ul><p>调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693" target="_blank" rel="noopener">通过使用 memoization 来优化</a>。</p><p>注意：<br>useContext(MyContext) 相当于 class 组件中的 static contextType = MyContext 或者 <code>&lt;MyContext.Consumer&gt;</code>。<br>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件提供 context。</p><h2 id="额外的Hook"><a href="#额外的Hook" class="headerlink" title="额外的Hook"></a>额外的Hook</h2><p>以下介绍的 Hook，有些是上一节中基础 Hook 的变体，有些则仅在特殊情况下会用到。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><pre><code class="hljs plain">const [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);</code></pre><p>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）<br>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</p><pre><code class="hljs plain">const initialState &#x3D; &#123;count: 0&#125;;&#x2F;&#x2F;reducer为单独定义的函数function reducer(state, action) &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      &#x2F;&#x2F;注意这里，不用返回dispath，react会帮我们实现，跟redux基本一致      return &#123;count: state.count + 1&#125;;    case &#39;decrement&#39;:      return &#123;count: state.count - 1&#125;;    default:      throw new Error();  &#125;&#125;function Counter() &#123;  const [state, dispatch] &#x3D; useReducer(reducer, initialState);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;</code></pre><p>React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 dispatch。</p><p><strong>惰性初始化</strong><br>注意到useReducer的第三个参数。用于让我们可以选择 惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。<br>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><pre><code class="hljs plain">function init(initialCount) &#123;  return &#123;count: initialCount&#125;;&#125;function reducer(state, action) &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123;count: state.count + 1&#125;;    case &#39;decrement&#39;:      return &#123;count: state.count - 1&#125;;    case &#39;reset&#39;:      return init(action.payload);    default:      throw new Error();  &#125;&#125;function Counter(&#123;initialCount&#125;) &#123;  const [state, dispatch] &#x3D; useReducer(reducer, initialCount, init);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button        onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;reset&#39;, payload: initialCount&#125;)&#125;&gt;        Reset      &lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;</code></pre><p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><pre><code class="hljs plain">const memoizedCallback &#x3D; useCallback(  () &#x3D;&gt; &#123;    doSomething(a, b);  &#125;,  [a, b],);</code></pre><p>返回一个 memoized 回调函数。<br>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><pre><code class="hljs plain">const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);</code></pre><p>返回一个 memoized 值。</p><p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p><p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><pre><code class="hljs plain">const refContainer &#x3D; useRef(initialValue);</code></pre><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 useEffect 以避免阻塞视觉更新。</p><p>我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。</p><p>如果你使用服务端渲染，请记住，无论 useLayoutEffect 还是 useEffect 都无法在 Javascript 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码时会触发 React 告警。解决这个问题，需要将代码逻辑移至 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 useLayoutEffect 执行之前 HTML 都显示错乱的情况下）。</p><p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild &amp;&amp; <code>&lt;Child /&gt;</code> 进行条件渲染，并使用 useEffect(() =&gt; { setShowChild(true); }, []) 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。</p><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React官方文档知识点-进阶</title>
    <link href="/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>承接上一篇文章。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-无障碍辅助功能"><a href="#1-无障碍辅助功能" class="headerlink" title="1.无障碍辅助功能"></a>1.无障碍辅助功能</h3><p>无障碍辅助功能是让所有人都能够获得服务的一种设计。<br>关于React中对此功能的全面要点：<a href="https://zh-hans.reactjs.org/docs/accessibility.html" target="_blank" rel="noopener">点击这里</a></p><h3 id="2-代码分割"><a href="#2-代码分割" class="headerlink" title="2.代码分割"></a>2.代码分割</h3><p>大多数 React 应用都会使用 Webpack，Rollup 或 Browserify 这类的构建工具来打包文件。 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。 接着在页面上引入该 bundle，整个应用即可一次性加载。</p><p>而现在的前端应用大多都会整合非常多第三方库，为了避免打包出的代码包过大导致加载时间边长。我们应该尽早思考对代码进行代码分割。代码分割是上诉打包工具支持的一项技术，能够创建多个包并在运行时动态加载。<br>它可以让你“懒加载”用户所需要的内容，避免加载永远不需要的代码，并在初始加载时减少所需加载的代码量，从而显著提高应用性能。</p><p>比如你的网站有20个网页，而某个用户可能只使用其中2个网页，另外18个网页的内容，用户是不需要加载的。</p><p>使用方法：</p><ul><li><p>import</p><pre><code class="hljs plain">&#x2F;&#x2F;使用前import &#123; add &#125; from &#39;.&#x2F;math&#39;;console.log(add(16, 26));&#x2F;&#x2F;使用后import(&quot;.&#x2F;math&quot;).then(math &#x3D;&gt; &#123;  console.log(math.add(16, 26));&#125;);</code></pre><p>如果你自己配置 Webpack，你可能要阅读下 Webpack 关于<a href="https://webpack.docschina.org/guides/code-splitting/" target="_blank" rel="noopener">代码分割</a>的指南。你的 Webpack 配置应该<a href="https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269" target="_blank" rel="noopener">类似于此</a>。</p></li><li><p>React.lazy<br>React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。</p><pre><code class="hljs plain">&#x2F;&#x2F;使用前import OtherComponent from &#39;.&#x2F;OtherComponent&#39;;&#x2F;&#x2F;使用后const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</code></pre><p>此代码将会在组件首次渲染时，自动导入包含 OtherComponent 组件的包。<br>React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。<br>然后你应在 <strong>Suspense</strong> 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。</p><pre><code class="hljs plain">import React, &#123; Suspense &#125; from &#39;react&#39;;const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));function MyComponent() &#123;  return (    &lt;div&gt;      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt;        &lt;OtherComponent &#x2F;&gt;      &lt;&#x2F;Suspense&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。</p></li></ul><p>PS：React.lazy 目前只支持默认导出（default exports）</p><ul><li><p>异常捕获边界(Error boundaries)<br>如果模块加载失败（如网络问题），它会触发一个错误。你可以通过<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">异常捕获边界（Error boundaries）</a>技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。</p></li><li><p>基于路由的代码分割<br>另一个很简单的代码分割方式就是基于路由。<br>使用React.lazy 和 <a href="https://react-router.docschina.org/" target="_blank" rel="noopener">React Router</a> 这类的第三方库，来配置基于路由的代码分割。</p></li></ul><h3 id="3-Context"><a href="#3-Context" class="headerlink" title="3.Context"></a>3.Context</h3><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。<br>使用方式</p><pre><code class="hljs plain">&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。const ThemeContext &#x3D; React.createContext(&#39;light&#39;);class App extends React.Component &#123;  render() &#123;    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。    return (      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;        &lt;Toolbar &#x2F;&gt;      &lt;&#x2F;ThemeContext.Provider&gt;    );  &#125;&#125;&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。function Toolbar() &#123;  return (    &lt;div&gt;      &lt;ThemedButton &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;class ThemedButton extends React.Component &#123;  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。  static contextType &#x3D; ThemeContext;  render() &#123;    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;  &#125;&#125;</code></pre><p>请谨慎使用context，因为这会使得组件的复用性变差。</p><p>如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。</p><p>比如在一个Page组件内，它层层向下传递user和avatarSize属性，从而较深的Avatar组件可以读取到这些属性。如果最后只有Avatar需要这个变量，层层传递就显得比较蠢，此时除了使用context，还可以的一种方法是直接在page中构造好avatar组件，然后传递下去。</p><p>这种对组件的控制反转减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。</p><p><a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">context的使用方法</a></p><h3 id="4-错误边界"><a href="#4-错误边界" class="headerlink" title="4.错误边界"></a>4.错误边界</h3><p>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p><p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p><p>错误边界无法捕获以下场景中产生的错误：</p><ul><li>事件处理,因为事件处理器不会再渲染期间触发，so使用try/catch来捕获。</li><li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</li><li>服务端渲染</li><li>它自身抛出来的错误（并非它的子组件）</li></ul><p>如果一个 class 组件中定义了 static <strong>getDerivedStateFromError()</strong> 或 <strong>componentDidCatch()</strong> 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。<br>当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p><pre><code class="hljs plain">class ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123; hasError: false &#125;;  &#125;  static getDerivedStateFromError(error) &#123;    &#x2F;&#x2F; 更新 state 使下一次渲染能够显示降级后的 UI    return &#123; hasError: true &#125;;  &#125;  componentDidCatch(error, errorInfo) &#123;    &#x2F;&#x2F; 你同样可以将错误日志上报给服务器    logErrorToMyService(error, errorInfo);  &#125;  render() &#123;    if (this.state.hasError) &#123;      &#x2F;&#x2F; 你可以自定义降级后的 UI 并渲染      return &lt;h1&gt;Something went wrong.&lt;&#x2F;h1&gt;;    &#125;    return this.props.children;   &#125;&#125;</code></pre><p>注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p><p>错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃。</p><p>PS:自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。</p><h3 id="5-Refs-和-DOM"><a href="#5-Refs-和-DOM" class="headerlink" title="5.Refs 和 DOM"></a>5.Refs 和 DOM</h3><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。<br>在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。  </p><p>下面是几个适合使用 refs 的情况：</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库。</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。举个例子，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性。</p><p>两种使用refs的方式：<br>1.React.createRef()</p><pre><code class="hljs plain">class CustomTextInput extends React.Component &#123;  constructor(props) &#123;    super(props);    &#x2F;&#x2F; 创建一个 ref 来存储 textInput 的 DOM 元素    this.textInput &#x3D; React.createRef();    this.focusTextInput &#x3D; this.focusTextInput.bind(this);  &#125;  focusTextInput() &#123;    &#x2F;&#x2F; 直接使用原生 API 使 text 输入框获得焦点    &#x2F;&#x2F; 注意：我们通过 &quot;current&quot; 来访问 DOM 节点    this.textInput.current.focus();  &#125;  render() &#123;    &#x2F;&#x2F; 告诉 React 我们想把 &lt;input&gt; ref 关联到    &#x2F;&#x2F; 构造器里创建的 &#96;textInput&#96; 上    return (      &lt;div&gt;        &lt;input          type&#x3D;&quot;text&quot;          ref&#x3D;&#123;this.textInput&#125; &#x2F;&gt;        &lt;input          type&#x3D;&quot;button&quot;          value&#x3D;&quot;Focus the text input&quot;          onClick&#x3D;&#123;this.focusTextInput&#125;        &#x2F;&gt;      &lt;&#x2F;div&gt;    );  &#125;&#125;</code></pre><p>React 会在组件挂载时给 current 属性传入 DOM 元素，并在组件卸载时传入 null 值。ref 会在 componentDidMount 或 componentDidUpdate 生命周期钩子触发前更新。</p><ul><li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</li><li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。</li></ul><p>2.回调ref</p><pre><code class="hljs plain">class CustomTextInput extends React.Component &#123;  constructor(props) &#123;    super(props);    this.textInput &#x3D; null;    this.setTextInputRef &#x3D; element &#x3D;&gt; &#123;      this.textInput &#x3D; element;    &#125;;    this.focusTextInput &#x3D; () &#x3D;&gt; &#123;      &#x2F;&#x2F; 使用原生 DOM API 使 text 输入框获得焦点      if (this.textInput) this.textInput.focus();    &#125;;  &#125;  componentDidMount() &#123;    &#x2F;&#x2F; 组件挂载后，让文本框自动获得焦点    this.focusTextInput();  &#125;  render() &#123;    &#x2F;&#x2F; 使用 &#96;ref&#96; 的回调函数将 text 输入框 DOM 节点的引用存储到 React    &#x2F;&#x2F; 实例上（比如 this.textInput）    return (      &lt;div&gt;        &lt;input          type&#x3D;&quot;text&quot;          ref&#x3D;&#123;this.setTextInputRef&#125;        &#x2F;&gt;        &lt;input          type&#x3D;&quot;button&quot;          value&#x3D;&quot;Focus the text input&quot;          onClick&#x3D;&#123;this.focusTextInput&#125;        &#x2F;&gt;      &lt;&#x2F;div&gt;    );  &#125;&#125;</code></pre><p>如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p><p>注：var func_name = function(){}这种形式定义的函数为内联函数。</p><p>在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。<br>这种情况下我们推荐使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">ref 转发</a>。Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。关于怎样对父组件暴露子组件的 DOM 节点，在 ref 转发文档中有一个详细的例子。</p><h3 id="6-Fragments"><a href="#6-Fragments" class="headerlink" title="6.Fragments"></a>6.Fragments</h3><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p><pre><code class="hljs plain">render() &#123;  return (    &lt;React.Fragment&gt;      &lt;ChildA &#x2F;&gt;      &lt;ChildB &#x2F;&gt;      &lt;ChildC &#x2F;&gt;    &lt;&#x2F;React.Fragment&gt;  );&#125;</code></pre><p>还有一种段语法,看起来有点诡异，即空标签：</p><pre><code class="hljs plain">class Columns extends React.Component &#123;  render() &#123;    return (      &lt;&gt;        &lt;td&gt;Hello&lt;&#x2F;td&gt;        &lt;td&gt;World&lt;&#x2F;td&gt;      &lt;&#x2F;&gt;    );  &#125;&#125;</code></pre><p>使用显式 &lt;React.Fragment&gt; 语法声明的片段可能具有 key。一个使用场景是将一个集合映射到一个 Fragments 数组。</p><pre><code class="hljs plain">function Glossary(props) &#123;  return (    &lt;dl&gt;      &#123;props.items.map(item &#x3D;&gt; (        &#x2F;&#x2F; 没有&#96;key&#96;，React 会发出一个关键警告        &lt;React.Fragment key&#x3D;&#123;item.id&#125;&gt;          &lt;dt&gt;&#123;item.term&#125;&lt;&#x2F;dt&gt;          &lt;dd&gt;&#123;item.description&#125;&lt;&#x2F;dd&gt;        &lt;&#x2F;React.Fragment&gt;      ))&#125;    &lt;&#x2F;dl&gt;  );&#125;</code></pre><p>key 是目前唯一可以传递给 Fragment 的属性。</p><h3 id="7-高阶组件"><a href="#7-高阶组件" class="headerlink" title="7.高阶组件"></a>7.高阶组件</h3><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p>可以对应高阶函数来理解，高阶函数为函数作为参数传递，函数作为返回值。<br>而高阶组件则是参数为组件，返回值为新组件的函数。</p><pre><code class="hljs plain">const EnhancedComponent &#x3D; higherOrderComponent(WrappedComponent);</code></pre><p>HOC 在 React 的第三方库中很常见，例如 Redux 的 connect 和 Relay 的 createFragmentContainer。</p><p>一大作用就是将组件间相同的业务逻辑进行抽象，比如2个组件都依赖于某个外部数据进行渲染，那么获取这个外部数据和监听其改变的方式就可以放到高阶组件中进行：</p><pre><code class="hljs plain">&#x2F;&#x2F; 此函数接收一个组件...function withSubscription(WrappedComponent, selectData) &#123;  &#x2F;&#x2F; ...并返回另一个组件...  return class extends React.Component &#123;    constructor(props) &#123;      super(props);      this.handleChange &#x3D; this.handleChange.bind(this);      this.state &#x3D; &#123;        data: selectData(DataSource, props)      &#125;;    &#125;    componentDidMount() &#123;      &#x2F;&#x2F; ...负责订阅相关的操作...      DataSource.addChangeListener(this.handleChange);    &#125;    componentWillUnmount() &#123;      DataSource.removeChangeListener(this.handleChange);    &#125;    handleChange() &#123;      this.setState(&#123;        data: selectData(DataSource, this.props)      &#125;);    &#125;    render() &#123;      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!      &#x2F;&#x2F; 请注意，我们可能还会传递其他属性      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;    &#125;  &#125;;&#125;</code></pre><p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。</p><p>不要试图在 HOC 中修改组件原型（或以其他方式改变它）。因为这种修改会导致组件行为永远发生变化。</p><p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p><pre><code class="hljs plain">function logProps(WrappedComponent) &#123;  return class extends React.Component &#123;    componentDidUpdate(prevProps) &#123;      console.log(&#39;Current props: &#39;, this.props);      console.log(&#39;Previous props: &#39;, prevProps);    &#125;    render() &#123;      &#x2F;&#x2F; 将 input 组件包装在容器中，而不对其进行修改。Good!      return &lt;WrappedComponent &#123;...this.props&#125; &#x2F;&gt;;    &#125;  &#125;&#125;</code></pre><p>您可能已经注意到 HOC 与容器组件模式之间有相似之处。容器组件担任分离将高层和低层关注的责任，由容器管理订阅和状态，并将 prop 传递给处理渲染 UI。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p><p>来看看redux的connect</p><pre><code class="hljs plain">&#x2F;&#x2F; React Redux 的 &#96;connect&#96; 函数const ConnectedComment &#x3D; connect(commentSelector, commentActions)(CommentList);</code></pre><p>发生了什么？！如果你把它分开，就会更容易看出发生了什么。</p><pre><code class="hljs plain">&#x2F;&#x2F; connect 是一个函数，它的返回值为另外一个函数。const enhance &#x3D; connect(commentListSelector, commentListActions);&#x2F;&#x2F; 返回值为 HOC，它会返回已经连接 Redux store 的组件const ConnectedComment &#x3D; enhance(CommentList);</code></pre><p>换句话说，connect 是一个返回高阶组件的高阶函数！</p><p>这种形式可能看起来令人困惑或不必要，但它有一个有用的属性, 充当装饰器，多个装饰器可以一起使用。</p><pre><code class="hljs plain">&#x2F;&#x2F; 而不是这样...const EnhancedComponent &#x3D; withRouter(connect(commentSelector)(WrappedComponent))&#x2F;&#x2F; ... 你可以编写组合工具函数&#x2F;&#x2F; compose(f, g, h) 等同于 (...args) &#x3D;&gt; f(g(h(...args)))const enhance &#x3D; compose(  &#x2F;&#x2F; 这些都是单参数的 HOC  withRouter,  connect(commentSelector))const EnhancedComponent &#x3D; enhance(WrappedComponent)</code></pre><p>许多第三方库都提供了 compose 工具函数，包括 lodash （比如 lodash.flowRight）， Redux 和 Ramda。</p><p>注意点：</p><ul><li>不要在 render 方法中使用 HOC</li><li>务必复制静态方法</li><li>Refs 不会被传递</li></ul><h3 id="8-与其它视图库集成"><a href="#8-与其它视图库集成" class="headerlink" title="8.与其它视图库集成"></a>8.与其它视图库集成</h3><p>得益于 ReactDOM.render() 的灵活性 React 可以被嵌入到其他的应用中。</p><p>虽然 React 通常被用来在启动的时候加载一个单独的根 React 组件到 DOM 上，ReactDOM.render() 同样可以在 UI 的独立部分上多次调用，这些部分可以小到一个按钮，也可以大到一个应用。<br>如：</p><pre><code class="hljs plain">$(&#39;#container&#39;).html(&#39;&lt;button id&#x3D;&quot;btn&quot;&gt;Say Hello&lt;&#x2F;button&gt;&#39;);$(&#39;#btn&#39;).click(function() &#123;  alert(&#39;Hello!&#39;);&#125;);</code></pre><p>改造成：</p><pre><code class="hljs plain">function Button(props) &#123;  return &lt;button onClick&#x3D;&#123;props.onClick&#125;&gt;Say Hello&lt;&#x2F;button&gt;;&#125;function HelloButton() &#123;  function handleClick() &#123;    alert(&#39;Hello!&#39;);  &#125;  return &lt;Button onClick&#x3D;&#123;handleClick&#125; &#x2F;&gt;;&#125;ReactDOM.render(  &lt;HelloButton &#x2F;&gt;,  document.getElementById(&#39;container&#39;));</code></pre><h3 id="9-深入JSX"><a href="#9-深入JSX" class="headerlink" title="9.深入JSX"></a>9.深入JSX</h3><p>实际上，JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。<br>值得说的点：</p><ul><li><p>Props 默认值为 “True”，如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：</p><pre><code class="hljs plain">&lt;MyTextBox autocomplete &#x2F;&gt;&lt;MyTextBox autocomplete&#x3D;&#123;true&#125; &#x2F;&gt;</code></pre></li><li><p>属性展开：如果你已经有了一个 props 对象，你可以使用展开运算符 … 来在 JSX 中传递整个 props 对象。还可以选择只保留当前组件需要接收的 props，并使用展开运算符将其他 props 传递下去。</p><pre><code class="hljs plain">const Button &#x3D; props &#x3D;&gt; &#123;  const &#123; kind, ...other &#125; &#x3D; props;  const className &#x3D; kind &#x3D;&#x3D;&#x3D; &quot;primary&quot; ? &quot;PrimaryButton&quot; : &quot;SecondaryButton&quot;;  return &lt;button className&#x3D;&#123;className&#125; &#123;...other&#125; &#x2F;&gt;;&#125;;</code></pre></li><li><p>函数作为子元素。 你可以将任何东西作为子元素传递给自定义组件，只要确保在该组件渲染之前能够被转换成 React 理解的对象。这种用法并不常见，但可以用于扩展 JSX。</p></li><li><p>false, null, undefined, and true 是合法的子元素。但它们并不会被渲染。值得注意的是有一些 “falsy” 值，如数字 0，仍然会被 React 渲染。 所以不要用 aa.length &amp;&amp; Component 这种形式。改成aa.length&gt;0即可。</p></li></ul><h3 id="10-性能优化"><a href="#10-性能优化" class="headerlink" title="10.性能优化"></a>10.性能优化</h3><p>UI 更新需要昂贵的 DOM 操作，而 React 内部使用几种巧妙的技术以便最小化 DOM 操作次数。</p><p><strong>首先，使用生产版本。</strong><br>React 默认包含了许多有用的警告信息。这些警告信息在开发过程中非常有帮助。然而这使得 React 变得更大且更慢，所以你需要确保部署时使用了生产版本。可通过chrome的<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">React开发者工具来检查</a>。图标为蓝色表示生产版本，图片红色表示开发模式。<br><a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">这里</a>有webpack,Brunch,Browserify,Rollup来进行生产构建的方法。</p><p><strong>使用chrome performance标签分析组件</strong><br>在开发模式下，你可以通过支持的浏览器可视化地了解组件是如何 挂载、更新以及卸载的。<br>在 Chrome 中进行如下操作：</p><ol><li>临时禁用所有的 Chrome 扩展，尤其是 React 开发者工具。他们会严重干扰度量结果！</li><li>确保你是在 React 的开发模式下运行应用。</li><li>打开 Chrome 开发者工具的 Performance 标签并按下 Record。</li><li>对你想分析的行为进行复现。尽量在 20 秒内完成以避免 Chrome 卡住。</li><li>停止记录。</li><li>在 User Timing 标签下会显示 React 归类好的事件。<br>这能帮助你查看是否有不相关的组件被错误地更新，以及 UI 更新的深度和频率。</li></ol><p><strong>使用开发者工具中的分析器对组件进行分析</strong><br>在开发模式下，React 开发者工具会出现分析器标签。 你可以在<a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">《介绍 React 分析器》</a>这篇博客中了解概述。 你也可以在 <a href="https://www.youtube.com/watch?v=nySib7ipZdk" target="_blank" rel="noopener">YouTube</a> 上观看分析器的视频指导。</p><p><strong>虚拟化长列表</strong><br>如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。</p><p><a href="https://react-window.now.sh/" target="_blank" rel="noopener">react-window</a> 和 <a href="https://bvaughn.github.io/react-virtualized/" target="_blank" rel="noopener">react-virtualized</a> 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。 如果你想要一些针对你的应用做定制优化，你也可以创建你自己的虚拟滚动组件，就像 Twitter 所做的。</p><p><strong>避免调停</strong><br>React 构建并维护了一套内部的 UI 渲染描述。它包含了来自你的组件返回的 React 元素。即虚拟DOM，使得 React 避免创建 DOM 节点以及没有必要的节点访问，因为 DOM 操作相对于 JavaScript 对象操作更慢。</p><p>当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM。<br>即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法 shouldComponentUpdate 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 true，让 React 执行更新。<br>如果你知道在什么情况下你的组件不需要更新，你可以在 shouldComponentUpdate 中返回 false 来跳过整个渲染过程。其包括该组件的 render 调用以及之后的操作。<br>在大部分情况下，你可以继承 React.PureComponent 以代替手写 shouldComponentUpdate()。它用当前与之前 props 和 state 的浅比较覆写了 shouldComponentUpdate() 的实现。</p><p><strong>不可变数据的力量</strong><br>这点之前已经说过，比如对于数组，用concat避免直接在原来的数组上push。 对于对象，用Object.assign避免直接修改对象中的值。</p><p>当处理深层嵌套对象时，以 immutable （不可变）的方式更新它们令人费解。如遇到此类问题，请参阅 <a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a> 或 <a href="https://github.com/kolodny/immutability-helper" target="_blank" rel="noopener">immutability-helper</a>。这些库会帮助你编写高可读性的代码，且不会失去 immutability （不可变性）带来的好处。</p><h3 id="11-Portals"><a href="#11-Portals" class="headerlink" title="11.Portals"></a>11.Portals</h3><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p><p>通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点。然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的。<br>一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p><pre><code class="hljs plain">render() &#123;  &#x2F;&#x2F; React 并*没有*创建一个新的 div。它只是把子元素渲染到 &#96;domNode&#96; 中。  &#x2F;&#x2F; &#96;domNode&#96; 是一个可以在任何位置的有效 DOM 节点。  return ReactDOM.createPortal(    this.props.children,    domNode  );&#125;</code></pre><p>PS:当在使用 portal 时, 记住<a href="https://zh-hans.reactjs.org/docs/accessibility.html#programmatically-managing-focus" target="_blank" rel="noopener">管理键盘焦点</a>就变得尤为重要。</p><p>对于模态对话框，通过遵循 <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" target="_blank" rel="noopener">WAI-ARIA 模态开发实践</a>，来确保每个人都能够运用它。</p><p><a href="https://codepen.io/gaearon/pen/yzMaBd" target="_blank" rel="noopener">这里</a>有一个关于用portal创建模态对话框的示例。</p><p>一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树 中的祖先。假设存在如下</p><pre><code class="hljs plain">&lt;html&gt;  &lt;body&gt;    &lt;div id&#x3D;&quot;app-root&quot;&gt;&lt;&#x2F;div&gt;    &lt;div id&#x3D;&quot;modal-root&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>在 #app-root 里的 Parent 组件能够捕获到未被捕获的从兄弟节点 #modal-root 冒泡上来的事件。<br><a href="https://codepen.io/gaearon/pen/jGBWpE" target="_blank" rel="noopener">codepen实例</a><br>在父组件里捕获一个来自 portal 冒泡上来的事件，使之能够在开发时具有不完全依赖于 portal 的更为灵活的抽象。例如，如果你在渲染一个 <Modal /> 组件，无论其是否采用 portal 实现，父组件都能够捕获其事件。</p><h3 id="12-Profiler-API"><a href="#12-Profiler-API" class="headerlink" title="12.Profiler API"></a>12.Profiler API</h3><p>Profiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用类似 <a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations" target="_blank" rel="noopener">memoization 优化</a>的部分，并从相关优化中获益。<br><a href="https://zh-hans.reactjs.org/docs/profiler.html" target="_blank" rel="noopener">这里</a>了解详情。</p><h3 id="13-React-Diffing的原理-协调算法"><a href="#13-React-Diffing的原理-协调算法" class="headerlink" title="13.React Diffing的原理 协调算法"></a>13.React Diffing的原理 协调算法</h3><p>在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。<br>这个算法问题有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作数。 然而，即使在最前沿的算法中，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量。<br>这无疑有些难以接受，React基于真实使用环境做出2个假设，在其基础上提出了一套O(n)的算法：</p><ol><li>两个不同类型的元素会产生出不同的树；</li><li>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；</li></ol><p><strong>Diffing算法</strong><br>当对比两颗树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。</p><ol><li>比对不同类型的元素<br>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。<br>当拆卸一棵树时，对应的 DOM 节点也会被销毁。在根节点以下的组件也会被卸载，它们的状态会被销毁。</li><li>比对同一类型的元素<br>当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如className变了就只更新className属性，当style属性更新是，也仅更新有所改变的属性，比如color等。<br>处理完当前节点之后，React 继续对子节点进行递归。</li><li>比对同类型的组件元素<br>当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。<br>下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。</li><li>对子节点进行递归<br>在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。<br>在子元素列表末尾新增元素时，更变开销比较小。React 会针对每个子元素 mutate 而不是保持相同的 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code> 子树完成。这种情况下的低效可能会带来性能问题。<br>所以引进了key属性。</li></ol><p><strong>总之</strong><br>React 可以在每个 action 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 render 方法，这不代表 React 会卸载或装载它们。React 只会基于以上提到的规则来决定如何进行差异的合并。<br>由于 React 依赖探索的算法，因此当以下假设没有得到满足，性能会有所损耗。</p><ol><li>该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题。</li><li>Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。</li></ol><h3 id="14-render-props"><a href="#14-render-props" class="headerlink" title="14.render props"></a>14.render props</h3><p>术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p><p>具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。</p><pre><code class="hljs plain">&lt;DataProvider render&#x3D;&#123;data &#x3D;&gt; (  &lt;h1&gt;Hello &#123;data.target&#125;&lt;&#x2F;h1&gt;)&#125;&#x2F;&gt;</code></pre><p>使用 render prop 的库有 React Router、Downshift 以及 Formik。<br>更具体地说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</p><pre><code class="hljs plain">class Cat extends React.Component &#123;  render() &#123;    const mouse &#x3D; this.props.mouse;    return (      &lt;img src&#x3D;&quot;&#x2F;cat.jpg&quot; style&#x3D;&#123;&#123; position: &#39;absolute&#39;, left: mouse.x, top: mouse.y &#125;&#125; &#x2F;&gt;    );  &#125;&#125;class Mouse extends React.Component &#123;  constructor(props) &#123;    super(props);    this.handleMouseMove &#x3D; this.handleMouseMove.bind(this);    this.state &#x3D; &#123; x: 0, y: 0 &#125;;  &#125;  handleMouseMove(event) &#123;    this.setState(&#123;      x: event.clientX,      y: event.clientY    &#125;);  &#125;  render() &#123;    return (      &lt;div style&#x3D;&#123;&#123; height: &#39;100vh&#39; &#125;&#125; onMouseMove&#x3D;&#123;this.handleMouseMove&#125;&gt;        &#123;&#x2F;*          Instead of providing a static representation of what &lt;Mouse&gt; renders,          use the &#96;render&#96; prop to dynamically determine what to render.        *&#x2F;&#125;        &#123;this.props.render(this.state)&#125;      &lt;&#x2F;div&gt;    );  &#125;&#125;class MouseTracker extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;移动鼠标!&lt;&#x2F;h1&gt;        &lt;Mouse render&#x3D;&#123;mouse &#x3D;&gt; (          &lt;Cat mouse&#x3D;&#123;mouse&#125; &#x2F;&gt;        )&#125;&#x2F;&gt;      &lt;&#x2F;div&gt;    );  &#125;&#125;</code></pre><p>这项技术使我们共享行为非常容易。要获得这个行为，只要渲染一个带有 render prop 的 <Mouse> 组件就能够告诉它当前鼠标坐标 (x, y) 要渲染什么。</p><p>关于 render prop 一个有趣的事情是你可以使用带有 render prop 的常规组件来实现大多数高阶组件 (HOC)。 例如，如果你更喜欢使用 withMouse HOC而不是 <Mouse> 组件，你可以使用带有 render prop 的常规 <Mouse> 轻松创建一个</p><pre><code class="hljs plain">&#x2F;&#x2F; 如果你出于某种原因真的想要 HOC，那么你可以轻松实现&#x2F;&#x2F; 使用具有 render prop 的普通组件创建一个！function withMouse(Component) &#123;  return class extends React.Component &#123;    render() &#123;      return (        &lt;Mouse render&#x3D;&#123;mouse &#x3D;&gt; (          &lt;Component &#123;...this.props&#125; mouse&#x3D;&#123;mouse&#125; &#x2F;&gt;        )&#125;&#x2F;&gt;      );    &#125;  &#125;&#125;</code></pre><p>重要的是要记住，render prop 是因为模式才被称为 render prop ，你不一定要用名为 render 的 prop 来使用这种模式。事实上， <strong>任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”.</strong></p><h3 id="15-静态类型检查"><a href="#15-静态类型检查" class="headerlink" title="15.静态类型检查"></a>15.静态类型检查</h3><p>像 Flow 和 TypeScript 等这些静态类型检查器，可以在运行前识别某些类型的问题。他们还可以通过增加自动补全等功能来改善开发者的工作流程。出于这个原因，我们建议在大型代码库中使用 Flow 或 TypeScript 来代替 PropTypes。</p><p>Flow介绍在<a href="https://zh-hans.reactjs.org/docs/static-type-checking.html" target="_blank" rel="noopener">这里</a></p><p><strong>typescript</strong><br>TypeScript 是一种由微软开发的编程语言。它是 JavaScript 的一个类型超集，包含独立的编译器。作为一种类型语言，TypeScript 可以在构建时发现 bug 和错误，这样程序运行时就可以避免此类错误。您可以通过<a href="https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter" target="_blank" rel="noopener">此文档</a> 了解更多有关在 React 中使用 TypeScript 的知识。</p><p>完成以下步骤，便可开始使用 TypeScript：</p><ul><li>将 TypeScript 添加到你的项目依赖中。</li><li>配置 TypeScript 编译选项</li><li>使用正确的文件扩展名</li><li>为你使用的库添加定义</li></ul><p>如果你使用create-react-app,那么使用<code>npx create-react-app my-app --template typescript</code>即可创建一个使用TypeScript的新项目。</p><p>关于怎么在现有项目中引入TS，见<a href="https://zh-hans.reactjs.org/docs/static-type-checking.html" target="_blank" rel="noopener">这里</a></p><p><strong>Kotlin</strong><br>Kotlin 是由 JetBrains 开发的一门静态类型语言。其目标平台包括 JVM、Android、LLVM 和 JavaScript。</p><p>JetBrains 专门为 React 社区开发和维护了几个工具：React bindings 以及 Create React Kotlin App。后者可以通过 Kotlin 快速编写 React 应用程序，并且不需要构建配置。</p><h3 id="16-严格模式"><a href="#16-严格模式" class="headerlink" title="16.严格模式"></a>16.严格模式</h3><p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p><pre><code class="hljs plain">import React from &#39;react&#39;;function ExampleApplication() &#123;  return (    &lt;div&gt;      &lt;Header &#x2F;&gt;      &lt;React.StrictMode&gt;        &lt;div&gt;          &lt;ComponentOne &#x2F;&gt;          &lt;ComponentTwo &#x2F;&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;React.StrictMode&gt;      &lt;Footer &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>StrictMode 目前有助于：</p><ul><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API<br>详情见<a href="https://zh-hans.reactjs.org/docs/strict-mode.html" target="_blank" rel="noopener">这里</a></li></ul><h3 id="17-PropTypes-类型检查"><a href="#17-PropTypes-类型检查" class="headerlink" title="17.PropTypes 类型检查"></a>17.PropTypes 类型检查</h3><p>第15点中说过，Flow和TypeScript可以对整个应用程序进行类型检查，但如果你没有使用这些扩展。你可以使用内置的PropTypes来进行类型检查。</p><pre><code class="hljs plain">import PropTypes from &#39;prop-types&#39;;class Greeting extends React.Component &#123;  render() &#123;    return (      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;    );  &#125;&#125;Greeting.propTypes &#x3D; &#123;  name: PropTypes.string&#125;;</code></pre><p>当传入的 prop 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，propTypes 仅在开发模式下进行检查。</p><p>类型很多，如下，还可以自定义：</p><pre><code class="hljs plain">import PropTypes from &#39;prop-types&#39;;MyComponent.propTypes &#x3D; &#123;  &#x2F;&#x2F; 你可以将属性声明为 JS 原生类型，默认情况下  &#x2F;&#x2F; 这些属性都是可选的。  optionalArray: PropTypes.array,  optionalBool: PropTypes.bool,  optionalFunc: PropTypes.func,  optionalNumber: PropTypes.number,  optionalObject: PropTypes.object,  optionalString: PropTypes.string,  optionalSymbol: PropTypes.symbol,  &#x2F;&#x2F; 任何可被渲染的元素（包括数字、字符串、元素或数组）  &#x2F;&#x2F; (或 Fragment) 也包含这些类型。  optionalNode: PropTypes.node,  &#x2F;&#x2F; 一个 React 元素。  optionalElement: PropTypes.element,  &#x2F;&#x2F; 一个 React 元素类型（即，MyComponent）。  optionalElementType: PropTypes.elementType,  &#x2F;&#x2F; 你也可以声明 prop 为类的实例，这里使用  &#x2F;&#x2F; JS 的 instanceof 操作符。  optionalMessage: PropTypes.instanceOf(Message),  &#x2F;&#x2F; 你可以让你的 prop 只能是特定的值，指定它为  &#x2F;&#x2F; 枚举类型。  optionalEnum: PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),  &#x2F;&#x2F; 一个对象可以是几种类型中的任意一个类型  optionalUnion: PropTypes.oneOfType([    PropTypes.string,    PropTypes.number,    PropTypes.instanceOf(Message)  ]),  &#x2F;&#x2F; 可以指定一个数组由某一类型的元素组成  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  &#x2F;&#x2F; 可以指定一个对象由某一类型的值组成  optionalObjectOf: PropTypes.objectOf(PropTypes.number),  &#x2F;&#x2F; 可以指定一个对象由特定的类型值组成  optionalObjectWithShape: PropTypes.shape(&#123;    color: PropTypes.string,    fontSize: PropTypes.number  &#125;),    &#x2F;&#x2F; An object with warnings on extra properties  optionalObjectWithStrictShape: PropTypes.exact(&#123;    name: PropTypes.string,    quantity: PropTypes.number  &#125;),     &#x2F;&#x2F; 你可以在任何 PropTypes 属性后面加上 &#96;isRequired&#96; ，确保  &#x2F;&#x2F; 这个 prop 没有被提供时，会打印警告信息。  requiredFunc: PropTypes.func.isRequired,  &#x2F;&#x2F; 任意类型的数据  requiredAny: PropTypes.any.isRequired,  &#x2F;&#x2F; 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。  &#x2F;&#x2F; 请不要使用 &#96;console.warn&#96; 或抛出异常，因为这在 &#96;onOfType&#96; 中不会起作用。  customProp: function(props, propName, componentName) &#123;    if (!&#x2F;matchme&#x2F;.test(props[propName])) &#123;      return new Error(        &#39;Invalid prop &#96;&#39; + propName + &#39;&#96; supplied to&#39; +        &#39; &#96;&#39; + componentName + &#39;&#96;. Validation failed.&#39;      );    &#125;  &#125;,  &#x2F;&#x2F; 你也可以提供一个自定义的 &#96;arrayOf&#96; 或 &#96;objectOf&#96; 验证器。  &#x2F;&#x2F; 它应该在验证失败时返回一个 Error 对象。  &#x2F;&#x2F; 验证器将验证数组或对象中的每个值。验证器的前两个参数  &#x2F;&#x2F; 第一个是数组或对象本身  &#x2F;&#x2F; 第二个是他们当前的键。  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;    if (!&#x2F;matchme&#x2F;.test(propValue[key])) &#123;      return new Error(        &#39;Invalid prop &#96;&#39; + propFullName + &#39;&#96; supplied to&#39; +        &#39; &#96;&#39; + componentName + &#39;&#96;. Validation failed.&#39;      );    &#125;  &#125;)&#125;;</code></pre><p><strong>限制单个元素</strong><br>你可以通过 PropTypes.element 来确保传递给组件的 children 中只包含一个元素。</p><pre><code class="hljs plain">&#x2F;&#x2F; children必须只有一个元素，否则控制台会打印警告。MyComponent.propTypes &#x3D; &#123;  children: PropTypes.element.isRequired&#125;;</code></pre><p><strong>默认Prop值</strong><br>您可以通过配置特定的 defaultProps 属性来定义 props 的默认值：</p><pre><code class="hljs plain">class Greeting extends React.Component &#123;  render() &#123;    return (      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;    );  &#125;&#125;&#x2F;&#x2F; 指定 props 的默认值：Greeting.defaultProps &#x3D; &#123;  name: &#39;Stranger&#39;&#125;;&#x2F;&#x2F; 不传递name将渲染出 &quot;Hello, Stranger&quot;：</code></pre><h3 id="18-非受控组件"><a href="#18-非受控组件" class="headerlink" title="18.非受控组件"></a>18.非受控组件</h3><p>在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。即使用类似ref等功能来从DOM节点获取表单数据。</p><p><strong>默认值</strong><br>在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value。</p><p><strong>文件输入</strong></p><pre><code class="hljs <input">使用 File API 与文件进行交互。</code></pre><p>class FileInput extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br>    this.fileInput = React.createRef();<br>  }<br>  handleSubmit(event) {<br>    event.preventDefault();<br>    alert(<br>      <code>Selected file - ${this.fileInput.current.files[0].name}</code><br>    );<br>  }</p><p>  render() {<br>    return (<br>      <form onSubmit={this.handleSubmit}><br>        <label><br>          Upload file:<br>          <input type="file" ref={this.fileInput} /><br>        </label><br>        <br /><br>        <button type="submit">Submit</button><br>      </form><br>    );<br>  }<br>}</p><p>ReactDOM.render(<br>  <FileInput />,<br>  document.getElementById(‘root’)<br>);</p><pre><code class="hljs plain">### 19. Web ComponentsReact 和 Web Components 为了解决不同的问题而生。Web Components 为可复用组件提供了强大的封装，而 React 则提供了声明式的解决方案，使 DOM 与数据保持同步。两者旨在互补。作为开发人员，可以自由选择在 Web Components 中使用 React，或者在 React 中使用 Web Components，或者两者共存。大多数开发者在使用 React 时，不使用 Web Components，但可能你会需要使用，尤其是在使用 Web Components 编写的第三方 UI 组件时。</code></pre><p>class HelloMessage extends React.Component {<br>  render() {<br>    return <div>Hello <x-search>{this.props.name}</x-search>!</div>;<br>  }<br>}</p><pre><code class="hljs plain">Web Components 通常暴露的是命令式 API。例如，Web Components 的组件 video 可能会公开 play() 和 pause() 方法。要访问 Web Components 的命令式 API，你需要使用 ref 直接与 DOM 节点进行交互。如果你使用的是第三方 Web Components，那么最好的解决方案是编写 React 组件包装该 Web Components。Web Components 触发的事件可能无法通过 React 渲染树正确的传递。 你需要在 React 组件中手动添加事件处理器来处理这些事件。常见的误区是要注意在 Web Components 中应该使用 class 而非 className。**在 Web Components 中使用 React**</code></pre><p>class XSearch extends HTMLElement {<br>  connectedCallback() {<br>    const mountPoint = document.createElement(‘span’);<br>    this.attachShadow({ mode: ‘open’ }).appendChild(mountPoint);</p><pre><code>const name = this.getAttribute(&apos;name&apos;);const url = &apos;https://www.google.com/search?q=&apos; + encodeURIComponent(name);ReactDOM.render(&lt;a href={url}&gt;{name}&lt;/a&gt;, mountPoint);</code></pre><p>  }<br>}<br>customElements.define(‘x-search’, XSearch);</p><p>```<br>注意：<br>如果使用 Babel 来转换 class，此代码将不会起作用。请查阅该 <a href="https://github.com/w3c/webcomponents/issues/587" target="_blank" rel="noopener">issue</a> 了解相关讨论。 在加载 Web Components 前请引入 <a href="https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs" target="_blank" rel="noopener">custom-elements-es5-adapter</a> 来解决该 issue。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React官方文档知识点-基本</title>
    <link href="/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%9F%BA%E6%9C%AC/"/>
    <url>/2020/05/28/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>最近准备面试前端工作，很多很久没使用的东西是应该复习一下了。首当其冲就是前端领域的三大框架。在这里就不再比较这三个框架的优劣，我从15年底开始用react，也算是很早期的一批用户了，所以先从官方文档出发复习一下React的知识点，顺便也学习一下新的特性。</p><p>官方文档比较多，我全部看了一遍。也将其中的要点摘录来下来，如果有缘读到这篇文章的你恰巧没有那么多时间复习，可以大概地瞟一眼我的摘录笔记。大概会有三篇，基本、进阶和Context+Hook</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-React不直接修改数据的原因："><a href="#1-React不直接修改数据的原因：" class="headerlink" title="1.React不直接修改数据的原因："></a>1.React不直接修改数据的原因：</h3><ul><li>简化复杂的功能，不直接在数据上修改可以让我们追溯并复用游戏的历史记录。</li><li>跟踪数据的改变，直接修改数据，很难跟踪到数据的改变，需要可变对象可以与改变之前的版本进行对比，这样整个对象树都需要被遍历一次。<br>跟踪不可变数据的变化相对来说就容易多了。如果发现对象变成了一个新对象，那么我们就可以说对象发生改变了。</li><li>确定在react中何时重新渲染，不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染。</li></ul><h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2.函数组件"></a>2.函数组件</h3><p>如果你想写的组件只包含一个 render 方法，并且不包含 state，那么使用函数组件就会更简单。<br>PS：当我们把 Square 修改成函数组件时，我们同时也把 onClick={() =&gt; this.props.onClick()} 改成了更短的 onClick={props.onClick}（注意两侧都没有括号）。</p><pre><code class="hljs plain">function Square(props) &#123;  return (    &lt;button className&#x3D;&quot;square&quot; onClick&#x3D;&#123;props.onClick&#125;&gt;      &#123;props.value&#125;    &lt;&#x2F;button&gt;  );&#125;</code></pre><h3 id="3-key"><a href="#3-key" class="headerlink" title="3.key"></a>3.key</h3><p>我们需要给每一个列表项一个确定的 key 属性，它可以用来区分不同的列表项和他们的同级兄弟列表项。<br>每当一个列表重新渲染时，React 会根据每一项列表元素的 key 来检索上一次渲染时与每个 key 所匹配的列表项。如果 React 发现当前的列表有一个之前不存在的 key，那么就会创建出一个新的组件。如果 React 发现和之前对比少了一个 key，那么就会销毁之前对应的组件。如果一个组件的 key 发生了变化，这个组件会被销毁，然后使用新的 state 重新创建一份。</p><p>key 是 React 中一个特殊的保留属性（还有一个是 ref，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 key 属性，然后把 key 直接存储在返回的元素上。虽然 key 看起来好像是 props 中的一个，但是你不能通过 this.props.key 来获取 key。React 会通过 key 来自动判断哪些组件需要更新。组件是不能访问到它的 key 的。</p><p>我们强烈推荐，每次只要你构建动态列表的时候，都要指定一个合适的 key。如果你没有找到一个合适的 key，那么你就需要考虑重新整理你的数据结构了，这样才能有合适的 key。</p><p>另外，设置key的元素是map() 方法中的元素，假如你的每个li都是包含在一个ListItem组件中返回的，你就应该在ListItem上加key，而不是li</p><h3 id="4-防注入攻击"><a href="#4-防注入攻击" class="headerlink" title="4.防注入攻击"></a>4.防注入攻击</h3><p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p><h3 id="5-将一个元素渲染为dom"><a href="#5-将一个元素渲染为dom" class="headerlink" title="5.将一个元素渲染为dom"></a>5.将一个元素渲染为dom</h3><pre><code class="hljs plain">&lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</code></pre><p>成为‘根’dom节点，仅使用react创建的应用通常只有一个根dom节点。<br>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()</p><pre><code class="hljs plain">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;ReactDOM.render(element, document.getElementById(&#39;root&#39;));</code></pre><h3 id="6-按需更新"><a href="#6-按需更新" class="headerlink" title="6.按需更新"></a>6.按需更新</h3><p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。<br>尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容<br>根据我们的经验，考虑 UI 在任意给定时刻的状态，而不是随时间变化的过程，能够消灭一整类的 bug。</p><h3 id="7-组件名称必须以大写字母开头。"><a href="#7-组件名称必须以大写字母开头。" class="headerlink" title="7.组件名称必须以大写字母开头。"></a>7.组件名称必须以大写字母开头。</h3><p>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<code>&lt;div /&gt;</code>代表 HTML 的 div 标签，而 <code>&lt;Welcome /&gt;</code> 则代表一个组件，并且需在作用域内使用 Welcome。</p><h3 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h3><p>当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）”。</p><p>同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（unmount）”。</p><p>于是我们有了componentDidMount() 和 componentWillUnmount()</p><p>当你需要在class中添加不参与数据流的额外字段，而它又需要初始化时，就在componentDidMount()来做。<br>比如在componentDidMount()中初始化一个计时器，在componentWillUnmount()中销毁它。</p><p>关于state:</p><ul><li>不要直接修改</li><li>state的更新可能是异步的，出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。<br>因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。<pre><code class="hljs plain">&#x2F;&#x2F; Wrongthis.setState(&#123;  counter: this.state.counter + this.props.increment,&#125;);</code></pre>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：<pre><code class="hljs plain">&#x2F;&#x2F; Correctthis.setState((state, props) &#x3D;&gt; (&#123;  counter: state.counter + props.increment&#125;));</code></pre></li></ul><h3 id="9-事件"><a href="#9-事件" class="headerlink" title="9.事件"></a>9.事件</h3><p>在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。</p><pre><code class="hljs plain">function ActionLink() &#123;  function handleClick(e) &#123;    e.preventDefault();    console.log(&#39;The link was clicked.&#39;);  &#125;  return (    &lt;a href&#x3D;&quot;#&quot; onClick&#x3D;&#123;handleClick&#125;&gt;      Click me    &lt;&#x2F;a&gt;  );&#125;</code></pre><p>在这里，e 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。如果想了解更多，请查看 <a href="https://zh-hans.reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a> 参考指南。</p><h3 id="10-条件渲染"><a href="#10-条件渲染" class="headerlink" title="10.条件渲染"></a>10.条件渲染</h3><p>之所以可以用 条件 &amp;&amp; 组件 的方式来渲染组件。是因为在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。</p><p>因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p><p>其次，在组件的 render 方法中返回 null 并不会影响组件的生命周期。即使返回null，componentDidUpdate 依然会被调用。</p><h3 id="11-表单"><a href="#11-表单" class="headerlink" title="11.表单"></a>11.表单</h3><p>React中，可变状态通常保存在组件的state属性中，且只能通过setState来更新。但HTML里类似input,select,textarea等元素本身自己维护着state。</p><p>一般情况下，我们还是倾向于让react的state成为组件的唯一数据源，即由react来渲染input，并控制用户输入过程中发生的操作，这样改造了的表单输入元素叫做“受控”组件。</p><pre><code class="hljs plain">...&lt;form ...&gt;    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;&lt;&#x2F;form&gt;...</code></pre><p>如上,显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p>对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。</p><p><a href="https://zh-hans.reactjs.org/docs/forms.html" target="_blank" rel="noopener">这里</a>了解诸如 textarea,select等受控组件在react中的用法。</p><p>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。</p><p>其次，类似<code>&lt;input type=&quot;file&quot; /&gt;</code>这种value为只读的元素，它们叫做非受控组件。<br>有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。</p><p>当然，直接找一些成熟的解决方案也是非常好的解决方式，比如<a href="https://jaredpalmer.com/formik" target="_blank" rel="noopener">Formilk</a> 就是不错的选择。但它们大多也是建立在受控组件和管理state的基础上的，所以了解一下原理并没有错。</p><h3 id="12-状态提升"><a href="#12-状态提升" class="headerlink" title="12.状态提升"></a>12.状态提升</h3><p>其实关于这个，只要用过React的人就应该非常熟悉，没什么值得再进一步探讨的。这里就提炼一下要点：  </p><ul><li>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”，如果当前组件的state在其它组件中被需要，我们就应该考虑将这个变量提升到共同的父组件中。利用好自上而下的数据流。</li><li>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。</li><li>利用好<a href="https://github.com/facebook/react/tree/master/packages/react-devtools" target="_blank" rel="noopener">React开发者工具</a>来定位UI中的bug</li></ul><p>提升方式与双向绑定的区别与优缺点： react的这种数据单向绑定方式实际是大势所趋，使得我们在追踪数据变化和调试程序的时候逻辑更加清晰，而双向绑定虽然一定程度减少了代码量，但一让查错变得困难，二也会在大量双向绑定存在的时候产生性能问题。</p><h3 id="13-不需要组件继承"><a href="#13-不需要组件继承" class="headerlink" title="13.不需要组件继承"></a>13.不需要组件继承</h3><p>组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p><p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p><h3 id="14-容器组件"><a href="#14-容器组件" class="headerlink" title="14.容器组件"></a>14.容器组件</h3><p>有一个特殊的prop：children。使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。</p><pre><code class="hljs plain">&lt;SomeComp color&#x3D;&quot;blue&quot;&gt;      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;        Welcome      &lt;&#x2F;h1&gt;      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;        Thank you for visiting our spacecraft!      &lt;&#x2F;p&gt;&lt;&#x2F;SomeComp&gt;</code></pre><p>出现在标签开始结束标记之间的这些内容，就会在SomeComp内部以props.children的形式存在。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>边写代码边学习Mask-rcnn</title>
    <link href="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/"/>
    <url>/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/</url>
    
    <content type="html"><![CDATA[<p>作为一个深度学习的学习者，你是不是苦于自己看了非常多的理论却难以下手实践？是否总觉得自己还没到写代码的时候？<br>如果你这么想，那么你看再多的理论，也无法真正踏进深度学习的大门。<br>就我个人而言，很多时候即使读完了论文仍然有点懵，很多地方感觉都一知半解，还有些地方可能直接就是不太明白。此时，如果能有源码看一看，才能真正将这篇文章搞明白。<br>so, “talk is cheap, show me the code” 实乃金玉良言。</p><p>这篇文章将使用pytorch modelzoo提供的现成Mask R-CNN预训练模型来进行fine-turing，实现一个目标检测和语义分割应用。并且在这个过程中来重新复习一下Mask R-CNN这个经典网络的一些原理。  </p><h2 id="Mask-R-CNN简介"><a href="#Mask-R-CNN简介" class="headerlink" title="Mask R-CNN简介"></a>Mask R-CNN简介</h2><p>Mask R-CNN来自何恺明大神2017年的论文，是一个通用的目标检测和实例分割的模型。它基于作者团队在2015年提出的faster rcnn模型，最主要的改动就是增加了一个分支来用于分割任务。<br>Mask R-CNN是anchor-based的模型，依然采用Faster RCNN的2-stage结构，首先用RPN找出候选region，然后在此基础上计算ROI并完成分类、检测和分割任务。<br>并没有添加各种trick，Mask RCNN就超过了当时所有的sota模型。</p><h2 id="定义DataSet并处理"><a href="#定义DataSet并处理" class="headerlink" title="定义DataSet并处理"></a>定义DataSet并处理</h2><p>我们将使用Penn-Fudan数据库中的行人图片数据来对模型进行微调。它包含170个图像和345个行人实例。<a href="https://www.cis.upenn.edu/~jshi/ped_html/PennFudanPed.zip" target="_blank" rel="noopener">数据在此</a>。<br>数据文件结构大致如下：</p><pre><code class="hljs plain">PennFudanPed&#x2F;  PedMasks&#x2F;    FudanPed00001_mask.png    FudanPed00002_mask.png    FudanPed00003_mask.png    FudanPed00004_mask.png    ...  PNGImages&#x2F;    FudanPed00001.png    FudanPed00002.png    FudanPed00003.png    FudanPed00004.png</code></pre><p>PedMasks中数据为PNGImages文件夹下对应图片的实例分割掩膜，如下：</p><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/mask_sample.png" srcset="/img/loading.gif" class="" title="原图片"><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/mask_sample1.png" srcset="/img/loading.gif" class="" title="mask图片"><p>即掩膜中不同的数值对应不同的实例的分割。</p><h3 id="定义Dataset类"><a href="#定义Dataset类" class="headerlink" title="定义Dataset类"></a>定义Dataset类</h3><p>上一篇文章说过，Dataset类是帮助我们处理原始数据并产出模型需要的输入数据的类。<br>而在我们这次的Mask R-CNN模型中，我们希望Dataset通过<strong>getitem</strong>能返回我们图像数据(H,W)以及图像的以下信息：</p><ul><li>boxes: 这张图片里所有的目标区域,格式为[x0,x1,y0,y1]，x∈[0,W], y∈[0,H]</li><li>labels: 每个边框的标签</li><li>masks: 每个图像的掩膜</li><li>image_id: 图片id</li><li>area：每个bbox的面积，用于计算IoU</li><li>iscrowd: 每个区域是否是人群<br>代码如下：<pre><code class="hljs plain">class PennFudanDataset(Dataset):    def __init__(self, root, transforms):        self.root &#x3D; root        self.transforms &#x3D; transforms        # 下载所有图像文件，为其排序。确保它们对齐,而且这样就把图片名字列出来了，方便了加载图片        self.imgs &#x3D; list(sorted(os.listdir(os.path.join(root, &quot;PNGImages&quot;))))        self.masks &#x3D; list(sorted(os.listdir(os.path.join(root, &quot;PedMasks&quot;))))    def __getitem__(self, idx):        # load images ad masks        img_path &#x3D; os.path.join(self.root, &quot;PNGImages&quot;, self.imgs[idx])        mask_path &#x3D; os.path.join(self.root, &quot;PedMasks&quot;, self.masks[idx])        img &#x3D; Image.open(img_path).convert(&quot;RGB&quot;)        # 请注意我们还没有将mask转换为RGB,        # 因为每种颜色对应一个不同的实例。0是背景        mask &#x3D; Image.open(mask_path)        # 将PIL图像转换为numpy数组        mask &#x3D; np.array(mask)        # 实例被编码为不同的颜色        obj_ids &#x3D; np.unique(mask)        # 第一个id是背景(即0)，所以删除它        obj_ids &#x3D; obj_ids[1:]        # 将相同颜色编码的mask分成一组        # mask为2维，用None扩充obj_ids维度，masks为3维，因为一张图片可能有多个实例分割        # 二进制格式        masks &#x3D; mask &#x3D;&#x3D; obj_ids[:, None, None]        # 获取每个mask的边界框坐标        num_objs &#x3D; len(obj_ids)        boxes &#x3D; []        for i in range(num_objs):            # masks[i]为2维，所以np.where返回2个tuple，分别为此颜色编码的元素在各个维度的下标            # 这里的数据中不同颜色的mask是语义分割的像素点，选出最大最小的x坐标和y坐标就得到了目标区域(x0,y0),(x1,y1)            pos &#x3D; np.where(masks[i])            xmin &#x3D; np.min(pos[1])            xmax &#x3D; np.max(pos[1])            ymin &#x3D; np.min(pos[0])            ymax &#x3D; np.max(pos[0])            boxes.append([xmin, ymin, xmax, ymax])        # 将所有转换为torch.Tensor        boxes &#x3D; torch.as_tensor(boxes, dtype&#x3D;torch.float32)        # 我们只检测行人这一个类(行人，所以直接全部置为1)        labels &#x3D; torch.ones((num_objs,), dtype&#x3D;torch.int64)        masks &#x3D; torch.as_tensor(masks, dtype&#x3D;torch.uint8)        image_id &#x3D; torch.tensor([idx])        area &#x3D; (boxes[:, 3] - boxes[:, 1]) * (boxes[:, 2] - boxes[:, 0])        # 假设所有实例都不是人群        iscrowd &#x3D; torch.zeros((num_objs,), dtype&#x3D;torch.int64)        target &#x3D; &#123;&#125;        target[&quot;boxes&quot;] &#x3D; boxes  # 这张图片里所有的目标区域        target[&quot;labels&quot;] &#x3D; labels   # 每个目标区域的类型        target[&quot;masks&quot;] &#x3D; masks    # 图像掩膜 mask        target[&quot;image_id&quot;] &#x3D; image_id  # 图片id        target[&quot;area&quot;] &#x3D; area          # 每个区域的面积        target[&quot;iscrowd&quot;] &#x3D; iscrowd    # 每个区域是否是人群(这里假设的都不是)        if self.transforms is not None:            img, target &#x3D; self.transforms(img, target)        return img, target            def __len__(self):        return len(self.imgs)</code></pre></li></ul><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>Mask-RCNN结构如下：</p><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/mask_rcnn_model.jpg" srcset="/img/loading.gif" class="" title="模型结构"><p>torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True) 为我们提供了一个预训练的Mask-RCNN模型。<br>修改这种预训练模型一般有2种思路，第一就是当我们数据较少时，我们就只将最后一层替换成我们的输入目标，然后进行微调。<br>另一种思路则是可以在原模型基础上进行修改，比如替换backbone，修改RPN的anchor数量，调整ROI维度等。  </p><p>我们先来看看第二种方式：<br><strong>修改backbone</strong>: Mask-RCNN 的backbone使用的Resnet101，整体还是比较大的，假如你想使用一些轻量的backbone，比如mobileNet，那么你可以进行替换<br><strong>修改rpn</strong>:Mask-RCNN 的anchor是如何生成的呢，注意看上面的结构图。输入数据在经过backbone之后，得到的feature-map其实是在原输入的基础上进行了32倍下采样。基于这个feature-map的每个元素，我们再进行一个3×3的卷积来增加感受野，然后对每个元素生成9个anchor来生成候选区域。这9个初始anchor包含3种长宽比(1:1,1:2,2:1),每种长宽比包含3种不同的面积。结构如下：</p><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/rpn_structure.jpg" srcset="/img/loading.gif" class="" title="rpn结构"><p>注意图上的各种数字，256表示的是骨干网络输出的通道数，k表示生成的anchor的数量。因为每个anchor有positive和negative，所以有2k个打分。而每个anchor会经过后续的回归找到针对正确区域的4个偏移量(x,y,w,h)，所以是4k个coordinates。<br>对于这些参数，我们也可以修改。<br><strong>修改RoI pooling</strong>：RoI pooling层复杂收集proposal，然后选取特征并送入后续的分类和检测FC网络。 要知道为了保留图片中事物的特性，我们很少对图片采用resize或者裁剪操作，而Mask-RCNN接受不同大小的图片输入，那么经过骨干和RPN网络后，各图片到此时的数据维度是不一样的。这种情况下我们没有办法通过FC等网络进行特征组合。RoI pooling层就是来解决这个问题的。它将收集到的proposal分为固定个数的区域(比如7*7)，然后对每这些区域使用max_pool处理，这样就得到了固定维度的输出。<br>其次，Faster RCNN在处理RoI pooling的过程中有2次取整操作：</p><ul><li>region proposal的xywh通常是小数，但是为了方便操作会把它整数化。</li><li>将整数化后的边界区域平均分割成 k x k 个单元，对每一个单元的边界进行整数化。<br>这将会导致RoI pooling后的输出与原图像对应的区域产生一些偏离，导致不能完全对应。第一个问题很好解决，不再取整即可。而解决第二个问题，则是使用双线性插值的方式来更加精确的找到每个边界的特征。我们在下面代码中看到的sampling_ratio=2就是这个方法的体现。</li></ul><p>代码如下：</p><pre><code class="hljs plain">from torchvision.models.detection import FasterRCNNfrom torchvision.models.detection.rpn import AnchorGenerator# 加载预先训练的模型进行分类和返回# 只有功能 # 主干采用mobileNet V2backbone &#x3D; torchvision.models.mobilenet_v2(pretrained&#x3D;True).features# FasterRCNN需要知道骨干网中的输出通道数量。对于mobilenet_v2，它是1280，所以我们需要在这里添加它backbone.out_channels &#x3D; 1280# 我们让RPN在每个空间位置生成5 x 3个锚点 PS：这里原文是3*3，即3种大小3种宽高比# 改成5种不同的大小和3种不同的宽高比。 # 因为每个特征映射可能具有不同的大小和宽高比，size为anchor box大小，aspect_ratios则是宽高比anchor_generator &#x3D; AnchorGenerator(sizes&#x3D;((32, 64, 128, 256, 512),),                                   aspect_ratios&#x3D;((0.5, 1.0, 2.0),))# 定义一下我们将用于执行感兴趣区域裁剪的特征映射，以及重新缩放后裁剪的大小。 # 如果您的主干返回Tensor，则featmap_names应为[0]。 # 更一般地，主干应该返回OrderedDict [Tensor]# 并且在featmap_names中，您可以选择要使用的功能映射。# 这里为RoIPooling层，将feature_map对应的原图中部分处理成7*7(output_size&#x3D;7)的大小然后再进行后续的分类和回归操作# 而sampling_ratio&#x3D;2则是原文中进行插值所选取的采样点，简单的说：采样点为2就是说7*7的每个区域内，都要再分成2*2个grid，然后对每个grid中心点进行采样，将这4个点的值求平均就是这个区域最终的值。roi_pooler &#x3D; torchvision.ops.MultiScaleRoIAlign(featmap_names&#x3D;[0],                                                output_size&#x3D;7,                                                sampling_ratio&#x3D;2)# 将这些pieces放在FasterRCNN模型中model &#x3D; FasterRCNN(backbone,                   num_classes&#x3D;2,                   rpn_anchor_generator&#x3D;anchor_generator,                   box_roi_pool&#x3D;roi_pooler)</code></pre><p>虽然第二种方式明显比较酷，但鉴于本示例中样本数据比较少，所以我们使用第一种方式:</p><pre><code class="hljs plain">def get_model_instance_segmentation(num_classes):    # 加载在COCO上预训练的预训练的实例分割模型    model &#x3D; torchvision.models.detection.maskrcnn_resnet50_fpn(pretrained&#x3D;True)    # 获取分类器的输入特征数    in_features &#x3D; model.roi_heads.box_predictor.cls_score.in_features    # 用新的头部替换预先训练好的头部    model.roi_heads.box_predictor &#x3D; FastRCNNPredictor(in_features, num_classes)    # 现在获取掩膜分类器的输入特征数    in_features_mask &#x3D; model.roi_heads.mask_predictor.conv5_mask.in_channels    hidden_layer &#x3D; 256    # 并用新的掩膜预测器替换掩膜预测器    model.roi_heads.mask_predictor &#x3D; MaskRCNNPredictor(in_features_mask,                                                       hidden_layer,                                                       num_classes)</code></pre><h2 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h2><p>在torchvision的官方库中，references/detection/里有很多辅助函数来简化训练和评估检测模型。<br>这里我们需要用到references/detection/engine.py，references/detection/utils.py和references/detection/transforms.py。<br>去<a href="https://github.com/pytorch/vision" target="_blank" rel="noopener">这里</a> download代码并将这几个文件拷贝到你的目录中即可。</p><p>其次，提前安装<a href="https://github.com/cocodataset/cocoapi/tree/master/PythonAPI" target="_blank" rel="noopener">cocoapi</a>,如果你在windows上，可能需要安装visial studio。<br>windows上也可以通过安装pycocotools来解决。whl见：<a href="https://pypi.org/project/pycocotools-windows/#files" target="_blank" rel="noopener">https://pypi.org/project/pycocotools-windows/#files</a></p><p>这一步没什么好说的，代码里也有足够的注释：</p><pre><code class="hljs plain"># 训练阶段按0.5几率水平翻转图像def get_transform(train):    transforms &#x3D; []    transforms.append(T.ToTensor())    if train:        transforms.append(T.RandomHorizontalFlip(0.5))    return T.Compose(transforms)# 在GPU上训练，若无GPU，可选择在CPU上训练device &#x3D; torch.device(&#39;cuda&#39;) if torch.cuda.is_available() else torch.device(&#39;cpu&#39;)# 我们的数据集只有两个类 - 背景和人num_classes &#x3D; 2# 使用我们的数据集和定义的转换dataset &#x3D; PennFudanDataset(&#39;data&#x2F;PennFudanPed&#39;, get_transform(train&#x3D;True))dataset_test &#x3D; PennFudanDataset(&#39;data&#x2F;PennFudanPed&#39;, get_transform(train&#x3D;False))# 在训练和测试集中拆分数据集indices &#x3D; torch.randperm(len(dataset)).tolist()dataset &#x3D; torch.utils.data.Subset(dataset, indices[:-50])dataset_test &#x3D; torch.utils.data.Subset(dataset_test, indices[-50:])# 定义训练和验证数据加载器data_loader &#x3D; torch.utils.data.DataLoader(    dataset, batch_size&#x3D;2, shuffle&#x3D;True, num_workers&#x3D;4,    collate_fn&#x3D;utils.collate_fn)data_loader_test &#x3D; torch.utils.data.DataLoader(    dataset_test, batch_size&#x3D;1, shuffle&#x3D;False, num_workers&#x3D;4,    collate_fn&#x3D;utils.collate_fn)# 使用我们的辅助函数获取模型model &#x3D; get_model_instance_segmentation(num_classes)# 将我们的模型迁移到合适的设备model.to(device)</code></pre><h2 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h2><p>我们使用SGD进行优化，训练10个epoch。并且通过比较在测试集上的mAP，保存效果最好的参数到best_state_dict中。</p><pre><code class="hljs plain">def train():    # 构造一个优化器    params &#x3D; [p for p in model.parameters() if p.requires_grad]    optimizer &#x3D; torch.optim.SGD(params, lr&#x3D;0.005,                                momentum&#x3D;0.9, weight_decay&#x3D;0.0005)    # 和学习率调度程序    lr_scheduler &#x3D; torch.optim.lr_scheduler.StepLR(optimizer,                                                   step_size&#x3D;3,                                                   gamma&#x3D;0.1)    # 训练10个epochs    num_epochs &#x3D; 10    best_mAp &#x3D; 0    for epoch in range(num_epochs):        # 训练一个epoch，每10次迭代打印一次        train_one_epoch(model, optimizer, data_loader, device, epoch, print_freq&#x3D;10)        # 更新学习速率        lr_scheduler.step()        # 在测试集上评价        eval_res &#x3D; evaluate(model, data_loader_test, device&#x3D;device)        # 将结果最好的参数保存下来        mAp_epoch &#x3D; float(eval_res.coco_eval[&#39;bbox&#39;].stats[0])        if mAp_epoch &gt; best_mAp:            torch.save(model.state_dict(),&#39;.&#x2F;best_state_dict&#39;)            best_mAp &#x3D; mAp_epoch    print(&quot;Finish training the model.&quot;)</code></pre><p>训练过程中你可以看到各项指标，我忘了截图，最后的COCO-style mAP大概是81左右，mask mAP为在78左右。</p><h2 id="使用效果最好的参数进行预测"><a href="#使用效果最好的参数进行预测" class="headerlink" title="使用效果最好的参数进行预测"></a>使用效果最好的参数进行预测</h2><p>完成了训练，接下来肯定就是我们的show time了。</p><pre><code class="hljs plain">model.load_state_dict(torch.load(&#39;.&#x2F;best_state_dict&#39;))    # # 切换为评估模式    model.eval()    # 让我们瞅一瞅效果    img, _ &#x3D; dataset_test[0]    with torch.no_grad():        prediction &#x3D; model([img.to(device)])    img_ori &#x3D; Image.fromarray(img.mul(255).permute(1, 2, 0).byte().numpy())    draw &#x3D; ImageDraw.Draw(img_ori)    masks &#x3D; prediction[0][&#39;masks&#39;]    masks_all &#x3D; Image.fromarray(np.sum(np.sum(masks.mul(255).byte().cpu().numpy(),axis&#x3D;0),axis&#x3D;0))            for [x1,y1,x2,y2] in prediction[0][&#39;boxes&#39;]:        draw.rectangle([(x1,y1),(x2,y2)],outline&#x3D;(255,0,0))    imgs &#x3D; [img_ori,masks_all]    for i,im in enumerate(imgs):        ax &#x3D; plt.subplot(1, 2, i + 1)        plt.tight_layout()        ax.axis(&#39;off&#39;)        plt.imshow(im)    plt.show()</code></pre><p>效果如下：</p><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/result01.jpg" srcset="/img/loading.gif" class="" title="效果图1"><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/result02.jpg" srcset="/img/loading.gif" class="" title="效果图2"><img src="/2020/05/19/%E8%BE%B9%E5%86%99%E4%BB%A3%E7%A0%81%E8%BE%B9%E5%AD%A6%E4%B9%A0mask-rcnn/result03.jpg" srcset="/img/loading.gif" class="" title="效果图3"><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本文源码在<a href="https://github.com/toulondu/mask-rcnn-brief" target="_blank" rel="noopener">这里</a></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html" target="_blank" rel="noopener">pytorch官网教程:TORCHVISION OBJECT DETECTION FINETUNING TUTORIAL</a><br><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">Faster R-CNN 论文</a><br><a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">Mask R-CNN 论文</a>、<br><a href="https://zhuanlan.zhihu.com/p/37998710" target="_blank" rel="noopener">令人拍案称奇的Mask RCNN</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>实践</tag>
      
      <tag>目标检测</tag>
      
      <tag>Mask R-CNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch中的数据加载和处理</title>
    <link href="/2020/05/15/PyTorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/15/PyTorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>这篇文章来自<a href="http://pytorch123.com/ThirdSection/DataLoding/" target="_blank" rel="noopener">官网中文教程</a>。<br>我稍稍作了总结，并把代码中稍微不好理解的地方做了详细的注释。</p><p>PyTorch提供了许多工具来简化和进行数据加载，使代码更具可读性。<br>这一节就主要介绍pytorch中是如何进行数据的加载和处理的。</p><p>先安装2个包：</p><ul><li>scikit-image：用于图像的IO和变换</li><li>pandas：用于更容易地进行csv解析</li></ul><p>在pytorch中进行数据加载，主要的步骤是：</p><ol><li>将下好的数据集放在本地文件夹中，本示例中的数据集是imagenet数据集标注为face的图片当中在 dlib 面部检测 (dlib’s pose estimation) 表现良好的图片，连接在<a href="https://download.pytorch.org/tutorial/faces.zip" target="_blank" rel="noopener">这里</a>。</li><li>先创建一个自己的数据集类(继承自dataset),在<strong>init</strong>中读取数据内容(根据数据的来源)，在<strong>getitem</strong>中根据idx读取文件。</li><li>在Dataset类中可以加入一个transform参数，它是一个函数，可以对样本数据进行预处理，包括Rescale,randomCrop等(输入图片大小不符合网络输入要求时)。我们可以通过torchvision.transforms.Compose这个函数式的方法将数据转换的方法合成一个方法作为我们最后的transform。</li><li>迭代从我们创建的Dataset中获取数据，这不需要我们自己实现，通过<strong>torch.utils.data.DataLoader</strong>提供的多线程实现我们可以更高效地载入数据。但在Windows上会存在内存泄漏的问题，所以无法使用多线程。</li><li>torchvision，这个包提供了常用的datasets和transform。</li></ol><p>代码如下,内部有详细注释</p><pre><code class="hljs plain">from __future__ import print_function, divisionimport osimport torchimport pandas as pd              #用于更容易地进行csv解析from skimage import io, transform    #用于图像的IO和变换import numpy as npimport matplotlib.pyplot as pltfrom torch.utils.data import Dataset, DataLoaderfrom torchvision import transforms, utils# 忽略警告import warningswarnings.filterwarnings(&quot;ignore&quot;)plt.ion()   # interactive mode# 下载数据集放在&#39;data&#x2F;face&#39;中，# 这个数据集实际上是imagenet数据集标注为face的图片当中在 dlib 面部检测 (dlib’s pose estimation) 表现良好的图片。# 我们要处理的是一个面部姿态的数据集。# 数据集是按如下规则打包成的csv文件:# image_name,part_0_x,part_0_y,part_1_x,part_1_y,part_2_x, ... ,part_67_x,part_67_y# 将csv中的标注点数据读入（N，2）数组中，其中N是特征点的数量。读取数据代码如下：landmarks_frame &#x3D; pd.read_csv(&#39;data&#x2F;faces&#x2F;face_landmarks.csv&#39;)n &#x3D; 32img_name &#x3D; landmarks_frame.iloc[n, 0]# values将Series作为ndarry或者ndarry-like类型的数据返回，取决于dtype类型. 这句代码取出了第n张图片的所以标记点信息landmarks &#x3D; landmarks_frame.iloc[n, 1:].values# 一对一对的坐标，2个一组landmarks &#x3D; landmarks.astype(&#39;float&#39;).reshape(-1, 2)print(&#39;Image name: &#123;&#125;&#39;.format(img_name))print(&#39;Landmarks shape: &#123;&#125;&#39;.format(landmarks.shape))print(&#39;First 4 Landmarks: &#123;&#125;&#39;.format(landmarks[:4]))# 展示一张图片和它对应的标注点作为例子。用到的函数都很容易看出作用def show_landmarks(image, landmarks):    &quot;&quot;&quot;显示带有地标的图片&quot;&quot;&quot;    plt.imshow(image)    plt.scatter(landmarks[:, 0], landmarks[:, 1], s&#x3D;10, marker&#x3D;&#39;.&#39;, c&#x3D;&#39;r&#39;)    plt.pause(0.001)  # pause a bit so that plots are updatedplt.figure()show_landmarks(io.imread(os.path.join(&#39;data&#x2F;faces&#x2F;&#39;, img_name)),               landmarks)plt.show()# 数据集类# torch.utils.data.Dataset是表示数据集的抽象类，因此自定义数据集应继承Dataset并覆盖以下方法 # * __len__ 实现 len(dataset) 返还数据集的尺寸。# * __getitem__用来获取一些索引数据，例如 dataset[i] 中的(i)。# 为面部数据集创建一个数据集类。# 我们将在 __init__中读取csv的文件内容，在 __getitem__中读取图片。# 这么做是为了节省内存 空间。只有在需要用到图片的时候才读取它而不是一开始就把图片全部存进内存里。# 我们的数据样本将按这样一个字典&#123;&#39;image&#39;: image, &#39;landmarks&#39;: landmarks&#125;组织。 # 我们的数据集类将添加一个可选参数transform 以方便对样本进行预处理。#下一节我们会看到什么时候需要用到transform参数。 __init__方法如下图所示：# 这部分代码也没什么值得说的class FaceLandmarksDataset(Dataset):    &quot;&quot;&quot;面部标记数据集.&quot;&quot;&quot;    def __init__(self, csv_file, root_dir, transform&#x3D;None):        &quot;&quot;&quot;        csv_file（string）：带注释的csv文件的路径。        root_dir（string）：包含所有图像的目录。        transform（callable， optional）：一个样本上的可用的可选变换        &quot;&quot;&quot;        self.landmarks_frame &#x3D; pd.read_csv(csv_file)        self.root_dir &#x3D; root_dir        self.transform &#x3D; transform    def __len__(self):        return len(self.landmarks_frame)    def __getitem__(self, idx):        img_name &#x3D; os.path.join(self.root_dir,                                self.landmarks_frame.iloc[idx, 0])        image &#x3D; io.imread(img_name)        landmarks &#x3D; self.landmarks_frame.iloc[idx, 1:]        landmarks &#x3D; np.array([landmarks])        landmarks &#x3D; landmarks.astype(&#39;float&#39;).reshape(-1, 2)        sample &#x3D; &#123;&#39;image&#39;: image, &#39;landmarks&#39;: landmarks&#125;        if self.transform:            sample &#x3D; self.transform(sample)        return sample        # 数据可视化# 实例化这个类并遍历数据样本。我们将会打印出前四个例子的尺寸并展示标注的特征点。 代码如下图所示：face_dataset &#x3D; FaceLandmarksDataset(csv_file&#x3D;&#39;data&#x2F;faces&#x2F;face_landmarks.csv&#39;,                                    root_dir&#x3D;&#39;data&#x2F;faces&#x2F;&#39;)fig &#x3D; plt.figure()for i in range(len(face_dataset)):    sample &#x3D; face_dataset[i]    print(i, sample[&#39;image&#39;].shape, sample[&#39;landmarks&#39;].shape)        # 创建子图，1行4列，最后一个参数为当前图编号 但也不知道为什么没成功，还是画成了4行1列    ax &#x3D; plt.subplot(1, 4, i + 1)    plt.tight_layout()    ax.set_title(&#39;Sample #&#123;&#125;&#39;.format(i))    # 不画坐标轴    ax.axis(&#39;off&#39;)    show_landmarks(**sample)    if i &#x3D;&#x3D; 3:        plt.show()        break# 数据变换# 通过上面的例子我们会发现图片并不是同样的尺寸。绝大多数神经网络都假定图片的尺寸相同。因此我们需要做一些预处理。# 让我们创建三个转换: * Rescale：缩放图片 * RandomCrop：对图片进行随机裁剪。这是一种数据增强操作 * ToTensor：把numpy格式图片转为torch格式图片 (我们需要交换坐标轴).# 我们会把它们写成可调用的类的形式而不是简单的函数，这样就不需要每次调用时传递一遍参数。我们只需要实现__call__方法，必 要的时候实现 __init__方法。我们可以这样调用这些转换:# tsfm &#x3D; Transform(params)# transformed_sample &#x3D; tsfm(sample)class Rescale(object):    &quot;&quot;&quot;将样本中的图像重新缩放到给定大小。.    Args:        output_size（tuple或int）：所需的输出大小。 如果是元组，则输出为         与output_size匹配。 如果是int，则匹配较小的图像边缘到output_size保持纵横比相同。    &quot;&quot;&quot;    def __init__(self, output_size):        assert isinstance(output_size, (int, tuple))        self.output_size &#x3D; output_size    def __call__(self, sample):        image, landmarks &#x3D; sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        h, w &#x3D; image.shape[:2]        if isinstance(self.output_size, int):            # output_size为int，将长或宽中小的那一个rescale成output_size，另一个保持纵横比缩放            if h &gt; w:                new_h, new_w &#x3D; self.output_size * h &#x2F; w, self.output_size            else:                new_h, new_w &#x3D; self.output_size, self.output_size * w &#x2F; h        else:            new_h, new_w &#x3D; self.output_size        new_h, new_w &#x3D; int(new_h), int(new_w)                # 看来skimage的这个库实现了对图片的各种转换操作        img &#x3D; transform.resize(image, (new_h, new_w))        # 别忘了对landmarks也要作同样比例的缩放！        landmarks &#x3D; landmarks * [new_w &#x2F; w, new_h &#x2F; h]        return &#123;&#39;image&#39;: img, &#39;landmarks&#39;: landmarks&#125;class RandomCrop(object):    &quot;&quot;&quot;随机裁剪样本中的图像.    Args:       output_size（tuple或int）：所需的输出大小。 如果是int，就按照int的值进行方形裁剪。             &quot;&quot;&quot;    def __init__(self, output_size):        assert isinstance(output_size, (int, tuple))        if isinstance(output_size, int):            self.output_size &#x3D; (output_size, output_size)        else:            assert len(output_size) &#x3D;&#x3D; 2            self.output_size &#x3D; output_size    def __call__(self, sample):        image, landmarks &#x3D; sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        h, w &#x3D; image.shape[:2]        new_h, new_w &#x3D; self.output_size                # 随机从图片中裁剪一块目标大小的图像出来,landmark也作相应处理 PS:h更小肿么办        top &#x3D; np.random.randint(0, h - new_h)        left &#x3D; np.random.randint(0, w - new_w)        image &#x3D; image[top: top + new_h,                      left: left + new_w]        landmarks &#x3D; landmarks - [left, top]        return &#123;&#39;image&#39;: image, &#39;landmarks&#39;: landmarks&#125;class ToTensor(object):    &quot;&quot;&quot;将样本中的ndarrays转换为Tensors.&quot;&quot;&quot;    def __call__(self, sample):        image, landmarks &#x3D; sample[&#39;image&#39;], sample[&#39;landmarks&#39;]        # 交换颜色轴因为        # numpy包的图片是: H * W * C        # torch包的图片是: C * H * W        image &#x3D; image.transpose((2, 0, 1))        return &#123;&#39;image&#39;: torch.from_numpy(image),                &#39;landmarks&#39;: torch.from_numpy(landmarks)&#125;                # 8.组合转换# 即把这些转换应用起来 # 我们想要把图像的短边调整为256，然后随机裁剪(randomcrop)为224大小的正方形。# 也就是说，我们打算组合一个Rescale和 RandomCrop的变换。 # 我们可以调用一个简单的类 torchvision.transforms.Compose来实现这一操作。具体实现如下图：scale &#x3D; Rescale(256)crop &#x3D; RandomCrop(128)composed &#x3D; transforms.Compose([Rescale(256),                               RandomCrop(224)])# 在样本上应用上述的每个变换。fig &#x3D; plt.figure()sample &#x3D; face_dataset[65]for i, tsfrm in enumerate([scale, crop, composed]):    transformed_sample &#x3D; tsfrm(sample)        ax &#x3D; plt.subplot(1, 3, i + 1)    plt.tight_layout()    ax.set_title(type(tsfrm).__name__)    show_landmarks(**transformed_sample)plt.show()# 9.迭代数据集# 让我们把这些整合起来以创建一个带组合转换的数据集。# 总结一下，每次这个数据集被采样时: # * 及时地从文件中读取图片 * 对读取的图片应用转换 * 由于其中一步操作是随机的 (randomcrop) , 数据被增强了# 我们可以像之前那样使用for i in range循环来对所有创建的数据集执行同样的操作。# 还记得FaceLandmarksDataset 这个类吗，忘了可以翻回去看一下transformed_dataset &#x3D; FaceLandmarksDataset(csv_file&#x3D;&#39;data&#x2F;faces&#x2F;face_landmarks.csv&#39;,                                           root_dir&#x3D;&#39;data&#x2F;faces&#x2F;&#39;,                                           transform&#x3D;transforms.Compose([                                               Rescale(256),                                               RandomCrop(224),                                               ToTensor()                                           ]))for i in range(len(transformed_dataset)):    sample &#x3D; transformed_dataset[i]    print(i, sample[&#39;image&#39;].size(), sample[&#39;landmarks&#39;].size())    if i &#x3D;&#x3D; 3:        break        # 但是，对所有数据集简单的使用for循环牺牲了许多功能，尤其是: * 批量处理数据 * 打乱数据 * 使用多线程multiprocessingworker 并行加载数据。# torch.utils.data.DataLoader是一个提供上述所有这些功能的迭代器。# 下面使用的参数必须是清楚的。一个值得关注的参数是collate_fn, 可以通过它来决定如何对数据进行批处理。但是绝大多数情况下默认值就能运行良好。# PS: 这里windows下跑是有问题的，因为windows在用这个多线程方法时有内存泄漏，详情：https:&#x2F;&#x2F;github.com&#x2F;pytorch&#x2F;pytorch&#x2F;pull&#x2F;5585# 概括点来说就是，因为在Windows上使用FileMapping（mmap）的差异引起的。# Windows上，所有相关线程都释放了FileMapping对象的引用，它才才能够被释放。没有提供其他方法可以将其直接删除。（例如shm_unlink） # 启用多线程后，子线程将创建一个FileMapping，然后主进程将其打开。之后子线程将尝试释放它，但是它的引用计数非零，因此无法在那时释放它。# 而且当前代码无法提供在可能的情况下再次关闭的机会，于是导致了内存泄漏。# 解决办法是权宜之计，即使用num_workers参数，令num_workers&#x3D;0,只使用一个主线程加载数据集。避免在windows中使用多线程。dataloader &#x3D; DataLoader(transformed_dataset, batch_size&#x3D;4,                        shuffle&#x3D;True, num_workers&#x3D;4)# 辅助功能：显示批次def show_landmarks_batch(sample_batched):    &quot;&quot;&quot;Show image with landmarks for a batch of samples.&quot;&quot;&quot;    images_batch, landmarks_batch &#x3D; \            sample_batched[&#39;image&#39;], sample_batched[&#39;landmarks&#39;]    batch_size &#x3D; len(images_batch)    im_size &#x3D; images_batch.size(2)    grid_border_size &#x3D; 2    grid &#x3D; utils.make_grid(images_batch)    plt.imshow(grid.numpy().transpose((1, 2, 0)))        for i in range(batch_size):        plt.scatter(landmarks_batch[i, :, 0].numpy() + i * im_size + (i + 1) * grid_border_size,                    landmarks_batch[i, :, 1].numpy() + grid_border_size,                    s&#x3D;10, marker&#x3D;&#39;.&#39;, c&#x3D;&#39;r&#39;)        plt.title(&#39;Batch from dataloader&#39;)        for i_batch, sample_batched in enumerate(dataloader):    print(i_batch, sample_batched[&#39;image&#39;].size(),          sample_batched[&#39;landmarks&#39;].size())    # 观察第4批次并停止。    if i_batch &#x3D;&#x3D; 3:        plt.figure()        show_landmarks_batch(sample_batched)        plt.axis(&#39;off&#39;)        plt.ioff()        plt.show()        break</code></pre><p><strong>torchvision</strong><br>torchvision包提供了 常用的数据集类(datasets)和转换(transforms)。<br>所以只要我们的数据符合这些数据集的要求，我们就不需要自己构造这些类比如。torchvision中还有一个更常用的数据集类ImageFolder。 它假定了数据集是以如下方式构造的:<br>root/ants/xxx.png<br>root/ants/xxy.jpeg<br>root/ants/xxz.png<br>.<br>.<br>.<br>root/bees/123.jpg<br>root/bees/nsdf3.png<br>root/bees/asd932_.png</p><p>其中’ants’,bees’等是分类标签。在PIL.Image中你也可以使用类似的转换(transforms)例如RandomHorizontalFlip,Scale。利 用这些你可以按如下的方式创建一个数据加载器(dataloader) :</p><pre><code class="hljs plain">import torchfrom torchvision import transforms, datasetsdata_transform &#x3D; transforms.Compose([        transforms.RandomSizedCrop(224),        transforms.RandomHorizontalFlip(),        transforms.ToTensor(),        transforms.Normalize(mean&#x3D;[0.485, 0.456, 0.406],                             std&#x3D;[0.229, 0.224, 0.225])    ])hymenoptera_dataset &#x3D; datasets.ImageFolder(root&#x3D;&#39;hymenoptera_data&#x2F;train&#39;,                                           transform&#x3D;data_transform)dataset_loader &#x3D; torch.utils.data.DataLoader(hymenoptera_dataset,                                             batch_size&#x3D;4, shuffle&#x3D;True,                                             num_workers&#x3D;4)</code></pre>]]></content>
    
    
    <categories>
      
      <category>编码工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
      <tag>基础</tag>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐系统技术概览</title>
    <link href="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/"/>
    <url>/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近在一边写一个web qa的问答模型一边刷leetcode，前者踩坑太多耗费了超出我预期的时间(还是攻城能力欠缺啊- -)，于是文章也有一段时间没更新了。<br>这期间抽空回顾和学习了目前工业界推荐系统常用的架构和算法，也亲自用代码实现了其中的部分算法，但总体还是停留在纸上谈兵的阶段。<br>虽然这篇文章我脸很厚的用了<strong><em>“概览”</em></strong>这个词，但我们都知道真实的工程落地远比纯粹的算法来得复杂，除了对应实际问题的难度，还会遭遇很多预想不到的困难，当然，这是题外话了~</p><p>这篇文章基本是对我近期看的这些推荐系统算法文章和视频的一个个人的文字总结，希望自己之后有应用的机会吧~</p><p>相关链接会放在文末。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工业界推荐系统的架构基本在宏观上比较趋同，大都可以粗分为<strong>召回(recall)</strong>和<strong>排序(rank)</strong>两个阶段。如下：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/recommandation-system-structure.png" srcset="/img/loading.gif" class="" title="推荐系统架构"><p>一般来说，平台往往动辄有上百万的item，不管是新闻应用，视频应用还是电商应用，要从海量的item中直接一步到位准确地找到推荐给某个用户的item是比较难的。 这两个阶段可以大概地看成是粗筛和精选，对某个用户来说，先通过一个比较快速而简单的方法从上百万的item中筛选出几百或者几千个高质量的item，再通过一个精确的方法仔细地将其中最好的一些item优先级确定下来，然后推荐给用户。前者就叫做召回阶段，后者则叫做排序阶段。</p><p>当然，落地的时候往往还会把排序阶段再分成 粗排-主排-重排，于是变成了四个阶段，这个后面再说~</p><p>下面就来介绍一下各个阶段常用的算法。</p><h2 id="召回算法"><a href="#召回算法" class="headerlink" title="召回算法"></a>召回算法</h2><p>召回算法有很多，主要分为3类：</p><ul><li>基于用户行为，简单地说就是“你看了什么，我就给你推荐什么“</li><li>基于用户档案，即给用户建立档案，根据用户档案中的标签推荐相应的item</li><li>基于隐语义，即基于机器学习方法，使用类似于embedding的方式<br>三者各有特点和优劣，基于用户行为直观上显得过于简单，基于用户档案也会存在用户改口味难以泛化的情况，而机器学习，本身就偏向黑盒，对于算法中的中间值难以解释，从而优化和修改显得困难。</li></ul><p>所以在使用这些算法的时候，一般是使用多路召回，即使用很多不同的召回算法分别进行召回，再把各自召回的结果组合起来作为最后的召回结果。</p><p>这里主要介绍 CF, personal rank, item2vec等算法。</p><h3 id="CF-协同过滤"><a href="#CF-协同过滤" class="headerlink" title="CF(协同过滤)"></a>CF(协同过滤)</h3><p>协同过滤是一种很老的算法，但沿用至今，它能够实现对特征进行学习的算法，即能够自行学习所需要使用的特征。</p><p>算法的核心是通过学习得到2个维度较低的矩阵，一个代表用户的embedding矩阵，一个代表item的embedding矩阵，计算某个用户对于item的推荐值的时候，只需要将二者进行点积计算。再直白一点，比如电影拥有两个特征，动作属性和爱情属性，某用户A的embedding向量为θ=[5，1]，即A对电影中动作元素的偏爱为5，相对地对爱情元素的偏爱只有1。而某一部电影的X=embedding为[4，1]，那么我们将这2个向量直接进行点积，matmul(θ,transpose(X))，得到的值就是这部电影对于这个用户的推荐值，将不同电影的推荐值进行排序，其中推荐值最高的不就是应该推荐给A的电影了吗。</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF01.png" srcset="/img/loading.gif" class="" title="CF图示"><p>怎么得到这两个embedding矩阵呢？基于上面电影推荐的例子，假设我们知道每部电影的特征矩阵，即X已知 求θ。那这个问题就变成了一个很简单的线性回归问题。 已有的打分数据作为样本，我们的目标函数只需要将 θ·XT减去真实评分 作为误差，很简单就可以定义出目标函数：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-formula-1.png" srcset="/img/loading.gif" class="" title="CF单体公式"><p>其中</p><ul><li>θ^(j)代表用户j的embedding向量。</li><li>x^(i)则代表电影i的embedding向量。</li><li>r(i,j)为1表示用户j已经为电影i打了分，0则表示没有。</li><li>y^(i,j)为用户j给电影i的评分<br>将这个公式推广到所有用户：<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-formula-1.png" srcset="/img/loading.gif" class="" title="CF公式"></li></ul><p>有了目标函数我们在将其对θ求导</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-derivative-theta.png" srcset="/img/loading.gif" class="" title="Lossd对θ导数"><p>然后直接用梯度下降之类的优化算法进行求解即可。</p><p>同理，假设θ已知，我们也可以用同样的方式求得X。</p><p>你可能会想，这不就成了鸡生蛋还是蛋生鸡的问题了吗？问题是两者我们都不知道啊？</p><p>是的，你很清醒，没有被带偏，实际情况中，用户的偏好和电影的属性都很难收集，更别提特征这个东西本就虚无缥缈，爱情属性动作属性你还能够理解，真出来几百个特征，你能分清什么是什么吗?</p><p>这个时候协同过滤就钻出来了，在面对这种两个未知数可以互相更新的情况下，最好的方式就是初始化其中一个未知数，然后求得另一个未知数，再反过来求第一个未知数，以此类推，在这个过程中，2个未知数就会产生协同作用，终会完成收敛，达到生命的大和谐。想想pagerank,想想EM，是不是很熟悉~</p><p>除了让二者彼此更新，还可以将二者同时计算：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/CF-form.png" srcset="/img/loading.gif" class="" title="协同过滤"><p>第一个式子是对每个用户，通过他们评价过的电影的类别来推断用户的喜好。第二个式子反过来，对每个电影，找出评价过它的用户的喜好来推断电影的类别。</p><p>其实二者前半部分就是第三个式子中的第一部分，只是第三个式子取得是一个(i,j)的对，表示所有用户评分过的电影。然后把二者的正则化都加上。实际上关于第三个式子，假如你假设x为常数，它就等于第一个式子，你假设θ为常数，它就等于第二个式子。</p><p>这就是协同过滤，实际实现过程中是可以用向量化实现从而不需要一个一个地进行计算的。这样的实现也叫做<strong>低秩矩阵分解(low rank matrix factorization)</strong>，还有一些地方叫做<strong>LFM(latent factor model)</strong>。不过矩阵分解方法并不是只此一家，SVD也是其中的佼佼者。这些方法最终都是得到user-item的隐式矩阵分解，获取二者的隐相量。</p><h3 id="personal-rank"><a href="#personal-rank" class="headerlink" title="personal rank"></a>personal rank</h3><p>推荐系统中最基础的两个部分就是user和item，整个系统也是user和item的交互，很容易想到，这就是一个图结构。那么，聪明的先行者们就想，能不能使用图算法来进行个性化推荐呢？ 当然可以~</p><p>user和item构成的图是一个<strong>二分图</strong>。</p><p>摘抄一下百度百科二分图的解释：<br>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p><p>而对于推荐系统而言，用户和item刚好是一个二分图，顶点分为user和item两类，且所有的变都是连接一个user和一个item的。</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_example.png" srcset="/img/loading.gif" class="" title="示例"><p>如上user和item构成了一个二分图，大写ABCD表示user，小写表示item。<br>personal rank比较各个item对于某个user的推荐值基于以下规则，其重要性一次递减：</p><ol><li>两个顶点间有多少条路径可以连通，如上图，从A-c，有A-a-B-c, A-d-D-c两条，而从A-e只有A-b-C-e一条，则c更值得推荐。</li><li>如果第一条相同，则比较连同路径的总长度，长度短者更值得推荐</li><li>如果1，2相同，则比较连同路径经过的顶点的出度和。</li></ol><p>基于此规则，我们来介绍personal rank方法的详细操作：<br>将二分图视作无向图，对于用户A进行推荐时，我们就从A节点出发开始在图上进行随机游走，以概率α从A所有的出度中等概率选择一条前进，到达对应顶点后(比如到了b)，再次以α的概率继续从a的出度中 等概率地选择一条继续前进，或者(1-α)的概率回到起点A，经历很多步之后，统计A到达各个item节点的次数求得概率。可以证明，只要步数足够大，此概率可以收敛。</p><p>把固定item对固定user的推荐得分记作PR值</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_formula.png" srcset="/img/loading.gif" class="" title="personal_rank公式"><p>其中out(v~)表示节点的出度。</p><p>可以看出，和pagerank算法非常相似，某个点的PR值等于 可以连通到该点的其它点的PR值除以自身出度 的和，即如a，有A,B可以连接到它，而A出度为3，B出度为2，故PR(a) = PR(A)/3 + PR(B)/2，再乘以一个概率α。A自身的PR值还要加上一个(1-alpha)。</p><p>直接迭代计算，复杂度太高了，像pagerank一样，我们也可以祭出矩阵来做：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_form_vec.png" srcset="/img/loading.gif" class="" title="向量化实现"><ul><li>r是一个n维向量，n是图中所有的节点数量，包括user节点和item节点，值则是每个节点的PR值。</li><li>r0也是一个n维向量，只有对应出发节点的元素为1，其余节点为0。</li><li>M是一个n阶转移矩阵，即图中节点与节点之间转移的概率，很好理解。<img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/trans_M.png" srcset="/img/loading.gif" class="" title="转移矩阵M">这样不断将结果代入公式，r最终可以收敛。</li></ul><p>再对公式进行移项处理，得到：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/personal_rank_final_form.png" srcset="/img/loading.gif" class="" title="移项处理后"><p>向量化实现很简单，你把r0换成矩阵试试。</p><p>PS：</p><ul><li>在计算时很多喜欢去掉1-α这个值，是因为推荐时我们更多的是要的推荐排序结果，而不是具体的推荐值，故去掉一个常数乘子没有影响。</li><li>可以看到其中M是稀疏矩阵，故E-αMT也是稀疏矩阵。针对它的存储和计算都有很多成熟的方法。</li></ul><h3 id="item2vec"><a href="#item2vec" class="headerlink" title="item2vec"></a>item2vec</h3><p>item2vec是一个神经网络算法，它基本是属于word2vec的衍生品。word2vec算法在诞生后，其简洁的方法和出色的效果掀起了一股万物皆可embedding的热潮，item2vec就是将word2vec应用到推荐系统上的算法。</p><p>所以要说item2vec，就逃不了word2vec，word2vec是一个用于NLP的算法，由大神Tomas Mikolov在2013年的论文《Efficient estimation of word representations in vector space》中提出。word2vec是一篇跨时代的论文，在word2vec诞生前，语言中的词都是使用one-hot、tf-inf等统计学方法或者NNLM这种计算量非常大的n-gram方式进行表示的，这样就会使得数据维度特别高(语料库大小)和精度低，而且词与词的关系也被忽略了。word2vec是一种将其进行降维，并且可以表示出词与词关系的方法。而且从它开始的embedding的概念，使我们在NLP研究方面，也终于可以开始站在巨人的肩膀上了。</p><p>它使用的方式就是embedding，将词用向量来表示。如下：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/word2vecSample.png" srcset="/img/loading.gif" class="" title="CF公式"><p>每一列是一个词的向量表示，向量中的每个值可以看做是一个特征，比如king和queen在性别和皇室上都非常突出，这是非常符合直觉的。<br>注意：上图只是为了举例，真实的embedding向量中的值基本是很难解释的。</p><p>要得到词的embedding,我们只需要将embedding矩阵与该词的one-hot相乘，如下：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/embedding_matrix.png" srcset="/img/loading.gif" class="" title="CF公式"><p>这个embedding矩阵如何得到呢？</p><p>word2vec论文中介绍了2种方式，CBOW和skip gram。我以skip gram为例作一个简要的介绍：</p><p>比如我们的语料库大小为10000，现在有一个英文句子： I will try to climb a very high mountain tomorrow.<br>我们随机选择其中一个词来预测它上下文的其它词，比如 climb，接着我们就可以在它一定的上下文范围内选取词作为样本，如：(climb,mountain),(climb, high),(climb, I),(climb,to)。</p><p>接着我们使用这些选取的词的one-hot来乘以一个Embedding矩阵 E得到其词向量，再通过一层神经网络+softmax得到一个10000维的向量，向量的各个值就代表每个词出现在其上下文中的概率。<br>即： Oc * E = ec -&gt; θT * ec -&gt; softmax -&gt; yhat<br>其中E和θ就是我们的待训练参数，直接使用优化器进行更新，便可以得到我们的E。</p><p>而CBOW则差不多，区别在于CBOW是用多个词来预测一个词。</p><p>当然，word2vec还有很多的细节，比如如何通过分层计算或者负采样来减少softmax层的计算量以及选取上下文词的启发式方法等。你可以在文末找到该论文进行翻阅。</p><p>而item2vec 就是把item当作词，一起出现的item当作上下文(比如用户浏览的item的集合)，使用上面的word2vec方式学习到item的embedding矩阵，有了它，再用任何向量近似算法计算向量相似性作为item相似性还不是任你施为~ </p><p>比如根据用户最近浏览过的item推荐与之相似的item。</p><p><strong>和CF的区别</strong><br>都是计算隐相量embedding，item2vec和上面介绍的MF主要的区别就是MF计算的embedding是user-item的，而item2vec计算出的embeeding是item-item的，从二者最终的使用方式上便可看出来。其次，二者计算的方式也完全不一样~</p><p>至于二者的效果，MF更容易推荐比较热门的内容，而item2vec在时间窗口的基础上更能推荐user最近浏览的相似item。</p><h3 id="基于内容"><a href="#基于内容" class="headerlink" title="基于内容"></a>基于内容</h3><p>基于内容的推荐方法最好解释，它的思路非常简单，就是建立在“用户经常看什么，我们就给他推荐什么”的思路上。它应该是诞生最早的推荐方法了。<br>这种方法的一个特点是它的独立性，即给某个用户进行推荐的策略只跟这个用户有关，而与其它用 户的行为无关。</p><p>缺点也比较明显，没什么扩展性，且需要已经有一些用户的行为历史。</p><p>算法的主要流程为：</p><ol><li>给所有的item做分类，或者打标签，早期通过手动或者提取关键字来做，而后可以通过上面介绍的embeding方法来计算相似性来做，或者SVD。</li><li>做用户画像，基于用户的长短期行为得到用户感兴趣的分类或者标签。</li><li>基于1，2的结果进行推荐</li></ol><p>召回方法还有不少，上面介绍的几个只是比较有代表性的几个算法，使用这些算法进行多路召回并合并结果，得到的新的集合，就是我们下一步，排序的输入了。</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>如果说召回决定了我们推荐效果的天花板，那么排序就决定了我们最终逼近天花板的程度。</p><p>在文章开头说过，排序阶段一般分成三个步骤：粗排-&gt;主排序-&gt;重排序。</p><p>粗排的原因时因为排序算法一般使用较为复杂的模型，使用较多的参数，速度相对较慢，如果召回阶段产出的item过多，会导致排序时间过长。于是先用一次粗排的过程来缩小样本范围。因此粗排一般使用比较简单的排序方法，比如使用后验CTR(点击率预估)和入库时的预估CTR值直接排序。</p><p>主排序则是我们要介绍的学习排序。</p><p>重排则是对主排的结果进行一些筛选，比如把结果放到一个类似于session model或者强化学习的模型里面进行重新排序，主要突出用户最近行为的特点。一般来说使用更少的样本范围，比如只把主排序结果的top k进行重排。</p><p>所以，最影响排序结果的，还是主排序部分。我们这里介绍的方法也是主排序的方法。</p><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归(logistic regression)这里就不展开来讲了，简单的说就是用函数关系来拟合真实的分布，然后用一个非线性的转换函数将结果拟合成分类结果。</p><p>推荐系统中基于一阶特征的逻辑回归如下：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/LR_formula.png" srcset="/img/loading.gif" class="" title="LR公式"><p>上式的x1,x2,…,xn代表不同的特征，sigmoid是一个可以将函数值映射到0-1间的函数：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/sigmoid.png" srcset="/img/loading.gif" class="" title="sigmoid公式"><p>接着再用交叉熵定义损失函数并用梯度下降更新求得w即可。</p><p>需要注意的是样本数据的选择和清洗，比如明显的异常数据便应该去掉。<br>其次，在特征的选取上，那种只有少量数据才拥有的特征意义就不大。</p><p>逻辑回归的缺点在于，要想取得好的结果，人工组合的特征不能少，但是人工特征需要不断组合、测试、调优，非常耗费人力，我们能否在模型层面自行进行特征组合呢？</p><h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p>单独写一篇文章来讲GBDT。<br>链接：todo..</p><h3 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT + LR"></a>GBDT + LR</h3><p>这个思路来自于《practical lessons from predicting clikcks on ads at facebook》这篇论文。</p><p>一句话就可以概括论文的主要想法：<br>逻辑回归进行融合特征时，一需要手动组合，二调参麻烦，而GBDT这种提升树模型不断用新的决策树学习残差的过程，就相当于不断地把特征变幻成了新的特征，如果把这种高维特征再放入LR模型中去训练，能不能得到更好的结果呢？</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/gbdt&lr.png" srcset="/img/loading.gif" class="" title="gbdt&amp;lr-model"><p>做法也很好实现，先训练好GBDT模型，再把每颗决策树的结果作为新的分类特征，然后使用LR模型进行训练。</p><p>看起来有一些trick，但实际效果确实在很多情况下略优于二者。<br>但2个模型并不是联合训练而是单独进行训练的，二者优化目标不同，从而解释性也就弱了。</p><h3 id="FM-factor-machine"><a href="#FM-factor-machine" class="headerlink" title="FM(factor machine)"></a>FM(factor machine)</h3><p>由上面的LR模型，我们有了一阶线性模型：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/state-1-LR.png" srcset="/img/loading.gif" class="" title="lr公式"><p>其实很容易想到，想要融入特征组合的概念，我们只需要添加一项：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/state-2-feature-combine.png" srcset="/img/loading.gif" class="" title="特征组合"><p>将特征两两组合构成新特征，再次放入线性模型，似乎就在模型层面完成了特征组合了。</p><p>其实不然，上诉方法在现实中是很难运用的，因为现实中的数据特征往往非常多，如淘宝京东的商品特征，量级超过千万。<br>这种情况下，数据矩阵是高度稀疏的，xi,xj同时不为0的可能性非常小，从而使得wij的训练几乎不可能。</p><p>FM模型就是一种求解这种高阶稀疏矩阵的方式，它将wij转化成2个向量大小为k的一维向量vi和vj的內积</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/fm-formula.png" srcset="/img/loading.gif" class="" title="fm公式"><p>它的本质还是我们上面提到的embedding，为什么它能解决稀疏矩阵的计算问题呢？<br>因为它的计算并不依赖于xi,xj这种特征组合是否出现，vi的本质是一个embedding, 于某个特征xi而言，只要有足够多xi和其它任何特征一起出现的样本，那么vi就是可以被训练出来的。此时和同样被训练出来的vj计算內积，便可以得到二者组合特征的权重。如下：</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/fm-illustrate.jpg" srcset="/img/loading.gif" class="" title="fm图解"><p>这就是embedding的核心特点，将one-hot或者1-0的硬匹配，转换成了向量间的软匹配，从而能够近似的得到2个本来匹配不上的特征的关系。</p><p><strong>公式化简</strong><br>上诉FM公式中的xixj交叉项是可以化简的，从而更好的进行model serving。</p><p>首先，我们要考虑的交叉项肯定不包括自己与自己组合，所以xixi这种情况不考虑，其次xixj,xjxi这种重复的，我们也只算一次。那么原始可以化简如下:</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/FM-briefy.png" srcset="/img/loading.gif" class="" title="fm化简"><ol><li>第一步式子中的1/2就是在去重，而减去的项则是自身与自身进行的特征组合。</li><li>第二步则是将向量內积展开，k是向量v的维度。</li><li>第三步则是先将k求和移到最外层，然后内层是在确定某个特征的第l位的情况下，与其它特征对应的第l位相乘并求和。</li><li>第三步到第四步，注意2个求和符号，虽然一个是i，一个是j，但范围相同，求和的对象也相同，所以实际是一样的，直接把乘改为平方即可。</li></ol><p>在实际的编码中就很好表示了，Σvilxi就是 样本特征矩阵*v, 最外层的Σ则是求和操作。</p><p>再根据实际情况是分类还是回归选择合适的损失函数进行求导即可，因为我们的式子里有常数项、一阶项和二阶交叉项，所以导数也是3个哦~</p><h3 id="使用DNN"><a href="#使用DNN" class="headerlink" title="使用DNN"></a>使用DNN</h3><p>深度学习在图像和NLP领域都搞得热火朝天如火如荼，那推荐系统可以蹭一蹭吗？答案是可以的，比起上诉的LR,GBDT,FM，神经网络模型最大的优点就是它可以完全自动地对特征进行非线性的组合，且覆盖了二阶组合和高阶组合。</p><p>将DNN引入推荐系统，最常用的方法就是wide and deep模型，它来自于google的一篇论文：《Wide &amp; Deep Learning for Recommender Systems》(文末附链接)。</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/wideAndDeep.png" srcset="/img/loading.gif" class="" title="wideAndDeep模型"><p>左边的wide部分是一个LR或者FM模型，而右边的deep则是一个神经网络模型，或者说MLP模型。w&amp;d模型的输出是将wide侧输出与deep侧最后一个隐层的输出相加，然后再进行激活得到的。这样做的目的是可以在一次反向传播中同时更新两边的参数，达到联合训练的目的。</p><img src="/2020/05/01/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/w&d-formula.png" srcset="/img/loading.gif" class="" title="w&amp;d激活"><p>x_cross是组合特征。<br>Loss目标函数则根据项目的实际情况自行定义，定义好后，再利用神经网络的反向传播进行求解即可。</p><p>当然，DNN也有其缺点。而且成也萧何败萧何，上面我们说自动组合特征是DNN的优点，但也是缺点。这种最纯粹的w&amp;d模型，只依靠MLP本身来自动对特征进行组合，但其内里却完全是一个黑盒子，我们并不知道真正组合了什么。</p><p>一般来说在实际进行使用的时候，这些排序模型在大规模数据上得到的效果是 w&amp;d&gt;LR+GBDT&gt;GBDT&gt;LR的。<br>当然，实际情况实际讨论，在模型落地的时候我们都会进行一些符合业务逻辑的修改，或者加入一些其它的想法。所以，选择合适的才是最重要的。</p><p>其次，对于实际上线的效果，有很多评估指标，通用的比如AUC、F1，测试集表现等。不同的业务还能根据实际业务定义相应的业务指标。</p><p>在特征的选取上，排序阶段则是可以尽量把相关的side info都特征化，毕竟这个阶段的目标就是精确，而更多的信息往往能够得到更好的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再总结一下流程，首先，使用多路召回并合并，从所有item中找到最适合推荐给用户的近千的item。进入排序阶段后，如果item过多导致排序时间长，可以加入粗排阶段，用一些简单的排序模型对召回返回的item进行一次筛选，进一步缩小item范围。接着再使用精确度较高的主排序模型进行精准排序。最后，再根据一些业务策略筛选，比如使实际推荐结果多样化，或者去除已读item等，然后再推荐给用户。</p><p>而为了验证模型效果和继续优化模型，我们要继续收集用户的各种行为和反馈。</p><p>这些行为和反馈一部分可以实时的用来更新在线推荐模型，让用户的实时行为在下一次刷新中即可得到体现。<br>而所有这些数据都应该被记录下来补充进我们的离线训练数据，从而用更大的模型进行离线训练，从而周期性地对模型进行更新。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Andrew Ng在coursera上的机器学习课程</a><br><a href="https://arxiv.org/abs/1301.3781v3" target="_blank" rel="noopener">word2vec论文:Efficient Estimation of Word Representations in Vector Space</a><br><a href="https://arxiv.org/abs/1603.04259" target="_blank" rel="noopener">item2vec论文:Item2Vec: Neural Item Embedding for Collaborative Filtering</a><br><a href="https://zhuanlan.zhihu.com/p/58160982" target="_blank" rel="noopener">知乎张俊林专栏：全能的FM模型</a><br><a href="https://quinonero.net/Publications/predicting-clicks-facebook.pdf" target="_blank" rel="noopener">gbdt&amp;lr论文：Practical Lessons from Predicting Clicks on Ads at Facebook</a><br><a href="https://arxiv.org/abs/1606.07792" target="_blank" rel="noopener">wide and deep论文:Wide &amp; Deep Learning for Recommender Systems</a></p>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>推荐系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的触发词识别</title>
    <link href="/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/"/>
    <url>/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本文参考andrew Ng, Sequence Model,  notebook-Trigger word detection.</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当你对苹果手机叫出”hey siri”，或对小米手机叫出”小爱同学”时，手机助手会立刻出现，这就是触发词识别系统，是一种识别音频并且在接收到某个触发词的时候激活的程序。不同于一般的语音识别需要大量的数据(超过10W小时)来训练，触发词系统的训练相对简单很多。</p><p>当你完成这个程序的时候，你可以将它扩展并布置到自己的电脑上，每当你说出某个激活词的时候，你的电脑可以随即自动打开某个app，或者是播放某一首音乐，听起来是不是很棒(吧？)。</p><p>因为声音数据是序列数据，我们用RNN&amp;GRU来做这个用识别触发词的程序，当程序听见语音”激活”的时候就给出一个某种反应。</p><h2 id="创建语音数据集"><a href="#创建语音数据集" class="headerlink" title="创建语音数据集"></a>创建语音数据集</h2><p>语音数据是很难获取的一类数据，这里我们需要的样本是10秒钟的数据，其中会随时出现我们的激活词。如果我们自己录制这些样本，因为数量比较大，这将会相当困难，于是我们考虑使用音频合成来制作我们的数据集。<br>首先，我们需要一些用于合成的元数据。因此我们需要去到各种环境中用不同人，不同口音录制”激活”以及任何其它语音。<br>将它们分为 positive\negative\background三类，positive为不同人不同口音念我们的激活词， negative 则是随机的其它词，background则是各种背景音，持续10秒。<br>PS：因为口音和词语长短不同，positive和negative的语音文件长度不定。</p><p>收集完语音后，我们需要对其进行处理。<br>一般来说，录制的声音文件根据设备的不同，拥有不同的HZ数。这里假设我们采集的样本为44100HZ，即录制的音频文件每秒有44100个数字。</p><p>要直接处理这种文件相对来说是较为困难的，所以更流行的做法是将数据用傅里叶变换转化为频谱(spectrogram)，这是信号处理相关的知识。这里我们直接用软件包实现。</p><pre><code class="hljs plain">x &#x3D; graph_spectrogram(&quot;audios&#x2F;train_example.wav&quot;)</code></pre>{% asset_img spectrogram-img.png 频谱片 %}<p>频谱图直观上体现的是频率(y轴)和时间(x轴)的图像关系，偏绿的颜色表示频率较高，而蓝色则相反。</p><p>频谱输出的数据维度是由程序的超参数和输入数据的长度决定的，这里我们使用的转换程序，10秒的数据将拥有5511个timestep，即Tx=5511.</p><pre><code class="hljs plain">print(&quot;spectrogram shape:&quot;, x.shape)</code></pre><p>输出为(101,5511)。<br>因此我们可以定义：</p><pre><code class="hljs plain">Tx &#x3D; 5511 n_freq &#x3D; 101 # 每个timestep中输入到模型中的频率数Ty &#x3D; 1375 # 我们程序的输出将会把10秒切分为1375份</code></pre><h3 id="合成语音"><a href="#合成语音" class="headerlink" title="合成语音"></a>合成语音</h3><p>三个步骤</p><ol><li>首先我们随机选取一个background音频</li><li>随机将0-4个正样本音频片段插入</li><li>随机将0-2个负样本音频片段插入<br>因为是我们控制的插入，我们同时可以得到Ylabel数据，即第几个timestep为激活词刚刚说完的时刻，记为y&lt;t&gt;=1,但一般来说为了避免label数据过于稀疏，我们会把激活词结束后的一段timestep的y都置为1，这里我们选择的一段为50个timestep。</li></ol><p>使用pydub包来处理音频，这个包将会用ms作为时间轴最小单位，10秒的数据将会有10000个timestep.</p><p>注意，合成后的音频应该依然为10秒，即正负样本都应该被background完全容纳，且二者互相不能重叠。</p><pre><code class="hljs plain">activates, negatives, backgrounds &#x3D; load_raw_audio()</code></pre><p>先来实现几个工具方法：</p><pre><code class="hljs plain"># 获取插入位置def get_random_time_segment(segment_ms):    &quot;&quot;&quot;    从10000个timestep中随机取一个timestep，作为之后的插入位置        Arguments:    segment_ms -- 要插入音频的ms长度        Returns:    segment_time -- a tuple(segment_start, segment_end) in ms，插入的开始和结束timestemp    &quot;&quot;&quot;        segment_start &#x3D; np.random.randint(low&#x3D;0, high&#x3D;10000-segment_ms)   # 确保插入的音频不会超出background的结尾    segment_end &#x3D; segment_start + segment_ms - 1        return (segment_start, segment_end)# 检查是否发生重叠def is_overlapping(segment_time, previous_segments):    &quot;&quot;&quot;    Arguments:    segment_time -- a tuple(segment_start, segment_end) 新插入片段的起止时间    previous_segments -- a list of tuples(segment_start, segment_end) 已经插入的片段的起止时间列表        Returns:    True or False 代表是否发生重叠    &quot;&quot;&quot;        segment_start, segment_end &#x3D; segment_time    overlap &#x3D; False        for previous_start, previous_end in previous_segments:        # 作业提示可以用 if ... &lt;&#x3D; ... and ... &gt;&#x3D; ... 这种形式实现，我没想出来呢        if (previous_start &gt; segment_end or segment_start &gt; previous_end) &#x3D;&#x3D; False :            overlap &#x3D; True    return overlap# 向background中随机位置插入音频片段，确保不会发生重叠和超出def insert_audio_clip(background, audio_clip, previous_segments):    &quot;&quot;&quot;     Arguments:    background -- 10秒钟的背景音频.      audio_clip -- 要插入的音频.     previous_segments -- 已经插入在background中的音频的起止时间        Returns:    new_background -- 插入音频后的新的background    &quot;&quot;&quot;        # Get the duration of the audio clip in ms    segment_ms &#x3D; len(audio_clip)        segment_time &#x3D; get_random_time_segment(segment_ms)        while is_overlapping(segment_time, previous_segments):        segment_time &#x3D; get_random_time_segment(segment_ms)    previous_segments.append(segment_time)        # 将音频在background的对应位置叠加进去    new_background &#x3D; background.overlay(audio_clip, position &#x3D; segment_time[0])        return new_background, segment_time</code></pre><p>插入了激活词语音后，我们就需要对Ylabel做出更新，如我们上面所说，将结束位置的后面50个y都更新为1。<br>因为我们的y的维度为1375而音频数据维度为10000，所以要记得做一下缩放。还要确保如果音频插入在background的尾部，导致后面没剩下50个值，注意不要越界。</p><pre><code class="hljs plain">def insert_ones(y, segment_end_ms):    &quot;&quot;&quot;    Arguments:    y -- numpy array of shape (1, Ty),训练样本的标签值    segment_end_ms -- 插入的激活音频的结束时间        Returns:    y -- 更新后的 labels    &quot;&quot;&quot;        # 缩放    segment_end_y &#x3D; int(segment_end_ms * Ty &#x2F; 10000.0)        for i in range(segment_end_y, segment_end_y + 50):        if i &lt; Ty:            y[0, i] &#x3D; 1        return y</code></pre><p>接下来就可以创建我们的训练样本了：</p><pre><code class="hljs plain">def create_training_example(background, activates, negatives):    &quot;&quot;&quot;    Creates a training example with a given background, activates, and negatives.        Arguments:    background -- a 10 second background audio recording    activates -- a list of audio segments of the word &quot;activate&quot;    negatives -- a list of audio segments of random words that are not &quot;activate&quot;        Returns:    x -- the spectrogram of the training example    y -- the label at each time step of the spectrogram    &quot;&quot;&quot;        # 减小噪音    background &#x3D; background - 20    y &#x3D; np.zeros((1,Ty))    previous_segments &#x3D; []        # 随机插入0-4段激活音频    number_of_activates &#x3D; np.random.randint(0, 5)    random_indices &#x3D; np.random.randint(len(activates), size&#x3D;number_of_activates)    random_activates &#x3D; [activates[i] for i in random_indices]        for random_activate in random_activates:        background, segment_time &#x3D; insert_audio_clip(background, random_activate, previous_segments)        segment_start, segment_end &#x3D; segment_time        y &#x3D; insert_ones(y, segment_end)    # 随机插入0-2段negative语音    number_of_negatives &#x3D; np.random.randint(0, 3)    random_indices &#x3D; np.random.randint(len(negatives), size&#x3D;number_of_negatives)    random_negatives &#x3D; [negatives[i] for i in random_indices]    for random_negative in random_negatives:        background, _ &#x3D; insert_audio_clip(background, random_negative, previous_segments)        # 标准化一波     background &#x3D; match_target_amplitude(background, -20.0)    # 导出训练样本    file_handle &#x3D; background.export(&quot;train&quot; + &quot;.wav&quot;, format&#x3D;&quot;wav&quot;)    print(&quot;File (train.wav) was saved in your directory.&quot;)        # 绘制频谱图    x &#x3D; graph_spectrogram(&quot;train.wav&quot;)        return x, y</code></pre><p>然后我们就用这个方法去创建一大堆的训练样本。<br>然后将创建好的训练样本赋值给 <strong><em>X</em></strong> 和 <strong><em>Y</em></strong></p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>我们用keres来实现这个模型。<br>模型共四层</p><ul><li>第一层是一个卷积层，因为我们的频谱数据为1维，所以是一维卷积(196个滤波器，滤波器长度15，步幅为4)，卷积后再做一次BN，并用ReLu激活，再用Dropout进行一次正则化。</li><li>第二层是一个GRU层，保证网络的记忆能力，并且也对输出的数据做Dropout和BN处理。</li><li>第三层继续用一个GRU层。</li><li>最后一层为全连接，且接sofxmax作为输出。</li></ul><p>如下：</p><img src="/2020/04/21/%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A6%E5%8F%91%E8%AF%8D%E8%AF%86%E5%88%AB/model.png" srcset="/img/loading.gif" class="" title="模型图片"><p>代码：</p><pre><code class="hljs plain">def model(input_shape):    &quot;&quot;&quot;    用keras构造训练模型        Argument:    input_shape -- 模型输入数据的形状    Returns:    model -- keras model 实例    &quot;&quot;&quot;        X_input &#x3D; Input(shape &#x3D; input_shape)        # Layer 1: CONV layer     X &#x3D; Conv1D(filters&#x3D;196,kernel_size&#x3D;15,strides&#x3D;4)(X_input)   # CONV1D    X &#x3D; BatchNormalization()(X)                                 # Batch normalization    X &#x3D; Activation(&quot;relu&quot;)(X)                                   # ReLu activation    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                    # dropout (use 0.8)    # Layer 2: First GRU Layer    X &#x3D; GRU(units&#x3D;128, return_sequences &#x3D; True)(X)           # GRU (use 128 units and return the sequences)    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                 # dropout (use 0.8)    X &#x3D; BatchNormalization()(X)                              # Batch normalization        # Layer 3: Second GRU Layer    X &#x3D; GRU(units&#x3D;128, return_sequences &#x3D; True)(X)           # GRU (use 128 units and return the sequences)    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                 # dropout (use 0.8)    X &#x3D; BatchNormalization()(X)                              # Batch normalization    X &#x3D; Dropout(rate&#x3D;0.8)(X)                                 # dropout (use 0.8)        # Layer 4: Time-distributed dense layer    X &#x3D; TimeDistributed(Dense(1, activation &#x3D; &quot;sigmoid&quot;))(X) # time distributed  (sigmoid)    model &#x3D; Model(inputs &#x3D; X_input, outputs &#x3D; X)        return model</code></pre><p>注意上面最后一层的 TimeDistributed 层，<a href="https://machinelearningmastery.com/timedistributed-layer-for-long-short-term-memory-networks-in-python/" target="_blank" rel="noopener">这里</a>有关于它的使用的完全解释。<br>简单的说，它是使用timestep来进行操作，且对每个timestep的数据都共享权重。<br>比如这里我们用它包装了Dense，即是说对每个timestep的结果，都使用同样的参数计算Dense输出结果。</p><p>接下来就可以进行训练了：</p><pre><code class="hljs plain">opt &#x3D; Adam(lr&#x3D;0.0001, beta_1&#x3D;0.9, beta_2&#x3D;0.999, decay&#x3D;0.01)model.compile(loss&#x3D;&#39;binary_crossentropy&#39;, optimizer&#x3D;opt, metrics&#x3D;[&quot;accuracy&quot;])model.fit(X, Y, batch_size &#x3D; 5, epochs&#x3D;100)</code></pre><p>得到：<br>Epoch 100/100<br>26/26 [==============================] - 34s - loss: 0.0610 - acc: 0.9796 </p><p>接下来如果有开发集，可以对模型进行测试，开发集样本最好来自真实分布，即去真实的环境说话进行录音。</p><h2 id="预测和更多操作"><a href="#预测和更多操作" class="headerlink" title="预测和更多操作"></a>预测和更多操作</h2><p>接下来就可以用这个训练好的模型进行预测了：</p><pre><code class="hljs plain">x &#x3D; graph_spectrogram(filename)x  &#x3D; x.swapaxes(0,1)x &#x3D; np.expand_dims(x, axis&#x3D;0)predictions &#x3D; model.predict(x)</code></pre><p>还可以在触发的时候做更多的操作：</p><pre><code class="hljs plain">consecutive_timesteps &#x3D; 0for i in range(Ty):        consecutive_timesteps +&#x3D; 1        if predictions[0,i,0] &gt; threshold:            # 任何操作            whatever_you_wanna_do()</code></pre>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>RNN</tag>
      
      <tag>Trigger word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习中的各种优化器算法</title>
    <link href="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>深度学习中的优化器有很多种，除了我们熟悉的梯度下降外，还有一些诸如 RMSProp，adam 等优秀的优化器。来了解一波~</p><h2 id="梯度下降-GD-BGD-MBGD"><a href="#梯度下降-GD-BGD-MBGD" class="headerlink" title="梯度下降 GD,BGD,MBGD"></a>梯度下降 GD,BGD,MBGD</h2><p>梯度下降（GD：gradient descent）大家都很熟悉，这里也不做详细介绍。整体就是先初始化求解参数，然后通过求解损失函数对求解参数的导数来对我们的求解参数进行更新，直到收敛。 </p><p>梯度下降分为BGD（batch：批量梯度下降），SGD（stochastic：随机梯度下降）和 MBGD(Mini-Batch：小批量梯度下降)，区别在于每次更新梯度时使用的样本的数量，分别为全部样本，单个样本和一部分样本。</p><p>梯度下降找到的最优解一般为函数的一个鞍点，即局部最优解。<br>MBGD和SGD因为样本较少，随机性太强，梯度往往震荡很大，如下：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/GDvsMBGD.png" srcset="/img/loading.gif" class="" title="GDvsMBGD"><p>要解决这个问题，使用MBGD进行优化时我们可以对学习率进行衰减来使之收敛。</p><p>PS:因为计算机本身的一些性质，将批次量设置为2的幂数计算会更快。</p><p>当然，还有比小批次下降更快的算法。但在学习它们之前，我们首先要了解指数加权平均。</p><h2 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h2><p>什么是指数加权平均？</p><p>参考吴恩达老师对此的讲解，用一个例子来进行说明：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/LondonTempreture.png" srcset="/img/loading.gif" class="" title="LondonTempreture"><p>上图是伦敦一年之中每天的温度情况，我们来对它做一些处理，把每天的温度值记作Vn。则：<br>V0=0， V1 = 0.9*V0 + 0.1*θ1， V2=0.9V1 + 0.1*θ2，…<br>θ为上图中当天真实的温度值，这个0.9我们记作β，那么公式记为：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/formulaVt.png" srcset="/img/loading.gif" class="" title="formulaVt"><p>稍微进行一下联想，这个V可以近似看做是之前1/(1-β)天的平均值，当我们分别取β=0.9(红色曲线)和0.98(绿色曲线)时，图像为：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/TempretureHandled.png" srcset="/img/loading.gif" class="" title="TempretureHandled"><p>β取0.9，我们把这个式子展开：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/UnfoldFormulaV.png" srcset="/img/loading.gif" class="" title="UnfoldFormulaV"><p>θ随着时间推后是β的指数级衰减，且一般来说，指数加权的衰减大约会在1/(1-β)后衰减到大约三分之一的程度，比如0.9的1/(1-0.9)次方约等于0.35，所以我们说它大约是最近10天的平均值。这就是指数加权平均名称的由来。</p><p>指数加权平均减少了存储空间的使用，当我们需要某个V的值时，只需要通过计算即可获得，因此它在机器学习中得到了大量的应用。</p><p>细心的你可能注意到，我们的V0取值为0，这会在计算初期的时候产生较大的误差值。<br>因此在很多时候，我们会对V的值进行<strong><em>偏差修正</em></strong>。<br>使 Vt = Vt/(1-β^t)  ，从而对Vt进行放大，而随着t的增大，放大率会逐渐趋于1。</p><p>有了这个基础，我们就可以介绍一些其它的优化器方法。</p><h2 id="动量梯度算法（momentum）"><a href="#动量梯度算法（momentum）" class="headerlink" title="动量梯度算法（momentum）"></a>动量梯度算法（momentum）</h2><p>算法的主要思想其实很简单，就是把我们刚才学习的指数加权平均用来计算梯度，然后用计算得到的梯度来进行参数更新。<br>在上面的梯度下降算法中，考虑多维度的情况，如下：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/momentumExample.png" srcset="/img/loading.gif" class="" title="momentumExample"><p>于收敛来说，竖直方向的震荡显然是无益的，我们希望能够减小竖直方向的震荡。</p><p>动量梯度下降的步骤如下<br>第t次迭代：</p><ol><li>用当前小批量样本 计算 参数W和 偏差b的导数</li><li>Vdw = βVdw + (1-β)dw， Vdb = βVdb + (1-β)db</li><li>W := W - αVdw,   b := b-αVdb </li></ol><p>end<br>我们还是对批次数量进行迭代，整个算法中中有2个超参数，α和β，α为学习率，β是我们上面学习到的指数加权。</p><p>为什么咋这么做可以有效呢？因为指数加权平均的平均，它就让垂直方向上相反的震荡被平均从而变小，而水平方向的震荡方向是相同的，平均值依然很大，故整体收敛速度就加快了。</p><p>PS:动量梯度下降时基本不用偏差修正，β基本都是选择0.9。</p><h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>RMSprop全称为均方根传递(Root Mean Square prop), 它也可以加速梯度下降。<br>计算方式如下：</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/RMSPropStep.png" srcset="/img/loading.gif" class="" title="RMSPropStep"><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/RMSPropImg.png" srcset="/img/loading.gif" class="" title="RMSPropImg"><p>RMSprop主要的思想是缩小大的震荡，加快小的震荡。如上图，垂直方向的震荡很大，而水平方向很小，RMSprop就会缩小垂直方向的震荡，加快水平方向的速度。<br>原理很简单，如果垂直方向的震荡较大，那么Sdb就会很大，那么作为除数，更新速度就减慢了，相反，水平方向较慢，Sdw就较小，W的更新速度就加快了。<br>当然，实际应用中，并没有垂直水平这么简单，我们加快的是慢的维度，减慢的是快的维度。<br>而且为了防止除0发生，通常在分母上我们会加一个很小的EPSON，大概10e-8</p><p>接下来，我们把RMSprop和动量结合起来，会得到一个更好的优化算法。<br>为了防止冲突，RMSprop中的β，我们用β_2表示</p><h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>adaptive moment estimation 自适应矩估计<br>adam优化算法实际上就是将RMSprop和动量梯度下降结合起来的算法。<br>在机器学习领域和深度学习领域中，曾经提出了非常多的优化算法，但大多数算法都不能很好的适应于不同的网络结构，adam算法是少有的在非常多网络结构中都能够产生非常好效果的算法。</p><p>在机器学习领域和深度学习领域中，曾经提出了非常多的优化算法，比如Adagrad,Adadelta等，但大多数算法都不能很好的适应于不同的网络结构，adam算法是少有的在非常多网络结构中都能够产生非常好效果的算法。</p><p>初始化Vdw，Sdw,  Vdb, Sdb为0</p><img src="/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%AE%97%E6%B3%95/AdamStep.png" srcset="/img/loading.gif" class="" title="AdamStep"><p>l为网络层数，两个β分别是动量梯度和RMSprop中的加权，α为学习率，同样，为了防止除0发生，通常在分母上我们会加一个很小的EPSON，大概10e-8（上图没加）。</p><p>几个超参数，一般β1选择0.9，β2选择0.999，EPSON选择10e-8。<br>而α，一个好的方法就是逐渐减小学习速率，使用一个衰减率来对学习率进行衰减。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT笔记-简介</title>
    <link href="/2020/04/03/BERT%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/04/03/BERT%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>BERT，全名 Bidirectional Encoder Representation from Transformers。是Google AI团队在2018年推出的一个NLP模型，在机器阅读理解顶级水平测试SQuAD1.1上全面超越人类表现，并在11项NLP测试中拿到最佳成绩。这也导致BERT的大火。</p><p>BERT的出现彻底改变了pre-train产生词向量和下游NLP训练任务间的关系。</p><p>//todo 留坑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer模型简介(笔记)</title>
    <link href="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Transformer来自Google 2017年的一篇文章，在原来的Attention&amp;RNN模型上抛弃了RNN，用全attention的结构取得了更好的效果。<br>这里做一做自己学习的笔记，也算一个简单的介绍。<br>内容图片很多来自于原论文<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>和<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a>这篇文章。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>原论文给出的结构如下：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/structureOfTransformer.png" srcset="/img/loading.gif" class="" title="transformer结构"><p>可以看到由左右两个部分，左边的Encoders和右边的Decoders组成。两边都有一个”N×”,表示各自由N个同样的结构重复N次组成，原文中是6。就是下面图中的样子。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/encodersAndDecoders.png" srcset="/img/loading.gif" class="" title="展开"><h2 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h2><p>我们来看一看Encoder部分。</p><p>因为是NLP的案例，所以我们首先要把我们的输入数据，即词变成词向量，这通过embedding实现，embedding后的数据作为Encoder的输入。<br>虽然有很多encoder，但embedding只用在最下面一层的encoder上，其它的encoder都是用上一层encoder的输出作为输入。</p><p>每个encoder都是一样的结构，都由两个子结构组成：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/EachEncoder.png" srcset="/img/loading.gif" class="" title="encoder组成"><p>self-attention的作用是，当你在处理某个具体的词时，self-attention允许你从句子中的其它位置处寻找线索，从而对当前词的理解和预测起到帮助。</p><h3 id="self-attention-细节"><a href="#self-attention-细节" class="headerlink" title="self-attention 细节"></a>self-attention 细节</h3><p>计算self-attention主要有以下几个步骤</p><p><strong>第一步</strong><br>计算self-attention的第一步是从每个输入向量中创建出3个向量(Querry,Key,Value)。他们通过把embedding分别与三个矩阵相乘得到，三个矩阵通过训练过程得到。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformerSelfAttentionVectors.png" srcset="/img/loading.gif" class="" title="QSV"><p>Q,S,V较之embedding的维度要小，在文中的维度是64，而embedding的维度是512。不必完全一样，但这是一种使得计算比较稳定的结构选择。</p><ul><li>Q = WQ * x</li><li>K = WK * x</li><li>V = WV * x</li></ul><p><strong>第二步</strong><br>计算self-attention的第二步是计算一个score。 假设我们正在计算的句子的第一个单词为”Thinking”。我们需要把输入的句子中的每一个词与这个词运算来得到一个score，这个score决定了我们在encode当前词的时候句子其它位置所施加的影响。</p><p>计算方法是把当前次的Q与要计算的词的K值进行点乘。即如果我们要计算#1位置处的self-attention，第一个我们要计算的score将是把q1和k1点乘，第二个socre则是把q1和k2进行点乘。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/SelfAttentionScore.png" srcset="/img/loading.gif" class="" title="计算score"><p><strong>第三步和第四步</strong><br>第三步和第四步是将得到的score除以8，这个8是QKV向量的维度64的平方根。这可以让梯度更加稳定(直接归一值差距较大)。当然可以不是8，这里只是一个默认值。接着将结果传递给一个softmax操作，这将把socre的值标准化，使它们都为正，且和为1。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/selfAttentionSoftmax.png" srcset="/img/loading.gif" class="" title="计算权重"><p><strong>第五步</strong><br>第五步是将每个V与第四步的结果相乘。这一步从直觉上讲是保留当前词想要关注的其它词语的完整性，同时丢掉不相关的词语(通过乘以了非常小的数)。</p><p><strong>第六步</strong><br>将得到的带权重的数据向量相加。这将得到self-attention层在这个位置(我们这里是第一个词)的输出。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/selfAttentionOutput.png" srcset="/img/loading.gif" class="" title="encoder输出"><p>这就是self-attentionde的计算过程，结果向量我们将传递给接下来的 feed-forward nertal network处理。<br>当然，在实际实现中，这些计算都可以通过矩阵形式的计算从而更加快速。</p><p><strong>self-attention的矩阵计算</strong><br>使用矩阵，第二步到第六步实际上可以在一个公式内进行计算：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/selfAttentionMatrixCalculation.png" srcset="/img/loading.gif" class="" title="矩阵计算公式"><h3 id="multi-headed"><a href="#multi-headed" class="headerlink" title="multi-headed"></a>multi-headed</h3><p>文章进一步用一个叫做”multi-headed” attention的结构增强了self-attention。它从2个方面提升了attention层的表现：<br><strong>扩张了模型关注其他位置的能力</strong><br>在我们上面的例子中，对thinking的编码就包含了句中其它位置词的影响(当然，最大的影响依然是它自己)。在解析一些有明显指向性的代词时就显得非常有用。比如“The animal didn’t cross the street because it was too tired”中的”it”指代的谁。<br><strong>给了attention层多重”表述子空间”</strong><br>这主要通过多组[WQ,WK,QV]来实现，文中使用了8组WQ,WK,QV，这些矩阵都通过随机初始化赋值。即是说我们会得到8组QKV，从而得到8个输出矩阵。每一个都是输入数据的一个表述子空间。</p><p>在传递给feed-forward network前，我们需要将他们处理成一个矩阵。通过将这8个矩阵堆叠起来，再与一个权重矩阵WO相乘得到。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformer_attention_heads_weight_matrix_o.png" srcset="/img/loading.gif" class="" title="concat结果"><p>以上大概就是 multi-headed self-attention 的内容。原文将他们放到一张图上：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/encoderTotalLook.png" srcset="/img/loading.gif" class="" title="整体造型"><h3 id="position-encoding"><a href="#position-encoding" class="headerlink" title="position encoding"></a>position encoding</h3><p>因为放弃了使用RNN，那么句子中词与词的位置关系就被忽略了，文中使用了一种position encoding的方式将位置信息补入模型中。<br>这通过给每一个input embedding加上一个vector来实现。这些vector遵循一种<strong><em>特殊的模式</em></strong>，它存储了每个词的位置信息，通过把它与embedding相加，从而把这种信息代入到后面的QKV和点乘的计算过程中。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformer_positional_encoding_vectors.png" srcset="/img/loading.gif" class="" title="位置编码"><p>如果我们的embedding是512维的向量，那么要加的positional encoding 向量也是512维。</p><p>关于位置编码，文中使用的是三角函数的形式。</p><p>大概说一下什么是位置编码和为什么要使用三角函数。<br>要对位置进行编码，最简单的方式莫过于直接使用单词在文本中的位置，即1，2，3，…，N。但缺点过于明显，如果文本较长，那么位置编码的大小跨度就太大了，将这样的数据加入到模型训练中，很有可能是会喧宾夺主的抢占embedding的重要性。<br>同样，将刚才的顺序除以文本长度也是不行的，如1/N,2/N,3/N,…1。<br>我们需要位置信息，其中一个重要的信息就是相对位置信息，而这种处理方式，会导致相隔同样距离的两个词，在长度不同的文本中得到的相对位置信息不一致，甚至差距较大。<br>总结之后，那么真正适合用来做位置编码的函数似乎就是 连续且有界的周期性函数。有界保证值域不会太大，周期性保证一定程度上编码的差异会摆脱文本长度的影响，而连续则保证了两个比较靠近的词不会出现差距很大的情况。</p><p>于是文中使用了sin和cos函数，连续而且周期稳定，值域[-1,1]。</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/PosEncodingformula.png" srcset="/img/loading.gif" class="" title="位置编码公式"><p>加入了dmodel和i两个参数，dmodel是embedding的维度，在文中就是512，用于增大位置编码的空间表现范围。i为向量的某一维度，dmodel=512，那么i就是[0,255],这样在奇偶维度分别使用sin和cos。这样就从取值范围和取值方法两个方向上增加了取值的多样性。让位置编码更加科学。</p><p>当然，这个函数作者应该也是通过自身的经验与不断的实验得到的。</p><p>PS：GOOGLE BERT中用了新的取位置信息的方法，position embedding，这是后话。</p><h3 id="残差网络-Residual-network-的使用"><a href="#残差网络-Residual-network-的使用" class="headerlink" title="残差网络(Residual network)的使用"></a>残差网络(Residual network)的使用</h3><p>另一个细节，就是哪里跑不掉的resNet的使用：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/resInEncoder.png" srcset="/img/loading.gif" class="" title="resNet的使用"><p>同样，在decoder中也使用到了resNet，如果是一个2个encoder和decoder的transformer，它长这样：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/resInTransformer.png" srcset="/img/loading.gif" class="" title="resNet的使用2"><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>介绍完Encoder，大多数Decoder里的组件的作用也明朗了。接下来看看他哥俩如何一起工作。</p><p>再贴一下模型结构图：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/structureOfTransformer.png" srcset="/img/loading.gif" class="" title="transformer结构"><p>可以看到Decoder中有一个 Encoder-Decoder Attention 层，它接受Encoder部分最后的输出作为计算attention的Key和Value，接受它下面的self-attention层的输出作为Query。</p><p>其次，Decoder部分的self-attention层也与Encoder中的不同，不同于Encoder中计算单词两两间的attention，Decoder中计算的是当前单词和它前面的单词的attention，同样，也要加入位置信息。</p><p>文章中有张非常形象的动图：</p><img src="/2020/04/02/Transformer%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B-%E7%AC%94%E8%AE%B0/transformerDecodingGif.gif" srcset="/img/loading.gif" class="" title="transformer结构"><p>注意在decoder中做self-attention的时候，当前输入只应该看到当前时刻以前的输出，比如在输出第二个词的时候，输入中是不应该出现第三个词的信息的。文中处理这种情况的方法是用了一个倒三角矩阵(第i行j列的元素表示第i个输入和第j个输入的attention)，将对角线右侧元素全部设置为负无穷，这样就防止了模型看到未来的信息。</p><h2 id="最后一层"><a href="#最后一层" class="headerlink" title="最后一层"></a>最后一层</h2><p>decoder将输出一堆floats组成的向量，将它转换成词语，就是最后一层的工作(通常是一个Linear+Softmax)。</p><p>Linear layer是一个简单的全连接层，将decoder的输出投射为一个比原来大很多的向量，叫做logits vector。</p><p>如果我们的词空间有10000个单词，那么10000就是这个logits vector的维度，向量中每个元素对应一个具体的词。接下来你就清楚了，softmax的作用是将这个logits vector的结果变成概率，概率最高的元素对应的词就是我们的输出。</p><h2 id="关于训练"><a href="#关于训练" class="headerlink" title="关于训练"></a>关于训练</h2><p>todo…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>todo…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a><br><a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a><br><a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">哈佛大学的pytorch版本源码</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个简单的人脸识别系统</title>
    <link href="/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>下述的大多数方法来自 <strong><em><a href="https://arxiv.org/pdf/1503.03832.pdf" target="_blank" rel="noopener">FaceNet</a></em></strong>,也叫做<strong><em>DeepFace</em></strong>.</p><h2 id="脸部识别"><a href="#脸部识别" class="headerlink" title="脸部识别"></a>脸部识别</h2><p>一般来说，脸部识别问题可以分为两类：</p><ul><li>脸部验证(Face Verification)：”这是某个人吗？” 通过提供的输入的数据来识别是否是某个确定的人。比如机场系统扫描你的护照来确认你是否是正确的持有人，比如移动手机通过识别你的脸部确认你是拥有者从而解锁。总的来说，这是一个1对1匹配的问题。</li><li>脸部识别(Face Recognition)：”这是谁？” 通过提供的输入识别来识别对应的人是谁。比如公司的脸部识别打卡，通过识别脸部直接完成对应人员的打卡。总的来说，这是一个1对K的匹配问题。</li></ul><p>FaceNet 通过一个神经网络先将输入的脸部照片解码为一个128维向量，通过比较2个这样的向量，从而判断这两张图片是否是一个人。将输入数据与数据库中所有人员的照片进行对比，从而找到”这是谁”。</p><p>我们将用TensorFlow来实现这个程序：(tensorflow 1.X)</p><ul><li>1.实现三元损失函数</li><li>2.用一个预训练的模型来将脸部图片解码为128维的向量</li><li>3.使用这些代码来进行脸部验证和脸部识别</li></ul><p>另外，我们使用通道优先(channels-first)。 也就是说对于输入数据的维度表示，我们使用(m,nC,nH,nW), 而不是(m,nH,nW,nC)。当然，channels-first 和 channels-last都有各自的理由，至今社区也没有一个统一的标准。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>先导入包</p><pre><code class="hljs plain">from keras.models import Sequentialfrom keras.layers import Conv2D, ZeroPadding2D, Activation, Input, concatenatefrom keras.models import Modelfrom keras.layers.normalization import BatchNormalizationfrom keras.layers.pooling import MaxPooling2D, AveragePooling2Dfrom keras.layers.merge import Concatenatefrom keras.layers.core import Lambda, Flatten, Densefrom keras.initializers import glorot_uniformfrom keras.engine.topology import Layerfrom keras import backend as KK.set_image_data_format(&#39;channels_first&#39;)import cv2import osimport numpy as npfrom numpy import genfromtxtimport pandas as pdimport tensorflow as tffrom fr_utils import *from inception_blocks_v2 import *np.set_printoptions(threshold&#x3D;np.nan)</code></pre><hr><h2 id="0-简陋的脸部识别"><a href="#0-简陋的脸部识别" class="headerlink" title="0.简陋的脸部识别"></a>0.简陋的脸部识别</h2><p>在脸部验证中，你需要确定给到的两张图片是否是一个人。最简单的方法就是直接将两张图片一个像素一个像素的进行比较。如果两张图片间的间距小于某个阈值，他们可能就是一个人。</p><img src="/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/LisaFaceReco.png" srcset="/img/loading.gif" class="" title="逐像素比较"><p>不难想到这个算法的表现会很差。因为光线的变化、人物脸部方向、甚至是头部位置的微小变化，都会导致像素值的改变。</p><p>与其使用原图片，我们可以使用编码后的图片数据。即f(img)。</p><p>将图片编码后的数据进行元素级的比较，我们可以得到一个更加准确的关于脸部验证的结果。</p><hr><h2 id="1-将脸部图片编码为128维的向量"><a href="#1-将脸部图片编码为128维的向量" class="headerlink" title="1.将脸部图片编码为128维的向量"></a>1.将脸部图片编码为128维的向量</h2><h3 id="1-1-使用卷积网络来进行编码"><a href="#1-1-使用卷积网络来进行编码" class="headerlink" title="1.1 使用卷积网络来进行编码"></a>1.1 使用卷积网络来进行编码</h3><p>FaceNet模型需要使用非常多的数据和很长的时间来进行训练。这里我们跳过这个步骤，直接载入别人已经训练好的权重。 网络结构采用了 <a href="https://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Szegedy等人</a>文中的inception模型。 我们使用一个已经实现好的inception network的实现(在inception_blocks_v2.py中，略)。</p><p>几个需要知道的知识点：</p><ul><li>这个网络采用96×96维度的RGB图像作为输入。特别地，输入一个脸部照片(或者多批次的m照片组)作为张量，形状为：(m,nC,nH,nW) = (m,3,96,96)</li><li>它将输出一个(m,128)的矩阵，即将每一张图片都编码为128维的向量。</li></ul><pre><code class="hljs plain">FRmodel &#x3D; faceRecoModel(input_shape&#x3D;(3, 96, 96))print(&quot;Total Params:&quot;, FRmodel.count_params())</code></pre><p>输出：Total Params: 3743280</p><p>通过使用一个128元的全连接层作为它的最后一层，这就保证了模型将输出128维的向量。接着，使用这两个向量进行两张图片的比较：</p><p>如果编码符合以下判别标准，则是一个好的编码:</p><ul><li>对同一个人的不同图片的编码较为相似</li><li>对不同人的图片的编码差异较大</li></ul><p>三元损失函数将以上标准公式化了，并且试图将相同人的图片的编码缩小，将不同人图片的编码拉大。</p><h3 id="1-2-三元损失函数对于一张图片x，我们声明它的编码为f-x-f是由神经网络计算的方法。"><a href="#1-2-三元损失函数对于一张图片x，我们声明它的编码为f-x-f是由神经网络计算的方法。" class="headerlink" title="1.2 三元损失函数对于一张图片x，我们声明它的编码为f(x), f是由神经网络计算的方法。"></a>1.2 三元损失函数对于一张图片x，我们声明它的编码为f(x), f是由神经网络计算的方法。</h3><img src="/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/FaceNetFx.png" srcset="/img/loading.gif" class="" title="f(x)方法"><p>三元损失函数的训练需要用到三元组数据，每个三元组包含三张图片(A,P,N)</p><ul><li>A 是一张锚图片 - 某人的头部图像</li><li>P 是一张”正”图片 - 与A图片中是同一个人物</li><li>N 是一张”负”图片 - 与A图片中不是同一个人物</li></ul><p>我们用(A(i),P(i),N(i))(都是上标)来声明第i个训练样本。<br>我们希望图A(i)与P(i)的距离至少比A(i)和N(i)的距离近至少一个α的值：</p><img src="/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/lossFormulaSingle.png" srcset="/img/loading.gif" class="" title="单个样本的三元损失公式"><p>那么总的损失函数就是：</p><img src="/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/lossFormulaTotal.png" srcset="/img/loading.gif" class="" title="三元损失公式"><p>[z]+表示 max(z,0)。表示一旦A与P距离和A与N距离达到我们的要求，损失就为0，否则它的值就是损失值。</p><p><strong><em>Notes:</em></strong></p><ul><li>公式中的第一个部分是锚图片A和正图片P的距离，你希望它尽可能的小</li><li>公式的第二个部分则是锚图片A和负图片N的距离，你希望它相对较大</li><li>α叫做边距(margin)，这是一个人为选择的超参数，我们使用 α = 0.2</li></ul><p>大多数的实现里会将编码后的向量进行一次L2归一化，这里我们不用担心~</p><p>实现上面公式中的三元损失函数，需要4个步骤：</p><ol><li>计算锚图片A和正图片P间的距离</li><li>计算锚图片A和负图片N间的距离</li><li>对每个三元组样本进行公式计算</li><li>将每组样本经步骤3得到的值与0取max并取和</li></ol><p>PS：</p><img src="/2020/03/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/L2formula.png" srcset="/img/loading.gif" class="" title="L2 Norm计算方法"><pre><code class="hljs plain">def triplet_loss(y_true, y_pred, alpha &#x3D; 0.2):    &quot;&quot;&quot;    三元损失函数的实现        Arguments:    y_true -- true 标签, 当你在keras中定义loss时需要, 在这个方法中你不需要它.    y_pred -- python list 包含三个对象:            anchor -- 锚图片编码后的结果, 形状为 (None, 128)            positive -- 正图片编码后的结果, 形状为(None, 128)            negative -- 负图片编码后的结果, 形状为 (None, 128)        Returns:    loss -- 数字, 损失值    &quot;&quot;&quot;        anchor, positive, negative &#x3D; y_pred[0], y_pred[1], y_pred[2]        # Step 1    pos_dist &#x3D; tf.reduce_sum(tf.square(tf.subtract(anchor,positive)),-1)    # Step 2    neg_dist &#x3D; tf.reduce_sum(tf.square(tf.subtract(anchor,negative)),-1)    # Step 3    basic_loss &#x3D; tf.maximum(tf.add(tf.subtract(pos_dist,neg_dist),alpha),0)    # Step 4    loss &#x3D; tf.reduce_sum(basic_loss)        return loss</code></pre><hr><h2 id="2-载入预训练模型"><a href="#2-载入预训练模型" class="headerlink" title="2.载入预训练模型"></a>2.载入预训练模型</h2><p>FaceNet通过最小化三元损失函数来进行训练。但训练需要大量的数据和计算时间，这里我们就不从头训练了。我们直接读取一个预训练的模型。用下面的代码读取来读取一个模型：</p><pre><code class="hljs plain">FRmodel.compile(optimizer &#x3D; &#39;adam&#39;, loss &#x3D; triplet_loss, metrics &#x3D; [&#39;accuracy&#39;])load_weights_from_FaceNet(FRmodel)</code></pre><hr><h2 id="3-应用模型"><a href="#3-应用模型" class="headerlink" title="3.应用模型"></a>3.应用模型</h2><p>假定我们构建的这个系统是一个门禁系统，用于给某公司利用脸部识别来确定是否允许某人进入公司建筑。</p><p>要通过门禁，每个人要先在入口处刷门禁卡，脸部识别系统会识别他们是否是他们所声明的人。</p><h3 id="3-1-脸部识别"><a href="#3-1-脸部识别" class="headerlink" title="3.1 脸部识别"></a>3.1 脸部识别</h3><p>我们先建立一个数据库，它存放了所有被允许进入建筑人员的编码后向量数据。它将用到img_to_encoding(image_path,model)方法，这个方法在输入图片数据上通过模型的前向传播来获得结果。</p><p>因为是教程，简便起见，我们直接用一个dict来充当数据库：</p><pre><code class="hljs plain">database &#x3D; &#123;&#125;database[&quot;danielle&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;danielle.png&quot;, FRmodel)database[&quot;younes&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;younes.jpg&quot;, FRmodel)database[&quot;tian&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;tian.jpg&quot;, FRmodel)database[&quot;andrew&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;andrew.jpg&quot;, FRmodel)database[&quot;kian&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;kian.jpg&quot;, FRmodel)database[&quot;dan&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;dan.jpg&quot;, FRmodel)database[&quot;sebastiano&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;sebastiano.jpg&quot;, FRmodel)database[&quot;bertrand&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;bertrand.jpg&quot;, FRmodel)database[&quot;kevin&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;kevin.jpg&quot;, FRmodel)database[&quot;felix&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;felix.jpg&quot;, FRmodel)database[&quot;benoit&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;benoit.jpg&quot;, FRmodel)database[&quot;arnaud&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;arnaud.jpg&quot;, FRmodel)</code></pre><p>接下来，当一个人走到前门处并刷卡，你就可以从数据库中查找他的编码，然后再进行脸部匹配，主要以下几个步骤：</p><ol><li>将前门摄像机捕捉的图片进行编码</li><li>计算上一步的编码与数据库中找到的对应id人员的编码间的间距</li><li>如果间距小于0.7，开门</li></ol><pre><code class="hljs plain">def verify(image_path, identity, database, model):    &quot;&quot;&quot;    验证存放在image_path中的人是否和数据库identity对应的人是同一个        参数:    image_path -- 图片地址    identity -- string, 要识别者的名字(来自于刷卡id). 必须是建筑进入允许的人员.    database -- python dictionary 数据字典 人名:头像编码 (向量).    model -- keras的 inception 模型        Returns:    dist -- image_path存储的图像和identity对应的图像的间距    door_open -- True代表开门，False代表不开门    &quot;&quot;&quot;        # Step 1:    encoding &#x3D; img_to_encoding(image_path,model)        # Step 2:     dist &#x3D; np.linalg.norm(encoding - database[identity])    # Step 3:     if dist &lt; 0.7:        print(&quot;It&#39;s &quot; + str(identity) + &quot;, welcome in!&quot;)        door_open &#x3D; True    else:        print(&quot;It&#39;s not &quot; + str(identity) + &quot;, please go away&quot;)        door_open &#x3D; False            return dist, door_open</code></pre><p>用了 <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html" target="_blank" rel="noopener">np.linalg.norm</a>来计算间距，不传递第二个参数即计算F-范数。</p><p>我们传入一张正确的图片试一试：</p><pre><code class="hljs plain">verify(&quot;images&#x2F;camera_0.jpg&quot;, &quot;younes&quot;, database, FRmodel)</code></pre><p>输出：It’s younes, welcome in!</p><p>再来一张错误的呢：</p><pre><code class="hljs plain">verify(&quot;images&#x2F;camera_2.jpg&quot;, &quot;kian&quot;, database, FRmodel)</code></pre><p>输出：It’s not kian, please go away</p><h3 id="3-2-脸部识别"><a href="#3-2-脸部识别" class="headerlink" title="3.2 脸部识别"></a>3.2 脸部识别</h3><p>脸部认证系统基本完成了，但是如果系统内某人丢失了ID卡，他再次回到办公室就不能再进去了！(需要刷卡)</p><p>要解决这个问题，你就需要将系统改造成一个脸部识别系统。这样大家就都不需要带id卡了。一个被授权的人只要走到前门，门就会自动打开！</p><p>很简单，只需要一个遍历，直接上代码即可：</p><pre><code class="hljs plain">def who_is_it(image_path, database, model):    &quot;&quot;&quot;    实现脸部识别系统，识别image_path图片人的身份        Arguments:    略        Returns:    min_dist -- image_path图片与数据库中图片的最小间距    identity -- 最小间距对应的人    &quot;&quot;&quot;        encoding &#x3D; img_to_encoding(image_path,model)            # 初始化最小值，整大点    min_dist &#x3D; 100        for (name, db_enc) in database.items():                dist &#x3D; np.linalg.norm(encoding - db_enc)        if dist &lt; min_dist:            min_dist &#x3D; dist            identity &#x3D; name    if min_dist &gt; 0.7:        print(&quot;Not in the database.&quot;)    else:        print (&quot;it&#39;s &quot; + str(identity) + &quot;, the distance is &quot; + str(min_dist))            return min_dist, identity</code></pre><p>试一下：</p><pre><code class="hljs plain">who_is_it(&quot;images&#x2F;camera_0.jpg&quot;, database, FRmodel)</code></pre><p>输出：it’s younes, the distance is 0.659393</p><p>激动人心的时候来了，我们把Lisa的图片裁剪成96×96再放入：</p>{% asset_img Lisa.png Lisa %} {% asset_img camera_Lisa.png LisaInCamera %}<pre><code class="hljs plain">database[&quot;lisa&quot;] &#x3D; img_to_encoding(&quot;images&#x2F;Lisa.png&quot;, FRmodel)who_is_it(&quot;images&#x2F;camera_Lisa.png&quot;, database, FRmodel)</code></pre><p>输出： it’s lisa, the distance is 0.597898<br>成功！！！</p><p>这样，一个简陋版本的脸部识别系统就完成啦！</p><h3 id="一些提升的方法"><a href="#一些提升的方法" class="headerlink" title="一些提升的方法"></a>一些提升的方法</h3><p>这里就不一一实现了，还有一些可以提升算法效果的方法：</p><ul><li>对于每个人，多在数据库中放几张照片，比如不同角度的，不同光线的，不同时间的。在刷脸时，将之与数据库中每个人的多张图片进行比较，这样可以提高模型准确度。</li><li>运用一个裁剪算法，将图片尽量剪到只剩下脸部。这样可以尽量排除不相关因素的干扰，也能提高准确度。</li></ul><hr><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><ul><li>Florian Schroff, Dmitry Kalenichenko, James Philbin (2015). <a href="https://arxiv.org/pdf/1503.03832.pdf" target="_blank" rel="noopener">FaceNet: A Unified Embedding for Face Recognition and Clustering</a></li><li>Yaniv Taigman, Ming Yang, Marc’Aurelio Ranzato, Lior Wolf (2014). <a href="https://research.fb.com/wp-content/uploads/2016/11/deepface-closing-the-gap-to-human-level-performance-in-face-verification.pdf" target="_blank" rel="noopener">DeepFace: Closing the gap to human-level performance in face verification</a></li><li>The pretrained model we use is inspired by Victor Sy Wang’s implementation and was loaded using his code: <a href="https://github.com/iwantooxxoox/Keras-OpenFace" target="_blank" rel="noopener">https://github.com/iwantooxxoox/Keras-OpenFace</a>.</li><li>Our implementation also took a lot of inspiration from the official FaceNet github repository: <a href="https://github.com/davidsandberg/facenet" target="_blank" rel="noopener">https://github.com/davidsandberg/facenet</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络介绍</title>
    <link href="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传统的神经网络的全连接层(full connected)在遭遇较大的输入数据时，需要训练的参数将会非常多。举个例子，一张1000×1000的图片，作flatten处理后就有了1000×1000×3的输入维度，如果第二层的隐藏单元数是1000，参数W的维度就是3000000×1000。<br>参数过多，就意味着训练难度变高。在这种情况下，卷积神经网络就诞生了。</p><h2 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h2><p>我们先来看一下最基础的一点：什么是卷积？</p><p>用一个例子来进行说明，假如我们有一张6×6的图片，为了方便理解，我们暂时假定它第三个维度为1，即通道数为1。那么一次卷积操作如下：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/conv01.png" srcset="/img/loading.gif" class="" title="卷积1"><p>如上图所示，左一的6×6矩阵代表我们的输入矩阵，中间的3×3矩阵叫做过滤器(filter)，也叫做卷积核，而二者中间的”*“就表示<strong><em>卷积</em></strong>，它和计算机中的乘法符号一致。</p><p>卷积的运算方法就是 从输入矩阵的左上角开始，从左到右每一次取出一个与卷积核维度一样大小的矩阵，这里是3×3。 将取出的矩阵的每一位与卷积核对应为相乘并相加，得到的数据填在右侧结果矩阵的对应位置。</p><p>第二步如下：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/conv02.png" srcset="/img/loading.gif" class="" title="卷积2"><p>以此类推，往右不能再走时，就向下移动一行，再次从最左边开始取。<br>这样，最终我们可以得到一个4×4的结果矩阵(一张变小的图片)。</p><h3 id="卷积在做什么"><a href="#卷积在做什么" class="headerlink" title="卷积在做什么"></a>卷积在做什么</h3><p>你可能会感到困惑，这样的一步所谓的操作到底做了些什么。<br>就我们上面的例子来说，这样一个卷积核的效果可以用六个字来概括：“垂直边缘检测”。<br>如下：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/conv03.png" srcset="/img/loading.gif" class="" title="卷积3"><p>可以看到，结果图片的中部有一道明显的白色，这就是检测出来的垂直边缘。是的，它看起来与左边的输入图片有些不符合，显得比较厚，这是因为我们选择的图片较小(才6×6)，当把图片变大时，结果就变得较为可观了。</p><p>既然有垂直边缘检测的卷积核，自然就有其它功能的卷积核，比如水平边缘检测卷积核，比如着重突出某些边缘特征的卷积核等。</p><p>而卷积核的值是可以通过训练得到的，这点我们将在后面介绍。</p><h2 id="填充-padding"><a href="#填充-padding" class="headerlink" title="填充-padding"></a>填充-padding</h2><p>除了卷积，conv网络的第二个重要的积木就是<strong><em>填充</em></strong>。</p><p>在上一节介绍卷积时，一个6×6的图片经过一次卷积操作变成了4×4，可见卷积操作是会让输入数据的维度降低的。这样的操作多来几次，再大的图片也遭不住。因此，为了构建深层网络，填充就必不可少。</p><p>首先，关于卷积操作减小维度，是有一个通用的计算公式的：<br><strong><em>结果矩阵的维度 = (n-f+1) × (n-f+1)</em></strong><br>其中f为卷积核的维度，n为输入矩阵的维度。</p><p>除了会减小图片的维度外，卷积还会导致图片角落的像素只能被使用到一次，而中间的数据则会被使用多次，这样会导致图片边缘的数据不能得到足够的利用，甚至被丢失了。</p><p>所以所谓填充，就是填充数据的边缘：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/padding01.png" srcset="/img/loading.gif" class="" title="填充1"><p>通过在原图片边缘填充一层使之变成8×8的图像，从而经过卷积操作后，你依然可以得到一个6×6的图像。</p><p>一般来说，在卷积网络中大多数时候使用这样的填充，即使数据在填充后进行卷积得到与原数据同样维度的数据。这样的卷积操作我们称之为<strong><em>same卷积</em></strong>。</p><p>除此之外还有full卷积和valid卷积，前者让图像最角落的元素也可以被充分利用，而后者则是不做填充。</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/padding02.png" srcset="/img/loading.gif" class="" title="full卷积"><p>上图为full卷积</p><h2 id="步幅-stride-卷积"><a href="#步幅-stride-卷积" class="headerlink" title="步幅(stride)卷积"></a>步幅(stride)卷积</h2><p>在之前的介绍中，我们每次计算卷积后，都是在原图片上向右或者向下移动一步。而步幅卷积，顾名思义，就是将这个一步扩展开来，每次移动s步，我们以2为例：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/stride01.png" srcset="/img/loading.gif" class="" title="步幅卷积1"><p>如上为第一步和第二步，此外，当需要向下移动时，也是移动s步</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/stride03.png" srcset="/img/loading.gif" class="" title="步幅卷积3"><p>容易计算，经过步幅为s的卷积后，结果矩阵维度的计算方式为：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/strideFormula.png" srcset="/img/loading.gif" class="" title="步幅卷积结果矩阵维度公式"><p>假如当向右移动s步已经超出了原矩阵范围，即当不能被整除的时候，就直接舍弃剩余部分直接向下走了。即向下取整。</p><h2 id="三维数据的卷积"><a href="#三维数据的卷积" class="headerlink" title="三维数据的卷积"></a>三维数据的卷积</h2><p>对于现实情况中的图片来说，因为RGB格式的存在，我们的输入数据大多都是3维的，那么，如何将卷积扩展到三维数据上去呢？</p><p>首先，卷积核（过滤器）也要变成三维，且第三个维度要和原矩阵相同(第三个维度在卷积中我们一般叫做<strong><em>通道</em></strong>)，如下：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/convIn3D01.png" srcset="/img/loading.gif" class="" title="三维数据卷积01"><p>可以看到，最终的结果是一个4*4的矩阵，没有了第三个维度，计算方法其实很简单，基本就是二维计算方式的三维扩展：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/convIn3D02.png" srcset="/img/loading.gif" class="" title="三维数据卷积02"><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/convIn3D03.png" srcset="/img/loading.gif" class="" title="三维数据卷积03"><p>即把每个3×3×3 = 27个格子的数字对应相乘并相加，然后右移和下移即可，因为深度一致，并不需要关心第三个维度。</p><p>卷积核的设计很灵活，假如你把卷积核的第二层和第三层都设置为0，相当于在结果矩阵中就只有你对第一层的卷积，在RGB图片中，你就只检测了红色通道的边缘。</p><p>更常用的是，你可以同时使用多个卷积核，然后把得到的结果堆叠，得到通道数大于1的结果：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/convIn3D04.png" srcset="/img/loading.gif" class="" title="三维数据卷积04"><p><strong>所以卷积结果矩阵的通道数，取决于卷积核的数量，记住这一点。</strong></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>介绍了这么多，我们拉通来看一下，把上述知识点结合起来，就是卷积神经网络的一层：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/aLayerInConvNet.png" srcset="/img/loading.gif" class="" title="卷及网络中的一层"><p>之前我们说过，每一个过滤器(卷积核)都相当于是过滤出原数据的一个特性。上图中，用了2个过滤器，将每个过滤器得到的结果再进行一次激活。激活函数可以说是神经网络中的一种重要工具，一般是一个非线性函数，可以简单地理解为将数据中的特点放大并且保证了多层网络的实用性。激活之后再重叠在一起，就得到了我们最后4×4×2的结果。</p><p>如果你知道普通神经网络的结构，它每一层的运算就是先进行 z[l] = W*a[l-1] + b[l]，再进行 a[l] = g(z[l])。可以看到对于我们的卷积神经网络，这一层的操作，也可以对应成这个公式，过滤器就是我们的W。</p><p>既然过滤器是我们W，上面我们也说过过滤器的值可以训练，那么这么一层卷积网络，我们需要训练多少参数呢？<br>假设我们有10个3×3×3的过滤器，那么我们需要 3×3×3×10 + 10(b参数，偏差值) 个，即280个参数。</p><h3 id="ConvNet中的符号"><a href="#ConvNet中的符号" class="headerlink" title="ConvNet中的符号"></a>ConvNet中的符号</h3><p>在卷积网络中，你会看到很多各种符号以及参数、中间值，结果的维度，我们稍作总结：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/notaionInConvNet.png" srcset="/img/loading.gif" class="" title="卷积网络中的符号"><p>以上就是卷积网络中的一层了，那么我们如何扩展它来构建一个卷积网络呢？</p><p>PS: ConvNet是卷积神经网络的简写</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>现在假如你有一些照片，你想通过卷积网络来实现图片的分类，假如输入图片的大小为39×39×3：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/aBriefConvNet.png" srcset="/img/loading.gif" class="" title="一个简单的卷积网络结构"><p>接着，我们可以把最后这个7×7×40的矩阵展开成1960的向量，接着我们可以使用普通神经网络的手段，使用逻辑回归或者一个softmax层来进行最后结果的计算。</p><p>从上面可以看出一个大多数卷积神经网络的趋势，即随着层数的增加，矩阵的宽高会逐渐减小，而通道数量会逐渐增加。</p><h3 id="其它的层类型"><a href="#其它的层类型" class="headerlink" title="其它的层类型"></a>其它的层类型</h3><p>上面的网络中，这些使用卷积核的层都可以叫做卷积层，但神经网络层中还有一些其他的层类型，比如池化(pooling)层，全连接(full connect/FC)层等。<br>将卷积层与这二者结合，我们可以搭建出更好的卷积神经网络。</p><h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>在ConvNet中，经常会使用一种叫做池化层(pooling layer)的结构来减小表示层的大小，从而加快模型训练，甚至更好的发现一些特性。</p><p>下面介绍两种池化层</p><h3 id="最大值-Max-池化"><a href="#最大值-Max-池化" class="headerlink" title="最大值(Max)池化"></a>最大值(Max)池化</h3><p>非常简单，如下：</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/maxPooling.png" srcset="/img/loading.gif" class="" title="最大值池化"><p>虽然很简单，但max池化在很多的实际应用中都有很好的效果。为什么呢？<br>直白的理解一下，加入你把这个4×4的区域看作某个特征的集合，即神经网络某个层中的激活状态，那么一个大的数字意味着算法可能检测到了一个特定的特征，如上图左上的2*2区域就有这样的特征，8被挑选并保留下来，它可能是一个垂直边缘，可能是一个任何难以描述的特征，而右上区域没有这样的特征，它的最大值依然很小。<br>所以，max pooling作所做的其实是 ，如果在过滤器中任何地方检测到了任何特征，就保留最大的数值。<br>反之，如果没有明显的特征被检测到，比如右上方的四分之一区域就没有这个特征，在结果中那些数值的最大值仍然相当小。</p><h3 id="平均值池化"><a href="#平均值池化" class="headerlink" title="平均值池化"></a>平均值池化</h3><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/avgPooling.png" srcset="/img/loading.gif" class="" title="平均值池化"><p>就不介绍了…</p><h3 id="池化层特点"><a href="#池化层特点" class="headerlink" title="池化层特点"></a>池化层特点</h3><p>最大值池化的使用通常比均值池化多得多。<br>也许你注意到了，大多数池化层都不需要学习超参数，只要确定了f和s，计算就确定了。<br>而且如果输入数据是3维的，则结果中通道数量依然保持，即每一层都像第一层一样进行过滤。</p><h2 id="卷积网络样例"><a href="#卷积网络样例" class="headerlink" title="卷积网络样例"></a>卷积网络样例</h2><p>todo…</p><h2 id="卷积为什么有用"><a href="#卷积为什么有用" class="headerlink" title="卷积为什么有用"></a>卷积为什么有用</h2><p>比起一般的全连接神经网络，卷积神经网络主要有2个优势，参数共享和连接稀疏性。</p><img src="/2020/03/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/whyCcnvWork.png" srcset="/img/loading.gif" class="" title="例图"> <p>举个例子，如上图，第一层共32×32×3 = 3072个输入，第二层共4704个输出。使用如上所示的卷积，我们只需要(5×5×3+1)×6一共456个参数。而如果我们使用全连接层，我们需要多少参数呢？一共3072×4704个参数，多太多了。</p><p>卷积网络的参数少，主要是两个原因。</p><h3 id="参数共享"><a href="#参数共享" class="headerlink" title="参数共享"></a>参数共享</h3><p>每一次卷积的时候，我们的卷积核一直被轮流地使用，输入数据的每一个部分都与过滤器进行了计算。<br>所谓共享即卷积核的共享。</p><h3 id="连接的稀疏性"><a href="#连接的稀疏性" class="headerlink" title="连接的稀疏性"></a>连接的稀疏性</h3><p>也很好理解，比如看上图，卷积后结果矩阵的每一个值，都只是原输入数据的一个3*3的数据与过滤器发生计算得到的，不像全连接要关联所有输入值。</p><p>更多，也有人说卷积可以捕捉平移不变，即是说一张图片的像素右移或左移了一些像素，它们依然应该有相同的特征。卷积可以给他们打上相同的标签。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是卷积神经网络的基本概念，通过tensorflow等软件包你也可以很轻松的实现各种自定义的网络类型。但一般的实际应用中，并不推荐自由构建网络结构，因为卷积网络的训练时间普遍较长，所以当你要建立一个卷积网络来解决一个新的问题时，去尝试想当然的网络结构往往得不偿失。一个好的方法就是多从各大论文或者成功模型的分享中获得灵感，在别人推荐的模型和超参数的基础上构建你的网络，才能事半功倍。</p><p>之后会介绍一些经典的卷积网络模型。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
